C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE RX8010
OBJECT MODULE PLACED IN ..\OBJ\RX8010.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\HARDWARE\RX8010\RX8010.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE O
                    -RDER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDW
                    -ARE\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\RX8010.lst) TABS(2) OBJ
                    -ECT(..\OBJ\RX8010.obj)

line level    source

   1           //#include "STC12C32AD.h"
   2           #include "all.h" 
   3           //#include "delay.h"
   4           //#include "RX8010.h"
   5          
   6           
   7          #define SCL          P25
   8          #define SDA          P26
   9          #define ASK            0
  10          #define NO_ASK         1
  11          #define OUT_LOW        0
  12          #define INPUT_HIGH     1
  13          
  14          #define SCL_DIR_OUTPUT()   P2M1 |= 0x10;P2M0 |= 0x10  //11 开漏输出
  15          #define SDA_DIR_INPUT()    P2M1 |= 0x40;P2M0 &= 0xBF  //10 仅为输入
  16          #define SDA_DIR_OUTPUT()   P2M1 |= 0x40;P2M0 |= 0x40  //11 开漏输出
  17          
  18          #define RX8010_WRITE  0x64 //I2C器件地址
  19          #define RX8010_READ   0x65
  20          
  21          //2019.03.29
  22          sfr WDT_CONTR = 0xC1;
  23          sbit EA       = 0xA8^7;
  24          sbit P25 = 0xA0^5;
  25          sbit P26 = 0xA0^6;
  26          sfr P2M0 = 0x96;
  27          sfr P2M1 = 0x95;
  28          
  29          ///************************************
  30          //** 函数原型: void IC_start(void); **
  31          //** 功 能: IC 总线起始位. **
  32          //************************************/
  33          static void IC_start(void)
  34          { 
  35   1          SCL_DIR_OUTPUT();
  36   1          SDA_DIR_OUTPUT();   
  37   1          SCL=1;
  38   1          SDA=1;
  39   1          delay_us(2);
  40   1          SDA=0;
  41   1          delay_us(2);//
  42   1          SCL=0;
  43   1      }
  44          
  45          ////**********************************
  46          ////** 函数原型: void IC_stop(void); **
  47          ////** 功 能: IC 总线停止位. **
  48          ////**********************************/
  49          static void IC_stop(void)
  50          {
  51   1          SCL=0;
  52   1          SDA_DIR_OUTPUT();
C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 2   

  53   1          SDA=0;
  54   1          delay_us(2);
  55   1          SCL=1;
  56   1          delay_us(2); //
  57   1          SDA=1;
  58   1          delay_us(2);
  59   1      }
  60          
  61          /////***************************************************
  62          ////** 函数原型: bit IC_writebyte(uchar wdata); **
  63          ////** 功 能: 向IC 总线发送8 位数据,并请求一个应答信 **
  64          ////** 号ACK.如果收到ACK 应答则返回1(TRUE), **
  65          ////** 否则返回0(FALSE). **
  66          ////***************************************************/
  67          static unsigned char IC_WriteByte( unsigned char wdata)
  68          {
  69   1        unsigned char i;
  70   1        SDA_DIR_OUTPUT();
  71   1        for(i=0;i<8;i++)
  72   1        {
  73   2          SCL=0;
  74   2          delay_us(2);
  75   2          if(wdata&0x80) SDA=1;
  76   2          else SDA=0;
  77   2          delay_us(2);
  78   2          SCL=1;
  79   2          delay_us(4);
  80   2          wdata<<=1;
  81   2        }
  82   1        SCL=0;
  83   1        delay_us(4);
  84   1        SDA_DIR_INPUT();
  85   1        SCL=1;
  86   1        delay_us(4);
  87   1        i=0;
  88   1        while(SDA)
  89   1        {
  90   2          if(++i>12){SCL=0;return(0);}
  91   2        }
  92   1        SCL=0;
  93   1        return(1);
  94   1      }
  95          /////***********************************************
  96          ////** 函数原型: uchar IC_readbyte(void); **
  97          ////** 功 能: 从IC 总线上接收8 位数据,并将接受到 **
  98          ////** 8 位数据作为一个字节返回,不回送应 **
  99          ////** 答信号ACK. **
 100          ////***********************************************/
 101          static unsigned char IC_ReadByte(void)
 102          { 
 103   1        unsigned char i;
 104   1        unsigned char IC_data=0;
 105   1        SCL=0;
 106   1        SDA_DIR_OUTPUT();
 107   1        SDA=1;
 108   1        SDA_DIR_INPUT();  
 109   1        for(i=0;i<8;i++)
 110   1        {
 111   2          SCL=1;
 112   2          delay_us(2);
 113   2          IC_data<<=1;
 114   2          IC_data|=SDA;
C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 3   

 115   2          //delay_us(4);
 116   2          SCL=1;
 117   2          delay_us(2);
 118   2          SCL=0;
 119   2          delay_us(4);
 120   2        }
 121   1        delay_us(4);
 122   1        SCL=0;
 123   1        SDA_DIR_OUTPUT();
 124   1        SDA=0;
 125   1        return(IC_data);
 126   1      }
 127          /////***************************************************************
 128          ////** 函数原型: bit readEEone(uchar instr,uchar addr,uchar num); **
 129          ////** 功 能: 从8010 中读取num 个字节的数据,采用序列读操作方 **
 130          ////** 式从片内Address 地址开始连续读取数据.8010 不接 **
 131          ////** 受指定的地址则返回0(FALSE). **
 132          ////***************************************************************/
 133          unsigned char readEEone(unsigned char addr,unsigned char num,unsigned char *Data)
 134          {
 135   1        unsigned char i;
 136   1        IC_start();
 137   1        if(IC_WriteByte(RX8010_WRITE)==0)
 138   1        {
 139   2          IC_stop(); return(0);
 140   2        }
 141   1        if(IC_WriteByte(addr)==0)
 142   1        {
 143   2          IC_stop(); return(0);
 144   2        }
 145   1          IC_start();
 146   1        if(IC_WriteByte(RX8010_READ)==0)
 147   1        {
 148   2          IC_stop(); return(0);
 149   2        }
 150   1        for(i=0;i<num-1;i++)
 151   1        {
 152   2          Data[i]=IC_ReadByte();
 153   2          SDA_DIR_OUTPUT();       
 154   2          SDA=0; /** Send ACK **/   
 155   2          SCL=1;
 156   2        }
 157   1        Data[num-1]=IC_ReadByte();
 158   1        SDA_DIR_OUTPUT(); 
 159   1        SDA=1; /** Send Read End **/
 160   1        delay_us(4);
 161   1        SCL=1;
 162   1        IC_stop();
 163   1        return(1);
 164   1      }
 165          
 166          ///****************************************************************
 167          //** 函数原型: bit writeEEone(uchar instr,uchar addr,uchar num); **
 168          //** 功 能: 将EEbuf[]单元中的数据写入8010 的num 个字节. **
 169          //** 采用页写操作方式,每次写入时都需要指定片内地址. **
 170          //** 如果8010 不接受指定的地址或某个传送的字节未收到 **
 171          //** 应答信号ACK,则返回0(FALSE). **
 172          //****************************************************************/
 173          static unsigned char writeEEone(unsigned char addr,unsigned char num,unsigned char *Data)
 174          {
 175   1        unsigned char i;
 176   1        //gie=0;
C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 4   

 177   1        IC_start();
 178   1        if(IC_WriteByte(RX8010_WRITE)==0)
 179   1        {
 180   2          IC_stop(); return(0);
 181   2        }
 182   1        if(IC_WriteByte(addr)==0)
 183   1        {
 184   2          IC_stop(); return(0);
 185   2        }
 186   1        for(i=0;i<num;i++)
 187   1        {
 188   2          if(IC_WriteByte(Data[i])==0)
 189   2          {
 190   3            IC_stop(); return(0);
 191   3          }
 192   2        }
 193   1        IC_stop();
 194   1        delay_us(4);
 195   1        SDA=0;
 196   1        SCL=0;
 197   1        //gie=1;
 198   1        return(1);
 199   1      } 
 200          
 201          
 202          //检测VLF频率停止位，若为1则初始化RX8010
 203          unsigned char RX8010_Initialize(void) 
 204          {
 205   1        unsigned char Rdata[7];
 206   1        unsigned char i;
 207   1        unsigned char Init_State;
 208   1        
 209   1        EA = 0; 
 210   1        Init_State = RX8010_INIT_NONE;//未初始化
 211   1        
 212   1        Rdata[0] = 0x00;
 213   1        for(i = 0;i < 10;i++)
 214   1        {
 215   2          if(readEEone(0x1E,1,Rdata) == 1)
 216   2          {
 217   3            Init_State = RX8010_INIT_NONE;
 218   3            break;//读VLF状态
 219   3          }
 220   2          delay_ms(100);
 221   2          WDT_CONTR = 0x3F; 
 222   2          Init_State = RX8010_INIT_FAIL;//初始化失败
 223   2        }
 224   1        
 225   1        if(Init_State == RX8010_INIT_NONE)
 226   1        {   
 227   2          if(Bit_is_one(Rdata[0],1))//判定是否停止,VLF=1
 228   2          {
 229   3            Init_State = RX8010_INIT_OK;//初始化成功
 230   3            Rdata[0] = 0x58;
 231   3            writeEEone(0x17,1,Rdata);
 232   3            Rdata[0] = 0x00;
 233   3            Rdata[1] = 0x18;
 234   3            Rdata[2] = 0x00;
 235   3            writeEEone(0x30,3,Rdata); 
 236   3            Rdata[0] = 0x04;//无中断输出
 237   3            Rdata[1] = 0x00;//清AF和VLF
 238   3            Rdata[2] = 0x40;    
C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 5   

 239   3            writeEEone(0x1D,3,Rdata); 
 240   3            
 241   3            Rdata[0] = 0x00;//SEC
 242   3            Rdata[1] = 0x00;//MIN
 243   3            Rdata[2] = 0x00;//HOUR
 244   3            Rdata[3] = 0x10;//WEEK
 245   3            Rdata[4] = 0x01;//DAY
 246   3            Rdata[5] = 0x01;//MONTH
 247   3            Rdata[6] = 0x15;//YEAR 2015-01-01-00:00:00-Tursday
 248   3            writeEEone(0x10,7,Rdata);//设定时间
 249   3            
 250   3            Rdata[0] = 0x00;//MIN
 251   3            Rdata[1] = 0x00;//HOUR
 252   3            Rdata[2] = 0x00;//WEEK
 253   3            writeEEone(0x18,3,Rdata);//设定闹钟
 254   3            
 255   3            Rdata[0] = 0x00;//MIN
 256   3            Rdata[1] = 0x00;//HOUR
 257   3            writeEEone(0x1B,2,Rdata);//设定定时
 258   3            
 259   3            Rdata[0] = 0x00;//STOP位为0
 260   3            writeEEone(0x1F,1,Rdata);     
 261   3          } 
 262   2        }
 263   1        EA = 1;
 264   1        return Init_State;
 265   1      }
 266           
 267          //设定时钟
 268          //注意，原来是DS1302，改为RX8010后，顺序不同，另外，星期由8421BCD码改为位
 269          void RX8010_SetTime(BYTE *p) 
 270          {
 271   1        unsigned char Rdata[7];
 272   1        
 273   1        Rdata[0] = 0x40;//STOP位为1
 274   1        writeEEone(0x1F,1,Rdata);
 275   1        
 276   1        Rdata[0] = *p;//SEC
 277   1        Rdata[1] = *(p+1);//MIN
 278   1        Rdata[2] = *(p+2);//HOUR  
 279   1        Rdata[3] = *(p+5);//WEEK
 280   1      /*
 281   1      //  data[3] = 1 << *(p+5); //WEEK由DS1302转换为RX8010 
 282   1      //  if(data[3]==0x80)data[3]=1;//DS1302星期天为7，而RX8010是低位为1
 283   1      */
 284   1        Rdata[4] = *(p+3);//DAY
 285   1        Rdata[5] = *(p+4);//MONTH
 286   1        Rdata[6] = *(p+6);//YEAR 2015-01-01-00:00:00-Tursday
 287   1        writeEEone(0x10,7,Rdata);
 288   1        
 289   1        Rdata[0] = 0x00;//STOP位为0
 290   1        writeEEone(0x1F,1,Rdata); 
 291   1      }
 292            
 293          //读取时钟
 294          //注意，原来是DS1302，改为RX8010后，顺序不同，另外，星期由8421BCD码改为位
 295          void RX8010_GetTime(BYTE *p) 
 296          {
 297   1        unsigned char Rdata[7];
 298   1        
 299   1        readEEone(0x10,7,Rdata);
 300   1        *p = Rdata[0];//SEC 
C51 COMPILER V9.52.0.0   RX8010                                                            03/30/2019 01:20:49 PAGE 6   

 301   1        *(p+1) = Rdata[1];//MIN
 302   1        *(p+2) = Rdata[2];//HOUR
 303   1        *(p+5) = Rdata[3];//WEEK
 304   1        /* 注意：未使用星期
 305   1        for(i = 1;i > 7; i++)
 306   1        {
 307   1          if((*(p+5) >> i)==0)break;
 308   1        }
 309   1        *(p+5) = i;
 310   1        if(*(p+5) == 1)//星期天
 311   1        {
 312   1          *(p+5) = 7;
 313   1        }
 314   1        else
 315   1        {
 316   1          *(p+5) -=1;
 317   1        }
 318   1        */
 319   1        
 320   1        *(p+3) = Rdata[4];//DAY
 321   1        *(p+4) = Rdata[5];//MONTH
 322   1        *(p+6) = Rdata[6];//YEAR 2015-01-01-00:00:00-Tursday
 323   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1116    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      45
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
