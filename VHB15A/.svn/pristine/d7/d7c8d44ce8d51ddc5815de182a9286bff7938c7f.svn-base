C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE RX8010
OBJECT MODULE PLACED IN ..\OBJ\RX8010.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\RX8010\RX8010.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE
                    - ORDER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HAR
                    -DWARE\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\RX8010.lst) TABS(2) O
                    -BJECT(..\OBJ\RX8010.obj)

line level    source

   1           #include "STC12C32AD.h"
   2           #include "all.h" 
   3           //#include "delay.h"
   4           //#include "RX8010.h"
   5          
   6           
   7          #define SCL_          P25
   8          #define SDA_          P26
   9          //#define ASK            0
  10          //#define NO_ASK         1
  11          //#define OUT_LOW        0
  12          //#define INPUT_HIGH     1
  13          
  14          //#define SCL_DIR_OUTPUT()   P2M1 |= 0x10;P2M0 |= 0x10  //11 开漏输出
  15          //#define SDA_DIR_INPUT()    P2M1 |= 0x40;P2M0 &= 0xBF  //10 仅为输入
  16          //#define SDA_DIR_OUTPUT()   P2M1 |= 0x40;P2M0 |= 0x40  //11 开漏输出
  17          
  18          #define RX8010_WRITE  0x64 //I2C器件地址
  19          #define RX8010_READ   0x65
  20          
  21          ////2019.03.29
  22          //sfr WDT_CONTR = 0xC1;
  23          //sbit EA  = (u8)0xA8^(u8)7;
  24          //sbit P25 = (u8)0xA0^(u8)5;
  25          //sbit P26 = (u8)0xA0^(u8)6;
  26          //sfr P2M0 = 0x96;
  27          //sfr P2M1 = 0x95;
  28          
  29          
  30          static void SCL_DIR_OUTPUT(void)
  31          {
  32   1        P2M1 |= (u8)0x10;
  33   1        P2M0 |= (u8)0x10;
  34   1      } 
  35          
  36          static void SDA_DIR_INPUT(void)
  37          {
  38   1        P2M1 |= (u8)0x40;
  39   1        P2M0 &= (u8)0xBF;
  40   1      }
  41          static void SDA_DIR_OUTPUT(void)
  42          {
  43   1        P2M1 |= (u8)0x40;
  44   1        P2M0 |= (u8)0x40;
  45   1      }
  46          
  47          //************************************
  48          //** 函数原型: void IC_start(void); **
  49          //** 功 能: IC 总线起始位. **
  50          //************************************
  51          static void IC_start(void)
  52          { 
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 2   

  53   1          SCL_DIR_OUTPUT();
  54   1          SDA_DIR_OUTPUT();   
  55   1          SCL_=(bit)1;
  56   1          SDA_=(bit)1;
  57   1          delay_us(2);
  58   1          SDA_=(bit)0;
  59   1          delay_us(2);//
  60   1          SCL_=(bit)0;
  61   1      }
  62          
  63          //**********************************
  64          //** 函数原型: void IC_stop(void); **
  65          //** 功 能: IC 总线停止位. **
  66          //**********************************
  67          static void IC_stop(void)
  68          {
  69   1          SCL_=(bit)0;
  70   1          SDA_DIR_OUTPUT();
  71   1          SDA_=(bit)0;
  72   1          delay_us(2);
  73   1          SCL_=(bit)1;
  74   1          delay_us(2); //
  75   1          SDA_=(bit)1;
  76   1          delay_us(2);
  77   1      }
  78          
  79          //***************************************************
  80          //** 函数原型: bit IC_writebyte(uchar wdata); **
  81          //** 功 能: 向IC 总线发送8 位数据,并请求一个应答信 **
  82          //** 号ACK.如果收到ACK 应答则返回1(TRUE), **
  83          //** 否则返回0(FALSE). **
  84          //***************************************************
  85          static uint8_t IC_WriteByte( uint8_t wdata)
  86          {
  87   1        uint8_t i;
  88   1        uint8_t ret=1;
  89   1        SDA_DIR_OUTPUT();
  90   1        for(i=0;i<(u8)8;i++)
  91   1        {
  92   2          SCL_=(bit)0;
  93   2          delay_us(2);
  94   2          if((wdata&(uint8_t)0x80)!=(uint8_t)0)
  95   2          {
  96   3            SDA_=(bit)1;
  97   3          }     
  98   2          else 
  99   2          {
 100   3            SDA_=(bit)0;
 101   3          }
 102   2          delay_us(2);
 103   2          SCL_=(bit)1;
 104   2          delay_us(4);
 105   2          wdata<<=1;
 106   2        }
 107   1        SCL_=(bit)0;
 108   1        delay_us(4);
 109   1        SDA_DIR_INPUT();
 110   1        SCL_=(bit)1;
 111   1        delay_us(4);
 112   1        i=0;
 113   1        while(SDA_)
 114   1        {
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 3   

 115   2          if(++i>(u8)12){SCL_=(bit)0;ret=(uint8_t)0;break;}
 116   2        }
 117   1        if(ret==(uint8_t)1)
 118   1        {
 119   2          SCL_=(bit)0;
 120   2        }
 121   1        return ret;
 122   1      }
 123          //***********************************************
 124          //** 函数原型: uchar IC_readbyte(void); **
 125          //** 功 能: 从IC 总线上接收8 位数据,并将接受到 **
 126          //** 8 位数据作为一个字节返回,不回送应 **
 127          //** 答信号ACK. **
 128          //***********************************************
 129          static uint8_t IC_ReadByte(void)
 130          { 
 131   1        uint8_t i;
 132   1        uint8_t IC_data=0;
 133   1        SCL_=(bit)0;
 134   1        SDA_DIR_OUTPUT();
 135   1        SDA_=(bit)1;
 136   1        SDA_DIR_INPUT();  
 137   1        for(i=0;i<(uint8_t)8;i++)
 138   1        {
 139   2          SCL_=(bit)1;
 140   2          delay_us(2);
 141   2          IC_data<<=1;
 142   2      
 143   2          //IC_data|=SDA_;
 144   2          if(SDA_)
 145   2          {
 146   3            IC_data++;
 147   3          }
 148   2          //delay_us(4);
 149   2          SCL_=(bit)1;
 150   2          delay_us(2);
 151   2          SCL_=(bit)0;
 152   2          delay_us(4);
 153   2        }
 154   1        delay_us(4);
 155   1        SCL_=(bit)0;
 156   1        SDA_DIR_OUTPUT();
 157   1        SDA_=(bit)0;
 158   1        return(IC_data);
 159   1      }
 160          //***************************************************************
 161          //** 函数原型: bit readEEone(uchar instr,uchar addr,uchar num); **
 162          //** 功 能: 从8010 中读取num 个字节的数据,采用序列读操作方 **
 163          //** 式从片内Address 地址开始连续读取数据.8010 不接 **
 164          //** 受指定的地址则返回0(FALSE). **
 165          //***************************************************************
 166          uint8_t readEEone(uint8_t addr,uint8_t num,uint8_t *Data)
 167          {
 168   1      //  uint8_t i;
 169   1      //  IC_start();
 170   1      //  if(IC_WriteByte(RX8010_WRITE)==0)
 171   1      //  {
 172   1      //    IC_stop(); return(0);
 173   1      //  }
 174   1      //  
 175   1      //  if(IC_WriteByte(addr)==0)
 176   1      //  {
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 4   

 177   1      //    IC_stop(); return(0);
 178   1      //  }
 179   1      //  IC_start();
 180   1      //  if(IC_WriteByte(RX8010_READ)==0)
 181   1      //  {
 182   1      //    IC_stop(); return(0);
 183   1      //  }
 184   1      //  for(i=0;i<(num-1);i++)
 185   1      //  {
 186   1      //    Data[i]=IC_ReadByte();
 187   1      //    SDA_DIR_OUTPUT();       
 188   1      //    SDA_=0;   
 189   1      //    SCL_=1;
 190   1      //  }
 191   1      //  Data[num-1]=IC_ReadByte();
 192   1      //  SDA_DIR_OUTPUT(); 
 193   1      //  SDA_=1; 
 194   1      //  delay_us(4);
 195   1      //  SCL_=1;
 196   1      //  IC_stop();
 197   1      //  return(1);
 198   1      
 199   1        uint8_t i;
 200   1        uint8_t ret=1;
 201   1        IC_start();
 202   1        if(IC_WriteByte(RX8010_WRITE)==(u8)0)
 203   1        {
 204   2          IC_stop(); ret=(uint8_t)0;
 205   2        }
 206   1        else if(IC_WriteByte(addr)==(u8)0)
 207   1        {
 208   2          IC_stop(); ret=(uint8_t)0;
 209   2        }
 210   1        else
 211   1        {
 212   2          IC_start();
 213   2          if(IC_WriteByte(RX8010_READ)==(u8)0)
 214   2          {
 215   3            
 216   3            IC_stop(); ret=(uint8_t)0;
 217   3          }
 218   2          else
 219   2          {
 220   3            for(i=0;i<(num-(u8)1);i++)
 221   3            {
 222   4              Data[i]=IC_ReadByte();
 223   4              SDA_DIR_OUTPUT();       
 224   4              SDA_=(bit)0; /** Send ACK **/   
 225   4              SCL_=(bit)1;
 226   4            }
 227   3            Data[num-(u8)1]=IC_ReadByte();
 228   3            SDA_DIR_OUTPUT(); 
 229   3            SDA_=(bit)1; /** Send Read End **/
 230   3            delay_us(4);
 231   3            SCL_=(bit)1;
 232   3            IC_stop();
 233   3          }
 234   2        }
 235   1        return ret;
 236   1      }
 237          
 238          //****************************************************************
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 5   

 239          //** 函数原型: bit writeEEone(uchar instr,uchar addr,uchar num); **
 240          //** 功 能: 将EEbuf[]单元中的数据写入8010 的num 个字节. **
 241          //** 采用页写操作方式,每次写入时都需要指定片内地址. **
 242          //** 如果8010 不接受指定的地址或某个传送的字节未收到 **
 243          //** 应答信号ACK,则返回0(FALSE). **
 244          //****************************************************************
 245          static void writeEEone(uint8_t addr,uint8_t num,const uint8_t *Data)
 246          {
 247   1        uint8_t i;
 248   1        //gie=0;
 249   1        IC_start();
 250   1        if(IC_WriteByte(RX8010_WRITE)==(u8)0)
 251   1        {
 252   2      //    IC_stop(); return(0);
 253   2          IC_stop();
 254   2        }
 255   1        if(IC_WriteByte(addr)==(u8)0)
 256   1        {
 257   2      //    IC_stop(); return(0);
 258   2          IC_stop();
 259   2        }
 260   1        for(i=0;i<num;i++)
 261   1        {
 262   2          if(IC_WriteByte(Data[i])==(u8)0)
 263   2          {
 264   3      //      IC_stop(); return(0);
 265   3            IC_stop();
 266   3          }
 267   2        }
 268   1        IC_stop();
 269   1        delay_us(4);
 270   1        SDA_=(bit)0;
 271   1        SCL_=(bit)0;
 272   1        //gie=1;
 273   1      //  return(1);
 274   1      } 
 275          
 276          
 277          //检测VLF频率停止位，若为1则初始化RX8010
 278          uint8_t RX8010_Initialize(void) 
 279          {
 280   1        uint8_t Rdata[7];
 281   1        uint8_t i;
 282   1        uint8_t Init_State;
 283   1        
 284   1        EA = (bit)0;  
 285   1        Init_State = RX8010_INIT_NONE;//未初始化
 286   1        
 287   1        Rdata[0] = 0x00;
 288   1        for(i = 0;i < (u8)10;i++)
 289   1        {
 290   2          if(readEEone(0x1E,1,Rdata) == (u8)1)
 291   2          {
 292   3            Init_State = RX8010_INIT_NONE;
 293   3            break;//读VLF状态
 294   3          }
 295   2          delay_ms(100);
 296   2          WDT_CONTR = 0x3F; 
 297   2          Init_State = RX8010_INIT_FAIL;//初始化失败
 298   2        }
 299   1        
 300   1        if(Init_State == (u8)RX8010_INIT_NONE)
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 6   

 301   1        {   
 302   2          if(Bit_is_one(Rdata[0],1)!=(uint8_t)0)//判定是否停止,VLF=1
 303   2          {
 304   3            Init_State = RX8010_INIT_OK;//初始化成功
 305   3            Rdata[0] = 0x58;
 306   3            writeEEone(0x17,1,Rdata);
 307   3            Rdata[0] = 0x00;
 308   3            Rdata[1] = 0x18;
 309   3            Rdata[2] = 0x00;
 310   3            writeEEone(0x30,3,Rdata); 
 311   3            Rdata[0] = 0x04;//无中断输出
 312   3            Rdata[1] = 0x00;//清AF和VLF
 313   3            Rdata[2] = 0x40;    
 314   3            writeEEone(0x1D,3,Rdata); 
 315   3            
 316   3            Rdata[0] = 0x00;//SEC
 317   3            Rdata[1] = 0x00;//MIN
 318   3            Rdata[2] = 0x00;//HOUR
 319   3            Rdata[3] = 0x10;//WEEK
 320   3            Rdata[4] = 0x01;//DAY
 321   3            Rdata[5] = 0x01;//MONTH
 322   3            Rdata[6] = 0x15;//YEAR 2015-01-01-00:00:00-Tursday
 323   3            writeEEone(0x10,7,Rdata);//设定时间
 324   3            
 325   3            Rdata[0] = 0x00;//MIN
 326   3            Rdata[1] = 0x00;//HOUR
 327   3            Rdata[2] = 0x00;//WEEK
 328   3            writeEEone(0x18,3,Rdata);//设定闹钟
 329   3            
 330   3            Rdata[0] = 0x00;//MIN
 331   3            Rdata[1] = 0x00;//HOUR
 332   3            writeEEone(0x1B,2,Rdata);//设定定时
 333   3            
 334   3            Rdata[0] = 0x00;//STOP位为0
 335   3            writeEEone(0x1F,1,Rdata);     
 336   3          } 
 337   2        }
 338   1        EA = (bit)1;
 339   1        return Init_State;
 340   1      }
 341           
 342          //设定时钟
 343          //注意，原来是DS1302，改为RX8010后，顺序不同，另外，星期由8421BCD码改为位
 344          void RX8010_SetTime(const BYTE *p) 
 345          {
 346   1        uint8_t Rdata[7];
 347   1        
 348   1        Rdata[0] = 0x40;//STOP位为1
 349   1        writeEEone(0x1F,1,Rdata);
 350   1        
 351   1        Rdata[0] = *p;//SEC
 352   1      //  Rdata[1] = *(p+1);//MIN
 353   1      //  Rdata[2] = *(p+2);//HOUR  
 354   1      //  Rdata[3] = *(p+5);//WEEK
 355   1        Rdata[1] = p[1];//MIN
 356   1        Rdata[2] = p[2];//HOUR  
 357   1        Rdata[3] = p[5];//WEEK
 358   1      
 359   1      //  data[3] = 1 << *(p+5); //WEEK由DS1302转换为RX8010 
 360   1      //  if(data[3]==0x80)data[3]=1;//DS1302星期天为7，而RX8010是低位为1
 361   1      
 362   1      //  Rdata[4] = *(p+3);//DAY
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 7   

 363   1      //  Rdata[5] = *(p+4);//MONTH
 364   1      //  Rdata[6] = *(p+6);//YEAR 2015-01-01-00:00:00-Tursday
 365   1        Rdata[4] = p[3];//DAY
 366   1        Rdata[5] = p[4];//MONTH
 367   1        Rdata[6] = p[6];//YEAR 2015-01-01-00:00:00-Tursday
 368   1        writeEEone(0x10,7,Rdata);
 369   1        
 370   1        Rdata[0] = 0x00;//STOP位为0
 371   1        writeEEone(0x1F,1,Rdata); 
 372   1      }
 373            
 374          //读取时钟
 375          //注意，原来是DS1302，改为RX8010后，顺序不同，另外，星期由8421BCD码改为位
 376          void RX8010_GetTime(BYTE *p) 
 377          {
 378   1        uint8_t Rdata[7];
 379   1        
 380   1      //  readEEone(0x10,7,Rdata);
 381   1        if(readEEone(0x10,7,Rdata)==(uint8_t)1)
 382   1        {
 383   2          *p = Rdata[0];//SEC 
 384   2          //  *(p+1) = Rdata[1];//MIN
 385   2          //  *(p+2) = Rdata[2];//HOUR
 386   2          //  *(p+5) = Rdata[3];//WEEK
 387   2          p[1]= Rdata[1];//MIN
 388   2          p[2] = Rdata[2];//HOUR
 389   2          p[5] = Rdata[3];//WEEK
 390   2          //  // 注意：未使用星期
 391   2          //  for(i = 1;i > 7; i++)
 392   2          //  {
 393   2          //    if((*(p+5) >> i)==0)break;
 394   2          //  }
 395   2          //  *(p+5) = i;
 396   2          //  if(*(p+5) == 1)//星期天
 397   2          //  {
 398   2          //    *(p+5) = 7;
 399   2          //  }
 400   2          //  else
 401   2          //  {
 402   2          //    *(p+5) -=1;
 403   2          //  }
 404   2          //  
 405   2      
 406   2          //  *(p+3) = Rdata[4];//DAY
 407   2          //  *(p+4) = Rdata[5];//MONTH
 408   2          //  *(p+6) = Rdata[6];//YEAR 2015-01-01-00:00:00-Tursday
 409   2          p[3] = Rdata[4];//DAY
 410   2          p[4] = Rdata[5];//MONTH
 411   2          p[6] = Rdata[6];//YEAR 2015-01-01-00:00:00-Tursday
 412   2        }
 413   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1154    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      47
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   RX8010                                                            04/19/2019 09:37:29 PAGE 8   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
