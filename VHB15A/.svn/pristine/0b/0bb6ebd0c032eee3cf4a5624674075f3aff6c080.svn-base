C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE NORMAL_TASK
OBJECT MODULE PLACED IN ..\OBJ\Normal_Task.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\CODE\Normal_Task.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER
                    - NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\
                    -sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\Normal_Task.lst) TABS(2) OB
                    -JECT(..\OBJ\Normal_Task.obj)

line level    source

   1          #include "all.h"
   2          
   3          ////2019.03.30
   4          ////sbit P20 = (uint8_t)0xA0^(uint8_t)0;
   5          //sbit P20 = (uint8_t)0xA0;
   6          //sbit P21 = (uint8_t)0xA0^(uint8_t)1;
   7          //sbit P22 = (uint8_t)0xA0^(uint8_t)2;
   8          //sbit P23 = (uint8_t)0xA0^(uint8_t)3;
   9          
  10          WORK_STATUS Work_State = UI_STATE_POWER_OFF_MODE;//工作状态定义
  11          
  12          void ManageTask(void)//Task0:Task Manager ----20mS
  13          {
  14   1          static INT Manage_Tik_100mS_Cnt = 0;
  15   1          static INT Manage_Tik_250mS_Cnt = 0;
  16   1          static INT Manage_Tik_1000mS_Cnt = 0;        
  17   1                   
  18   1          WS_TaskState = ManageTIFG;
  19   1          if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)   
  20   1          { 
  21   2              WS_DelTaskIfg(WS_TaskState); 
  22   2              {         
  23   3                //20mS任务
  24   3                WS_SetTaskIfg(KeyScanTIFG);//按键扫描任务 20mS          
  25   3                WS_SetTaskIfg(UartRecTIFG);//串口接收进程
  26   3                
  27   3                if(Work_State != UI_STATE_DATAREADER_MODE)//数据传输界面屏蔽以下任务
  28   3                {         
  29   4                  if(Work_State != UI_STATE_POWER_OFF_MODE)
  30   4                  {         
  31   5                    WS_SetTaskIfg(GetTemp_HpChamberTIFG);      //读取加热盘盘和出气口的温度 20mS
  32   5                    WS_SetTaskIfg(GetTempHumidity_PatientTIFG); //读取患者端温度和温度 20mS
  33   5                  }         
  34   4                  //100mS任务
  35   4                  Manage_Tik_100mS_Cnt++;
  36   4                  if(Manage_Tik_100mS_Cnt >= 5)//
  37   4                  {
  38   5                    Manage_Tik_100mS_Cnt = 0;
  39   5        //            time_test_lcd_backlight();
  40   5                    if(Work_State == UI_STATE_SERVICE_MODE)
  41   5                    {         
  42   6                      WS_SetTaskIfg(HmiServiceModeTIFG);//服务模式
  43   6                    }
  44   5                    else if(Work_State == UI_STATE_POST_MODE)
  45   5                    {
  46   6                      WS_SetTaskIfg(HmiPostTIFG);//开机自检
  47   6                    }         
  48   5                    else if(Work_State == UI_STATE_FACTORY_DEFAULT_SEL_MODE)
  49   5                    {
  50   6                      WS_SetTaskIfg(HmiFactoryDefaultSelTIFG);//开机选择功能
  51   6                    }
  52   5                    else if(Work_State == UI_STATE_NON_INVASIVE_MODE)
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 2   

  53   5                    {
  54   6                      WS_SetTaskIfg(HmiNon_InvasiveSelTIFG);//开机有创无创选择
  55   6                    }
  56   5                    else if(Work_State == UI_STATE_RUNNING_NORMAL_MODE)
  57   5                    {
  58   6                      WS_SetTaskIfg(HmiRunningTIFG);//正常运行状态
  59   6                    }
  60   5                    else if(Work_State == UI_STATE_SetTempPatient_MODE)
  61   5                    {
  62   6                      WS_SetTaskIfg(HmiSetTempPatientTIFG);//患者端温度设定
  63   6                    }
  64   5                    else if(Work_State == UI_STATE_SetTempChamber_MODE)
  65   5                    {
  66   6                      WS_SetTaskIfg(HmiSetTempChamberTIFG);//出气口温度设定
  67   6                    }
  68   5                    else if(Work_State == UI_STATE_SetInExp_MODE)
  69   5                    {
  70   6                      WS_SetTaskIfg(HmiSetInExpTIFG);//InExp设定
  71   6                    }
  72   5                    else if(Work_State == UI_STATE_SetTime_MODE)
  73   5                    {
  74   6                      WS_SetTaskIfg(HmiSetTimeTIFG);//时间设定
  75   6                    }
  76   5                    else
  77   5                    {
  78   6                      //do nothing
  79   6                    }             
  80   5                    
  81   5                    if((Work_State != UI_STATE_POWER_OFF_MODE)
  82   5                      &&(Work_State != UI_STATE_POST_MODE)
  83   5                      &&(Work_State != UI_STATE_FACTORY_DEFAULT_SEL_MODE)
  84   5                      &&(Work_State != UI_STATE_NON_INVASIVE_MODE)  
  85   5                      &&(Work_State != UI_STATE_SERVICE_MODE))//除以上模式外          
  86   5                    {
  87   6                      WS_SetTaskIfg(HmiScreenSaverModeTIFG);//屏保模式 
  88   6                    }
  89   5      
  90   5                    
  91   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
  92   5                      ||(Work_State == UI_STATE_SetTempPatient_MODE)
  93   5                      ||(Work_State == UI_STATE_SetTempChamber_MODE)
  94   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
  95   5                      ||(Work_State == UI_STATE_SetTime_MODE))
  96   5                    { 
  97   6                      if((Work_State != UI_STATE_SetTime_MODE)//设定时间时不刷新实时RTC时间 
  98   6                        &&(Work_State != UI_STATE_SCREENSAVER_MODE))
  99   6                      {
 100   7                        WS_SetTaskIfg(RefreshRTCTimeTIFG);//刷新RTC时间     
 101   7                      }               
 102   6                    }
 103   5                  }
 104   4                  
 105   4                  //240mS任务
 106   4                  Manage_Tik_250mS_Cnt++;
 107   4                  if(Manage_Tik_250mS_Cnt >= 12)//
 108   4                  {
 109   5                    Manage_Tik_250mS_Cnt = 0;
 110   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
 111   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
 112   5                      ||(Work_State == UI_STATE_SetTime_MODE))
 113   5                    {
 114   6                      if((Work_State != UI_STATE_SetTempPatient_MODE)
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 3   

 115   6                        &&(Work_State != UI_STATE_SetTempChamber_MODE))
 116   6                      {   
 117   7                        WS_SetTaskIfg(RefreshTempHumidyTIFG);//刷新实时温度和湿度
 118   7                      }
 119   6                    }
 120   5                    
 121   5                    if((Work_State != UI_STATE_POWER_OFF_MODE)
 122   5                      &&(Work_State != UI_STATE_POST_MODE)
 123   5                      &&(Work_State != UI_STATE_FACTORY_DEFAULT_SEL_MODE)
 124   5                      &&(Work_State != UI_STATE_NON_INVASIVE_MODE)
 125   5                      &&(Work_State != UI_STATE_SERVICE_MODE))//除以上模式外                  
 126   5                    {
 127   6                      WS_SetTaskIfg(AlarmErrorTIFG);//报警和错误事件处理,错误事件刷新 
 128   6                    }
 129   5                  }
 130   4                            
 131   4                  //1000mS任务
 132   4                  Manage_Tik_1000mS_Cnt++;
 133   4                  if(Manage_Tik_1000mS_Cnt >= 50)//
 134   4                  {
 135   5                    Manage_Tik_1000mS_Cnt = 0;
 136   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
 137   5                      ||(Work_State == UI_STATE_SCREENSAVER_MODE)
 138   5                      ||(Work_State == UI_STATE_SetTempPatient_MODE)
 139   5                      ||(Work_State == UI_STATE_SetTempChamber_MODE)
 140   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
 141   5                      ||(Work_State == UI_STATE_SetTime_MODE))
 142   5                    {             
 143   6                      WS_SetTaskIfg(HeaterWireModeDetTIFG); //加热线状态检测 1S
 144   6                      WS_SetTaskIfg(HeaterPlateWireControlTIFG);//回路加热线温度的控制 1S(仅运算，驱动在定时中断)
 145   6                      WS_SetTaskIfg(LowPowerModeTIFG);//低功率模式 1S
 146   6                      WS_SetTaskIfg(SaveDateToFlashTIFG);//保存数据到FLASH 1S 
 147   6                      WS_SetTaskIfg(LowTempDet1STIFG);//低温低湿检测1S
 148   6                      WS_SetTaskIfg(RefreshRunTimeTIFG);//刷新运行时间 1S
 149   6                    }             
 150   5                  }         
 151   4                } 
 152   3              }          
 153   2          }
 154   1      }
 155          
 156          
 157          void KeyScanTask(void) //1
 158          {
 159   1        static KEY_STATUS KeyToFuncVal = KEY_STATE_ReleaseValue; 
 160   1        static const struct Key_Multifun_Element Key_UP_Element = 
 161   1        {
 162   1          KEY_STATE_PressValue,         //PressValue
 163   1          KEY_STATE_ReleaseValue,       //ReleaseValue
 164   1          10,                           //TimOf_Low_High 按下弹起的最大响应时间
 165   1          20,                           //TimOfSe 初次长按响应时间
 166   1          5,                            //TimOfLg 后续长连续按下状态时间
 167   1          KeyUpPressShortAction,        //void (*)(void)短按键由低到高弹起
 168   1          KeyUpPressLongFirstAction,    //按键长键后的响应函数
 169   1          KeyUpPressLongRepeatAction,  //连续按下持续,连+连-
 170   1        };
 171   1        static struct Multifun_Key Key_UP =
 172   1        {
 173   1          &KeyToFuncVal,            //按键码值
 174   1          &Key_UP_Tik,  //按键时标
 175   1          1,            //处理状态
 176   1        };
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 4   

 177   1        static const struct Key_Multifun_Element Key_Down_Element = 
 178   1        {
 179   1          KEY_STATE_PressValue,         //PressValue
 180   1          KEY_STATE_ReleaseValue,       //ReleaseValue
 181   1          10,                           //TimOf_Low_High 按下弹起的最大响应时间
 182   1          20,                           //TimOfSe 初次长按响应时间
 183   1          5,                            //TimOfLg 后续长连续按下状态时间
 184   1          KeyDownPressShortAction,        //void (*)(void)短按键由低到高弹起
 185   1          KeyDownPressLongFirstAction,    //按键长键后的响应函数
 186   1          KeyDownPressLongRepeatAction,  //连续按下持续,连+连-
 187   1        };
 188   1        static struct Multifun_Key Key_Down =
 189   1        {
 190   1          &KeyToFuncVal,            //按键码值
 191   1          &Key_Down_Tik,  //按键时标
 192   1          1,            //处理状态
 193   1        };
 194   1        static const struct Key_Multifun_Element Key_OK_Element = 
 195   1        {
 196   1          KEY_STATE_PressValue,         //PressValue
 197   1          KEY_STATE_ReleaseValue,       //ReleaseValue
 198   1          10,                           //TimOf_Low_High 按下弹起的最大响应时间
 199   1          20,                           //TimOfSe 初次长按响应时间
 200   1          5,                            //TimOfLg 后续长连续按下状态时间
 201   1          KeyOKPressShortAction,        //void (*)(void)短按键由低到高弹起
 202   1          KeyOKPressLongFirstAction,    //按键长键后的响应函数
 203   1          KeyOKPressLongRepeatAction,  //连续按下持续,连+连-
 204   1        };
 205   1        static struct Multifun_Key Key_OK =
 206   1        {
 207   1          &KeyToFuncVal,            //按键码值
 208   1          &Key_OK_Tik,  //按键时标
 209   1          1,            //处理状态
 210   1        };
 211   1        static const struct Key_Multifun_Element Key_Mute_Element = 
 212   1        {
 213   1          KEY_STATE_PressValue,         //PressValue
 214   1          KEY_STATE_ReleaseValue,       //ReleaseValue
 215   1          10,                           //TimOf_Low_High 按下弹起的最大响应时间
 216   1          20,                           //TimOfSe 初次长按响应时间
 217   1          5,                            //TimOfLg 后续长连续按下状态时间
 218   1          KeyMutePressShortAction,        //void (*)(void)短按键由低到高弹起
 219   1          KeyMutePressLongFirstAction,    //按键长键后的响应函数
 220   1          KeyMutePressLongRepeatAction,  //连续按下持续,连+连-
 221   1        };
 222   1        static struct Multifun_Key Key_Mute =
 223   1        {
 224   1          &KeyToFuncVal,            //按键码值
 225   1          &Key_Mute_Tik,  //按键时标
 226   1          1,            //处理状态
 227   1        };
 228   1      //  BitStatus bit_status;
 229   1        bit bit_status;
 230   1        WS_TaskState = KeyScanTIFG;
 231   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 232   1        {   
 233   2          WS_DelTaskIfg(WS_TaskState);
 234   2          {
 235   3            bit_status = KEY_LEFT_UP_IN;//UP
 236   3      
 237   3      //      if((INT)bit_status == (INT)RESET)
 238   3            if(!bit_status)
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 5   

 239   3            {
 240   4              KeyToFuncVal = KEY_STATE_PressValue;     
 241   4            }
 242   3            else
 243   3            {
 244   4              KeyToFuncVal = KEY_STATE_ReleaseValue;
 245   4            }
 246   3            Key_Multifun(Key_UP_Element,&Key_UP);
 247   3            
 248   3            bit_status = KEY_LEFT_DOWN_IN;//DOWN
 249   3            if(!bit_status)
 250   3            {
 251   4              KeyToFuncVal = KEY_STATE_PressValue;     
 252   4            }
 253   3            else
 254   3            {
 255   4              KeyToFuncVal = KEY_STATE_ReleaseValue; 
 256   4            }
 257   3      
 258   3            Key_Multifun(Key_Down_Element,&Key_Down);
 259   3            
 260   3            bit_status = KEY_RIGHT_UP_IN;//OK
 261   3      
 262   3            if(!bit_status)
 263   3            {
 264   4              KeyToFuncVal = KEY_STATE_PressValue;     
 265   4            }
 266   3            else
 267   3            {
 268   4              KeyToFuncVal = KEY_STATE_ReleaseValue; 
 269   4            }
 270   3              
 271   3            Key_Multifun(Key_OK_Element,&Key_OK);
 272   3            
 273   3            bit_status = KEY_RIGHT_DOWN_IN;//MUTE
 274   3      
 275   3            if(!bit_status)
 276   3            {
 277   4              KeyToFuncVal = KEY_STATE_PressValue;        
 278   4            }
 279   3            else
 280   3            {
 281   4              KeyToFuncVal = KEY_STATE_ReleaseValue; 
 282   4            }
 283   3              
 284   3            Key_Multifun(Key_Mute_Element,&Key_Mute);         
 285   3          }
 286   2        }
 287   1      }
 288          
 289          void HmiServiceModeTask(void)//2
 290          {
 291   1        WS_TaskState = HmiServiceModeTIFG;
 292   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 293   1        {   
 294   2          WS_DelTaskIfg(WS_TaskState);
 295   2          {
 296   3            HmiServiceModeFunc();
 297   3          }
 298   2        }
 299   1      }
 300          
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 6   

 301          void HmiPostTask(void)//3
 302          {
 303   1        WS_TaskState = HmiPostTIFG;
 304   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 305   1        {   
 306   2          WS_DelTaskIfg(WS_TaskState);
 307   2          {
 308   3            HmiPostFunc();
 309   3          }
 310   2        }
 311   1      }
 312          
 313          void HmiFactoryDefaultSelTask(void)//4
 314          {
 315   1        WS_TaskState = HmiFactoryDefaultSelTIFG;
 316   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 317   1        {   
 318   2          WS_DelTaskIfg(WS_TaskState);
 319   2          {
 320   3            HmiFactoryDefaultFunc();
 321   3      //      time_test_lcd_backlight();
 322   3          }
 323   2        }
 324   1      }
 325          
 326          void HmiNon_InvasiveSelTask(void)//5
 327          {
 328   1        WS_TaskState = HmiNon_InvasiveSelTIFG;
 329   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 330   1        {   
 331   2          WS_DelTaskIfg(WS_TaskState);
 332   2          {
 333   3            HmiNon_InvasiveSelFunc();
 334   3          }
 335   2        } 
 336   1      }
 337          
 338          void HmiRunningTask(void)//6
 339          {
 340   1        WS_TaskState = HmiRunningTIFG;
 341   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 342   1        {   
 343   2          WS_DelTaskIfg(WS_TaskState);
 344   2          {
 345   3            HmiRunningFunc();
 346   3          }
 347   2        }   
 348   1      }
 349          
 350          void HmiSetTempPatientTask(void)//7
 351          {
 352   1        WS_TaskState = HmiSetTempPatientTIFG;
 353   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 354   1        {   
 355   2          WS_DelTaskIfg(WS_TaskState);
 356   2          {
 357   3            HmiSetTempPatientFunc();
 358   3          }
 359   2        } 
 360   1      }
 361          
 362          void HmiSetTempChamberTask(void)//8
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 7   

 363          {
 364   1        WS_TaskState = HmiSetTempChamberTIFG;
 365   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 366   1        {   
 367   2          WS_DelTaskIfg(WS_TaskState);
 368   2          {
 369   3            HmiSetTempChamberFunc();
 370   3          }
 371   2        } 
 372   1      } 
 373          
 374          void HmiSetInExpTask(void)//9
 375          {
 376   1        WS_TaskState = HmiSetInExpTIFG;
 377   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 378   1        {   
 379   2          WS_DelTaskIfg(WS_TaskState);
 380   2          {
 381   3            HmiSetInExpFunc();
 382   3          }
 383   2        }
 384   1      }
 385          
 386          void HmiSetTimeTask(void)//10
 387          {
 388   1        WS_TaskState = HmiSetTimeTIFG;
 389   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 390   1        {   
 391   2          WS_DelTaskIfg(WS_TaskState);
 392   2          {
 393   3            HmiSetTimeFunc();
 394   3          }
 395   2        }
 396   1      }
 397          
 398          void HmiScreenSaverModeTask(void)//11
 399          {
 400   1        WS_TaskState = HmiScreenSaverModeTIFG;
 401   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 402   1        {   
 403   2          WS_DelTaskIfg(WS_TaskState);
 404   2          {
 405   3            HmiScreenSaverModeFunc();
 406   3          }
 407   2        }
 408   1      }
 409          
 410          void GetTemp_HpChamberTask(void)//12
 411          {
 412   1        WS_TaskState = GetTemp_HpChamberTIFG;
 413   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 414   1        {   
 415   2          WS_DelTaskIfg(WS_TaskState);
 416   2          {
 417   3            GetTemp_HpChamberFunc();
 418   3          }
 419   2        }   
 420   1      }
 421          
 422          void GetTempHumidity_PatientTask(void)//13
 423          {
 424   1        WS_TaskState = GetTempHumidity_PatientTIFG;
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 8   

 425   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 426   1        {   
 427   2          WS_DelTaskIfg(WS_TaskState);
 428   2          {
 429   3            GetTempHumidity_PatientFunc();
 430   3          }
 431   2        }   
 432   1      }
 433          
 434          void RefreshTempHumidyTask(void)//14
 435          {
 436   1        WS_TaskState = RefreshTempHumidyTIFG;
 437   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 438   1        {   
 439   2          WS_DelTaskIfg(WS_TaskState);
 440   2          {
 441   3            RefreshTempHumidyFunc(0);
 442   3          }
 443   2        }   
 444   1      }
 445          
 446          void RefreshRunTimeTask(void)//15
 447          {
 448   1        WS_TaskState = RefreshRunTimeTIFG;
 449   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 450   1        {   
 451   2          WS_DelTaskIfg(WS_TaskState);
 452   2          {
 453   3            RefreshRunTimeFunc(0);
 454   3          }
 455   2        }     
 456   1      }
 457          
 458          void RefreshRTCTimeTask(void)//16
 459          {
 460   1        WS_TaskState = RefreshRTCTimeTIFG;
 461   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 462   1        {   
 463   2          WS_DelTaskIfg(WS_TaskState);
 464   2          {
 465   3            if((Work_State != UI_STATE_SetTime_MODE)//设定时间时不刷新实时RTC时间 
 466   3                &&(Work_State != UI_STATE_SCREENSAVER_MODE))
 467   3            {
 468   4              RefreshRTCTimeFunc(); 
 469   4            } 
 470   3            
 471   3          }
 472   2        }   
 473   1      }
 474          
 475          void HeaterWireControlTask(void)//17
 476          {
 477   1        WS_TaskState = HeaterPlateWireControlTIFG;
 478   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 479   1        {   
 480   2          WS_DelTaskIfg(WS_TaskState);
 481   2          {
 482   3            HeaterPlateWireControlFunc();
 483   3          }
 484   2        }
 485   1      }
 486          
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 9   

 487          void LowPowerModeTask(void)//18
 488          {
 489   1        WS_TaskState = LowPowerModeTIFG;
 490   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 491   1        {   
 492   2          WS_DelTaskIfg(WS_TaskState);
 493   2          {
 494   3            LowPowerModeFunc();
 495   3          }
 496   2        }
 497   1      }
 498          
 499          void HeaterWireModeDetTask(void)//19
 500          {
 501   1        WS_TaskState = HeaterWireModeDetTIFG;
 502   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 503   1        {   
 504   2          WS_DelTaskIfg(WS_TaskState);
 505   2          {
 506   3            HeaterWireModeDetFunc();
 507   3          }
 508   2        }
 509   1      }
 510          
 511          void AlarmErrorTask(void)//20
 512          {
 513   1        WS_TaskState = AlarmErrorTIFG;
 514   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 515   1        {   
 516   2          WS_DelTaskIfg(WS_TaskState);
 517   2          {
 518   3            AlarmErrorFunc();
 519   3          }
 520   2        }
 521   1      }
 522          
 523          void LowTempDet1STask(void)//21
 524          {
 525   1        WS_TaskState = LowTempDet1STIFG;
 526   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 527   1        {   
 528   2          WS_DelTaskIfg(WS_TaskState);
 529   2          {
 530   3            LowTempDet1SFunc();
 531   3          }
 532   2        }
 533   1      }
 534          
 535          void SaveDateToFlashTask(void)//22
 536          {
 537   1        WS_TaskState = SaveDateToFlashTIFG;
 538   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 539   1        {   
 540   2          WS_DelTaskIfg(WS_TaskState);
 541   2          {
 542   3            SaveDateToFlashFunc();
 543   3          }
 544   2        }
 545   1      }
 546          
 547          void UartRecTask(void)//23
 548          {
C51 COMPILER V9.59.0.0   NORMAL_TASK                                                       04/19/2019 09:37:28 PAGE 10  

 549   1          WS_TaskState = UartRecTIFG;
 550   1          if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 551   1          {   
 552   2              WS_DelTaskIfg(WS_TaskState);         
 553   2              UART_RecData_Func();   
 554   2          }
 555   1      }
 556          
 557          
 558          
 559          
 560          
 561          
 562          
 563          
 564          
 565          
 566          
 567          
 568          
 569          
 570          
 571          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1501    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     92    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
