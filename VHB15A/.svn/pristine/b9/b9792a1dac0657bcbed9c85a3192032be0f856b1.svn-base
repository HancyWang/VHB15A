C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE GUI
OBJECT MODULE PLACED IN ..\OBJ\GUI.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\CODE\GUI.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER NOAREGS
                    - INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sht31;..
                    -\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\GUI.lst) TABS(2) OBJECT(..\OBJ\GUI.
                    -obj)

line level    source

   1          #include "all.h"
   2          
   3          ////2019.03.29
   4          //sfr WDT_CONTR = 0xC1;
   5          //sbit P21 = (u8)0xA0^(u8)1;
   6          //sbit P22 = (u8)0xA0^(u8)2;
   7          //sbit P23 = (u8)0xA0^(u8)3;
   8          ////sbit P40 = (u8)0xC0^(u8)0;
   9          //sbit P40 = (u8)0xC0;
  10          
  11          static uint8_t Tik_POST_Tick_100mS = 0;//ÔËÐÐÄ£Ê½µÄÊ±±ê
  12          static uint8_t Tik_HmiFac_Tick_100mS_10S = 0;//10SÄÚ²»ÏìÓ¦ÔòÉÁË¸·ÅÈëÇ°Ì¨ÈÎÎñ
  13          static uint8_t OK_not_Pressed_flag = 0;//OK¼üÃ»ÓÐ±»°´ÏÂ±êÖ¾£¬10SºóÆô¶¯´Ë±êÖ¾
  14          static uint8_t HmiFac_Mode_Changed = 1;//Ä£Ê½±»¸Ä±ä
  15          //static uint8_t HmiLan_Sel_Changed = 1;//Ä£Ê½±»¸Ä±ä
  16          static uint8_t Tik_HmiNon_InvasiveSel_Tick_100mS = 0;//ÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæµÄÊ±±ê
  17          static uint16_t  Tik_ScreenSaver_Tick_100mS = 0;
  18          
  19          static uint16_t   Remeber_Temp_Value;//¼ÇÒäÉè¶¨µÄÊýÖµ
  20          
  21          static void Display_SET_Temp(uint16_t Temp);
  22          static void EnterSetTime(void);//½øÈëÊ±¼äÉè¶¨
  23          static void EnterSetInExp(void);//½øÈëInExpÉè¶¨
  24          static void Date_Is_Correct(void);//ÈÕÆÚÐ£Õý
  25          static void Display_In_Exp_Ratio(uint8_t Dis,uint8_t Dp_en);//ÏÔÊ¾In/Exp 
  26          
  27          static void Display_In_Exp_Ratio(uint8_t Dis,uint8_t Dp_en)//ÏÔÊ¾In/Exp  
  28          {
  29   1        if(Dp_en!=(uint8_t)0)
  30   1        {
  31   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+120,16,200,(const u8*)"In/Exp:",0,BLACK18);   
  32   2      
  33   2          show_str[0]=(u8)'1';
  34   2          show_str[1]=(u8)':';
  35   2          show_str[2]=(u8)'1';
  36   2          if(Dis <= (uint8_t)1)  //1-1:1 2-1:1.1 3-1:1.2 4-1:1.3 5-1:1.4 6-1:1.5
  37   2          {
  38   3            show_str[3]=(u8)' ';
  39   3            show_str[4]=(u8)' ';
  40   3          }
  41   2          else
  42   2          {
  43   3            show_str[3]=(u8)'.';
  44   3            show_str[4]=(u8)'0' + Dis-(u8)1;
  45   3          }
  46   2          show_str[5] = (u8)'\0';
  47   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+180,16,200,(const u8*)show_str,0,BLACK18); 
  48   2        }
  49   1        else
  50   1        {
  51   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+120,16,200,(const u8*)"In/Exp:",0,WHITE18); //²»ÏÔÊ¾
  52   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+180,16,200,(const u8*)"      ",0,WHITE18);  
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 2   

  53   2        }
  54   1        
  55   1      }
  56          
  57          void DisPlayTime(const uint8_t TempTime[7],uint8_t TimeKind)//ÏÔÊ¾Ê±¼ä
  58          {
  59   1        uint8_t i;
  60   1        uint8_t color;
  61   1        //2-7//Äê/ÔÂ/ÈÕ/Ê±/·Ö/Ãë
  62   1        
  63   1        color = BLACK18;
  64   1        if(TimeKind == (uint8_t)7)
  65   1        { //ÏÔÊ¾Ãë-------------------------------------------------    
  66   2          i=(TempTime[0]&(uint8_t)0xF)%(u8)10;
  67   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+68,i,BLACK18);   
  68   2          i=(TempTime[0]>>4)& (uint8_t)0x7;
  69   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+56,i,color);
  70   2        }
  71   1        else if(TimeKind == (uint8_t)6)
  72   1        { //ÏÔÊ¾·Ö========------------------------------------------     
  73   2          i=(TempTime[1]&(uint8_t)0xF)%(u8)10;
  74   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+40,i,color);
  75   2          i=(TempTime[1]>>4) & (uint8_t)0x7;
  76   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+28,i,color);
  77   2        }
  78   1        else if(TimeKind == (uint8_t)5)
  79   1        { //ÏÔÊ¾Ê±,²ÉÓÃ24Ð¡ÖÆ===========================      
  80   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y,TempTime[2]>>4,color);//BCDÂë
  81   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+12,TempTime[2]&(uint8_t)0x0f,color);
  82   2        }
  83   1        else if(TimeKind == (uint8_t)4)  
  84   1        {//ÏÔÊ¾ÈÕ
  85   2          i=(TempTime[3]&(uint8_t)0xF)%(u8)10;
  86   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+92,i,color);
  87   2          i=(TempTime[3]>>4)& (uint8_t)0x03;
  88   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+80,i,color);   
  89   2        }
  90   1        else if(TimeKind == (uint8_t)3)      
  91   1        {//ÏÔÊ¾ÔÂ
  92   2          i=(TempTime[4]&(uint8_t)0xF)%(u8)10;
  93   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+64,i,color);
  94   2          i=(TempTime[4]>>4)& (uint8_t)0x1;
  95   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+52,i,color);
  96   2        }
  97   1        else if(TimeKind == (uint8_t)2)
  98   1        {//ÏÔÊ¾Äê  
  99   2          i=(TempTime[6]&(uint8_t)0xF)%(u8)10;
 100   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+36,i,color);
 101   2          i=(TempTime[6]>>4)%(u8)10;
 102   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+24,i,color);
 103   2        } 
 104   1        else
 105   1        {
 106   2          //do nothing
 107   2        }
 108   1      }
 109          
 110          //ÏÔÊ¾Éè¶¨ÎÂ¶È
 111          static void Display_SET_Temp(uint16_t Temp)
 112          {
 113   1        Back_Color=WHITE18;   //ÏÔÊ¾Éè¶¨Öµ
 114   1        //ÎÂ¶ÈÍ¼±ê¿ªÊ¼ÉÁË¸,½øÈëÎÂ¶ÈÉè¶¨
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 3   

 115   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y,(uint8_t)(Temp/(u16)100),BLACK18);  
 116   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y+34,(u8)(Temp%(u16)100/(u16)10),BLACK18);   
 117   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*2)+5,(u8)(Temp%(u16)10),BLACK18);
 118   1        Draw_Rectangle_Real(POS_RT_TEMP_X+1,POS_RT_TEMP_Y+67,POS_RT_TEMP_X+8,POS_RT_TEMP_Y+71,BLACK18); //»­µã //
             -»­µã
 119   1      }
 120          
 121          
 122          //-----------½øÈëÄ³¸ö¹¤×÷Ä£Ê½½çÃæ
 123          void  HmiEnterToWorkStateFunc(WORK_STATUS State)
 124          {
 125   1        switch(State) 
 126   1        { 
 127   2          case UI_STATE_SERVICE_MODE:
 128   2          { 
 129   3            LCD_LIGHT_CLOSE;
 130   3            Back_Color=WHITE18;
 131   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 132   3      
 133   3            break;
 134   3          }   
 135   2          case UI_STATE_POST_MODE:
 136   2          {
 137   3            Tik_POST_Tick_100mS = 0;      
 138   3            LCD_LIGHT_CLOSE;
 139   3            Back_Color=WHITE18;
 140   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 141   3            break;
 142   3          }
 143   2          case UI_STATE_FACTORY_DEFAULT_SEL_MODE:
 144   2          {
 145   3            Tik_HmiFac_Tick_100mS_10S = 0;      
 146   3            OK_not_Pressed_flag = 0;//OK¼üÃ»ÓÐ±»°´ÏÂ±êÖ¾£¬10SºóÆô¶¯´Ë±êÖ¾
 147   3            
 148   3      
 149   3            {
 150   4              Mem_Flash_Recall(); //¶ÁÈ¡ÉÏ´ÎµÄ¼ÇÒä²¢ÑéÖ¤Êý¾Ý          
 151   4      
 152   4              defalut_mode = Load_User_Pre_MODE;  //Ô¤ÉèÄ£Ê½Ñ¡Ôñ  
 153   4              HmiFac_Mode_Changed = 1;//Ä£Ê½±»¸Ä±ä
 154   4              
 155   4              LCD_LIGHT_CLOSE;
 156   4              Draw_Rectangle(0,0,239,319,BLUE18,4);
 157   4              Draw_Rectangle_Real(0,0,239,319,WHITE18); 
 158   4              
 159   4              Back_Color=WHITE18;
 160   4              {
 161   5                CHAR str_previousSetting[]="Previous Settings";
 162   5                CHAR str_defaultSetting[]="Default Settings";
 163   5                CHAR str_select[]="Select";
 164   5                CHAR str_enter[]="Enter";
 165   5                CHAR str_Patient39C[]="Patient:39 C  ";
 166   5                CHAR str_chamber36C[]="Chamber:36 C  ";
 167   5                
 168   5                strcpy((CHAR*)show_str,str_previousSetting);        
 169   5                LCD_ShowString(Load_User_Pre_Set_X,Load_User_Pre_Set_Y+14,24,280,(const u8*)show_str,0,BLUE18); 
 170   5                strcpy((CHAR*)show_str,str_defaultSetting);       
 171   5                LCD_ShowString(Load_Fac_Set_X,Load_Fac_Set_Y+14,24,280,(const u8*)show_str,0,BLUE18); 
 172   5                strcpy((CHAR*)show_str,str_select);       
 173   5                LCD_ShowString(20,125,16,280,(const u8*)show_str,0,BLUE18);
 174   5                strcpy((CHAR*)show_str,str_enter);        
 175   5                LCD_ShowString(20,245,16,280,(const u8*)show_str,0,BLUE18);
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 4   

 176   5                  
 177   5                Back_Color=WHITE18;   
 178   5                strcpy((CHAR*)show_str,str_Patient39C);         
 179   5                LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y,16,280,(const u8*)show_str,0,BLUE18);
 180   5                Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê    
 181   5                strcpy((CHAR*)show_str,str_chamber36C);           
 182   5                LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*15),16,280,(const u8*)show_str,0,BLUE1
             -8);
 183   5                Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê   
             -        
 184   5                LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y,16,280,(const u8*)"In/Exp:1:1.3",0,BLUE18
             -);//            
 185   5                Draw_Rectangle(Load_Fac_Set_X+39,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X-15,Load_User_Pre_Set_Y+24
             -2,RED18,2);//»­²ÎÊý¿ò         
 186   5                Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-10,RED18);//»­Ñ¡Ôñ²ÎÊýºáÏß       
             -    
 187   5              }
 188   4            
 189   4              Back_Color=WHITE18;
 190   4              DISP_ICO_40X40(15,30,3,BLUE18);//ÏÔÊ¾UPÍ¼±ê 
 191   4              DISP_ICO_40X40(15,80,4,BLUE18);//ÏÔÊ¾DOWNÍ¼±ê 
 192   4              DISP_ICO_40X40(15,200,2,BLUE18);//ÏÔÊ¾OKÍ¼±ê
 193   4            }   
 194   3            break;
 195   3          } 
 196   2            
 197   2          case UI_STATE_NON_INVASIVE_MODE:
 198   2          {     
 199   3            Tik_HmiNon_InvasiveSel_Tick_100mS = 0;//ÓÐ´´ÎÞ´´µÄÊ±±ê
 200   3            LCD_LIGHT_CLOSE;
 201   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 202   3            Back_Color=WHITE18;
 203   3            Disp_WuChuang(POS_Select_WC_X,POS_Select_WC_Y,BLUE18);
 204   3            Disp_YouChuang(POS_Select_YC_X,POS_Select_YC_Y,BLUE18);
 205   3            Draw_Rectangle(75,182,162,262,WHITE18,4);
 206   3            Draw_Rectangle(75,58,162,136,RED18,4);
 207   3            LCD_LIGHT_OPEN; 
 208   3            break;
 209   3          }
 210   2          
 211   2          case UI_STATE_RUNNING_NORMAL_MODE:
 212   2          {
 213   3      //      Tik_HmiRunning_Tick_100mS = 0;
 214   3            LCD_LIGHT_CLOSE;      
 215   3            DrawWorkWindows();      
 216   3            RefreshRunTimeFunc(1);//Ç¿ÖÆË¢ÐÂÔËÐÐÊ±¼ä
 217   3            RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂ¶ÈÏÔÊ¾     
 218   3            LCD_LIGHT_OPEN;
 219   3            Tik_ScreenSaver_Tick_100mS = 0;
 220   3            break;
 221   3          } 
 222   2      
 223   2          case UI_STATE_SetTempPatient_MODE:
 224   2          {
 225   3            Remeber_Temp_Value = (uint16_t)Set_RT_Temp; 
 226   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);    
 227   3            Display_SET_Temp(Remeber_Temp_Value);     
 228   3      //      Set_CQK_Subtract_RT = Set_CQK_Temp - Set_RT_Temp;//³öÆø¿ÚºÍÈËÌå¶ËÉè¶¨ÎÂ¶È²î£¬¼ÇÒä´Ë²îÖµ 
 229   3            break;
 230   3          }
 231   2          
 232   2          case UI_STATE_SetTempChamber_MODE:
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 5   

 233   2          {
 234   3            Remeber_Temp_Value = Set_CQK_Temp;  
 235   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);    
 236   3            Display_SET_Temp(Remeber_Temp_Value);   
 237   3            break;
 238   3          }
 239   2          
 240   2          case UI_STATE_SetTime_MODE: 
 241   2          {
 242   3            EnterSetTime();
 243   3            break;
 244   3          }
 245   2          
 246   2          case UI_STATE_SetInExp_MODE: 
 247   2          {
 248   3      //      Display_In_Exp_Ratio(In_Exp_Ratio,1); 
 249   3            EnterSetInExp();//½øÈëInExpÉè¶¨
 250   3            break;
 251   3          }
 252   2          case UI_STATE_POWER_OFF_MODE:
 253   2            break;
 254   2          case UI_STATE_SCREENSAVER_MODE:
 255   2            break;
 256   2          case UI_STATE_DATAREADER_MODE:
 257   2            break;
 258   2          default:
 259   2            //do nothing
 260   2            break;
 261   2        }
 262   1      }
 263          
 264          //
 265          void HmiServiceModeFunc(void)
 266          {
 267   1        static INT ServiceMode_Step = 0;
 268   1        
 269   1        //ÏÔÊ¾ÆÁ´¿É«²âÊÔ  
 270   1        if(ServiceMode_Step == 0)
 271   1        {
 272   2          ServiceMode_Step = 1;
 273   2          Draw_Rectangle_Real(0,0,239,319,RED18);   //ºì
 274   2          Back_Color=RED18;
 275   2          LCD_ShowString(220,20,16,200,(const u8*)"LCD TEST_RED(Test 1/6)",0,WHITE18);
 276   2          LCD_ShowString(200,20,16,200,(const u8*)"Press Left Up Key...",0,WHITE18); 
 277   2          LCD_LIGHT_OPEN; 
 278   2        }
 279   1        else if(ServiceMode_Step == 1)
 280   1        {
 281   2          if(Key_State_Present == KEY_STATE_UP_Short)//ÏòÏÂ¼üµ½¹¤³§Éè¶¨
 282   2          {
 283   3            ServiceMode_Step = 2;     
 284   3            Draw_Rectangle_Real(0,0,239,319,GREEN18);  //ÂÌ
 285   3            Back_Color=GREEN18;
 286   3            LCD_ShowString(220,20,16,200,(const u8*)"LCD TEST_GREEN(Test 2/6)",0,RED18);
 287   3            LCD_ShowString(200,20,16,200,(const u8*)"Press Left Down Key...",0,RED18);
 288   3          }   
 289   2        }
 290   1        else if(ServiceMode_Step == 2)
 291   1        {
 292   2          if(Key_State_Present == KEY_STATE_Down_Short)
 293   2          {
 294   3            ServiceMode_Step = 3;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 6   

 295   3            Draw_Rectangle_Real(0,0,239,319,BLUE18);   //À¶
 296   3            Back_Color=BLUE18;
 297   3            LCD_ShowString(220,20,16,200,(const u8*)"LCD TEST_BLUE(Test 3/6)",0,RED18);
 298   3            LCD_ShowString(200,20,16,200,(const u8*)"Press Right Down Key...",0,RED18); 
 299   3          }
 300   2        }
 301   1        else if(ServiceMode_Step == 3)
 302   1        { 
 303   2          if(Key_State_Present == KEY_STATE_Mute_Short)
 304   2          {
 305   3            ServiceMode_Step = 4;
 306   3            Draw_Rectangle_Real(0,0,239,319,BLACK18);  //ºÚ
 307   3            Back_Color=BLACK18;
 308   3            LCD_ShowString(220,20,16,200,(const u8*)"LCD TEST_BLACK(Test 4/6)",0,RED18);
 309   3            LCD_ShowString(200,20,16,200,(const u8*)"Press Right Up Key...",0,RED18); 
 310   3          }
 311   2        }
 312   1        else if(ServiceMode_Step == 4)
 313   1        { 
 314   2          if(Key_State_Present == KEY_STATE_OK_Short)
 315   2          {
 316   3            uint8_t TRUE=(uint8_t)1;
 317   3            //LCD²âÊÔ½áÊø 
 318   3            ServiceMode_Step = 5;
 319   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);  //W25X¶ÁÐ´²âÊÔ
 320   3            Back_Color=WHITE18;
 321   3            LCD_ShowString(220,20,16,280,(const u8*)"W25X Write&Read Test(Test 5/6)",0,GRAY18);
 322   3            LCD_ShowString(200,20,16,200,(const u8*)"Press Left Up Key...",0,GRAY18);   
 323   3      
 324   3            //WX25 ²âÊÔ
 325   3            SPI_Erase_Sector(0x100000);//1M×Ö½ÚÆðÆôÉÈÇø²Á³ý
 326   3            WDT_CONTR = 0x3F; ; 
 327   3            delay_ms(300);
 328   3            SaveData[0] = (u8)'O';
 329   3            SaveData[1] = (u8)'K'; 
 330   3            SPI_Write_nBytes(0x100000,2,SaveData);
 331   3            delay_ms(10);
 332   3            SaveData[0] = (u8)0xff;
 333   3            SaveData[1] = (u8)0xff;
 334   3            SPI_Read_nBytes(0x100000,2,SaveData); 
 335   3            //*/
 336   3            
 337   3            if((SaveData[0] == (u8)'O')&&(SaveData[1] == (u8)'K'))
 338   3            {                
 339   4              LCD_ShowString(160,70,16,200,(const u8*)"W25X TEST OK!",0,RED18);
 340   4            }
 341   3            else
 342   3            {
 343   4              LCD_ShowString(160,70,16,200,(const u8*)"W25X TEST Fail!",0,RED18);
 344   4              while(TRUE!=(uint8_t)0)
 345   4              {
 346   5                WDT_CONTR = 0x3F;
 347   5              }
 348   4            } 
 349   3            //ÏÔÊ¾°æ±¾ºÅ
 350   3            LCD_Show_Verion();
 351   3          }
 352   2        }
 353   1        else if(ServiceMode_Step == 5)
 354   1        {
 355   2          if((!KEY_LEFT_DOWN_IN)&&(!KEY_RIGHT_DOWN_IN))  //ÏÔÊ¾°æ±¾ÈÕÆÚ
 356   2          {
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 7   

 357   3            //ÏÔÊ¾ÈÕÆÚ  
 358   3            LCD_ShowString((u16)20,(u16)20,(u16)16,(u16)200,(const u8*)DATE_VER,0,GRAY18);    
 359   3          }
 360   2          else if(Key_State_Present == KEY_STATE_UP_Short)
 361   2          {
 362   3            ServiceMode_Step = 6;
 363   3            
 364   3            LCD_LIGHT_CLOSE;//±³¹â 
 365   3            Back_Color=WHITE18;   
 366   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);  //°×
 367   3            LCD_ShowString(220,20,16,280,(const u8*)"Temperature & Humidity(Test 6/6)",0,RED18);
 368   3      
 369   3            DISP_ICO_52X64(POS_ICO_TEMP_X-8,POS_ICO_TEMP_Y,0,BLACK18);//ÈËÌå¶ËÍ¼±ê
 370   3            DISP_ICO_32X40(POS_RT_TEMP_X-8,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î»
 371   3            DISP_ICO_40X40(POS_ICO_SHIDU_X,POS_ICO_TEMP_Y,0,BLACK18); //Êª¶ÈÍ¼±ê
 372   3            DISP_ICO_32X40(POS_RT_RH_X+2,POS_RT_RH_Y+(19*2),ICO_PER,BLACK18); //ÏÔÊ¾Êª¶Èµ¥Î»  
 373   3            DISP_RH14X24(POS_RT_RH_X+5,POS_RT_RH_Y+70,0,BLACK18);
 374   3            DISP_RH14X24(POS_RT_RH_X+5,POS_RT_RH_Y+84,1,BLACK18);
 375   3            DISP_ICO_52X64(55,POS_ICO_TEMP_Y,1,BLACK18); //³öÆø¿ÚÎÂ¶ÈÍ¼±ê
 376   3            DISP_ICO_32X40(55,POS_ICO_TEMP_Y+(35*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î»
 377   3            DISP_HEAT_36X24(15,POS_ICO_TEMP_Y+5,BLACK18);//¼ÓÈÈÅÌÎÂ¶ÈÍ¼±ê 
 378   3            DISP_ICO_32X40(5,POS_ICO_TEMP_Y+(35*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î» 
 379   3            LCD_LIGHT_OPEN;//¿ª±³¹â     
 380   3          }
 381   2          else
 382   2          {
 383   3            //do nothing
 384   3          }
 385   2        }
 386   1        else if(ServiceMode_Step == 6)
 387   1        {
 388   2          ServiceMode_TempHumidy_Disp(); //²âÊÔÄ£Ê½ÏÂÏÔÊ¾ÎÂÊª¶È
 389   2          
 390   2          if(!KEY_RIGHT_UP_IN)
 391   2          {
 392   3            if(JEP_Temp<=800)
 393   3            {
 394   4              Micro_Temp_Val = 201;
 395   4            }
 396   3            else
 397   3            {
 398   4              Micro_Temp_Val = 0;
 399   4            }
 400   3            if(RT_Temp<=400)
 401   3            {
 402   4              Micro_Temp_In = 201;
 403   4              Micro_Temp_Out = 201;
 404   4            }
 405   3            else
 406   3            {
 407   4              Micro_Temp_In = 0;
 408   4              Micro_Temp_Out = 0;
 409   4            }
 410   3          }
 411   2          else
 412   2          {
 413   3            Micro_Temp_Val = 0;
 414   3            Micro_Temp_In = 0;
 415   3            Micro_Temp_Out = 0;
 416   3          }
 417   2          
 418   2          if((!KEY_LEFT_DOWN_IN)&&(!KEY_RIGHT_DOWN_IN))//Í¬Ê±°´ÏÂÁ½¼ü,½øÈëÕý³£¹¤×÷Ä£Ê½
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 8   

 419   2          {     
 420   3            Test_Mode_Dis_Jrp_Ctl = 1; //ÊÇ´Ó²âÊÔÄ£Ê½½øÈëÕý³£Ä£Ê½,¼´ÏÔÊ¾¼ÓÈÈÅÌ¿ØÖÆµÄÊý¾Ý  
 421   3            Work_State = UI_STATE_POST_MODE;
 422   3            HmiEnterToWorkStateFunc(UI_STATE_POST_MODE);      
 423   3          }   
 424   2        }
 425   1        else
 426   1        {
 427   2          //do nothing
 428   2        }
 429   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü
 430   1      }  
 431          
 432          //-----------POST½çÃæ
 433          void HmiPostFunc_Tik_Cnt(void)
 434          {
 435   1        if(Tik_POST_Tick_100mS < (u8)250)
 436   1        {
 437   2          Tik_POST_Tick_100mS++;
 438   2        }
 439   1      }
 440          
 441          void  HmiPostFunc(void)//GUI --- 
 442          { 
 443   1        static uint8_t Post_Step=0;
 444   1        uint8_t i;
 445   1      
 446   1        //LCD_LIGHT_OPEN;//¿ª±³¹â   
 447   1        if(Post_Step == (u8)0)//RTC×Ô¼ì1
 448   1        {
 449   2          //LCD_ShowString(220,20,16,200,"POST_STEP0!",0,RED18);
 450   2          i = RX8010_Initialize();//RTC³õÊ¼»¯ 
 451   2          if(i == (u8)RX8010_INIT_FAIL)//RTC³õÊ¼»¯Ê§Ð§
 452   2          {
 453   3            Post_Step = 255;//FAIL,ÐèÖØÐÂ¿ª»ú»òËÍÐÞ
 454   3            LCD_LIGHT_CLOSE;//±³¹â
 455   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 456   3            LCD_ShowString(180,20,16,200,(const u8*)"RTC Initialize Fail!",0,RED18);
 457   3            LCD_ShowString(140,40,16,300,(const u8*)"Please restart,if the problem",0,RED18);
 458   3            LCD_ShowString(120,20,16,300,(const u8*)"reproduce,contact to the supplier!",0,RED18);
 459   3            WDT_CONTR = 0x3F; 
 460   3            LCD_LIGHT_OPEN;//±³¹â
 461   3          }
 462   2          else if(i == (u8)RX8010_INIT_OK)//RTCÎ´³õÊ¼»¯£¬Ôò×Ô¶¯³õÊ¼»¯³É¹¦
 463   2          {
 464   3            Post_Step = 1;//
 465   3            Tik_POST_Tick_100mS = 0;
 466   3            LCD_LIGHT_CLOSE;//±³¹â
 467   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 468   3            LCD_ShowString(220,20,16,200,(const u8*)"RTC Initialize OK!",0,RED18);
 469   3            LCD_LIGHT_OPEN;//¿ª±³¹â     
 470   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 471   3          }
 472   2          else
 473   2          {
 474   3            Post_Step = 2;//
 475   3          }
 476   2        }
 477   1        else if(Post_Step == (u8)1)//RTC×Ô¼ì2-×Ô¶¯³õÊ¼»¯,µÈ´ý2S
 478   1        {
 479   2          //LCD_ShowString(190,20,16,200,"POST STEP1!",0,RED18);
 480   2          if(Tik_POST_Tick_100mS > (u8)20)
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 9   

 481   2          {
 482   3            Post_Step = 2;
 483   3          }   
 484   2        }
 485   1        else if(Post_Step == (u8)2)//FLASH×Ô¼ì1
 486   1        {
 487   2          //LCD_ShowString(160,20,16,200,"POST STEP2!",0,RED18);    
 488   2          SPI_Read_nBytes(0x100000,2,SaveData); 
 489   2          if((SaveData[0] == (u8)'O')&&(SaveData[1] == (u8)'K'))//Ð£Ñé³É¹¦
 490   2          {
 491   3            Post_Step = 4;
 492   3          }
 493   2          else
 494   2          {
 495   3            Post_Step = 3;
 496   3            SPI_Erase_Sector(0x100000);//1M×Ö½ÚÆðÆôÉÈÇø²Á³ý
 497   3          }
 498   2        }
 499   1        else if(Post_Step == (u8)3)//FLASH×Ô¼ì2
 500   1        {
 501   2          //LCD_ShowString(130,20,16,200,"POST STEP3!",0,RED18);    
 502   2          SaveData[0] = (u8)'O';
 503   2          SaveData[1] = (u8)'K'; 
 504   2          SPI_Write_nBytes(0x100000,2,SaveData);
 505   2          delay_ms(10);
 506   2          SaveData[0] = 0xff;
 507   2          SaveData[1] = 0xff;
 508   2          SPI_Read_nBytes(0x100000,2,SaveData); 
 509   2            
 510   2          if((SaveData[0] == (u8)'O')&&(SaveData[1] == (u8)'K'))
 511   2          {                
 512   3            Post_Step = 4;//OK
 513   3          }
 514   2          else
 515   2          {
 516   3            Post_Step = 255;//FAIL,ÐèÖØÐÂ¿ª»ú»òËÍÐÞ       
 517   3            LCD_ShowString(180,20,16,200,(const u8*)"Memory Initialize Fail!",0,RED18);
 518   3            LCD_ShowString(140,40,16,300,(const u8*)"Please restart,if the problem",0,RED18);
 519   3            LCD_ShowString(120,20,16,300,(const u8*)"reproduce,contact to the supplier!",0,RED18);
 520   3          }     
 521   2        }
 522   1        else if(Post_Step == (u8)4)//HP SENSOR-2
 523   1        {
 524   2          //LCD_ShowString(100,20,16,200,"POST STEP4!",0,RED18);    
 525   2          Tik_POST_Tick_100mS = 0;
 526   2          Post_Step = 5;
 527   2        }
 528   1        else if(Post_Step == (u8)5)//HP SENSOR-2
 529   1        {
 530   2          //LCD_ShowString(70,20,16,200,"POST STEP5!",0,RED18); 
 531   2          //LCD_ShowxNum(130,70,16,3,No_HeatSensor_Times,0x80,BLACK18); //
 532   2          if(Tik_POST_Tick_100mS > (u8)10)//ÑÓÊ±1S
 533   2          {
 534   3            if(No_HeatSensor_Times>(u8)25)//¼ÓÈÈÅÌ´«¸ÐÆ÷´íÎó¼ì²â,1S¿ÉÒÔ¼ì²âµ½50´Î
 535   3            {
 536   4              Post_Step = 6;
 537   4              Tik_POST_Tick_100mS = 0;
 538   4            } 
 539   3            else
 540   3            {
 541   4              Post_Step = 7;//PASS    
 542   4            }
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 10  

 543   3          }
 544   2        }
 545   1        else if(Post_Step == (u8)6)//HP SENSOR-3 ¼ì²âÁ½´Î
 546   1        {
 547   2          //LCD_ShowString(40,20,16,200,"POST STEP6!",0,RED18);
 548   2          //LCD_ShowxNum(130,150,16,3,No_HeatSensor_Times,0x80,BLACK18); //·¢ÈÈÅÌ¼ÓÈÈµÄÄ£Ê½ÏÔÊ¾   
 549   2          if(Tik_POST_Tick_100mS > (u8)30)//ÑÓÊ±3S
 550   2          {
 551   3            if(No_HeatSensor_Times>(u8)100)//¼ÓÈÈÅÌ´«¸ÐÆ÷´íÎó¼ì²â 4S¼ì²âµ½200´Î
 552   3            {
 553   4              Post_Step = 255;
 554   4              LCD_ShowString(180,20,16,200,(const u8*)"Sensor Initialize Fail!",0,RED18);
 555   4              LCD_ShowString(140,40,16,300,(const u8*)"Please restart,if the problem",0,RED18);
 556   4              LCD_ShowString(120,20,16,300,(const u8*)"reproduce,contact to the supplier!",0,RED18);         
 557   4            }
 558   3            else
 559   3            {
 560   4              Post_Step = 7;//PASS    
 561   4            }
 562   3          }
 563   2        }
 564   1        else if(Post_Step == (u8)7)//
 565   1        {
 566   2          //LCD_ShowString(10,20,16,200,"POST_STEP7!",0,RED18);   
 567   2          Work_State = UI_STATE_FACTORY_DEFAULT_SEL_MODE;
 568   2          HmiEnterToWorkStateFunc(UI_STATE_FACTORY_DEFAULT_SEL_MODE);
 569   2        }
 570   1        else if(Post_Step == (u8)255)//FAIL
 571   1        {
 572   2          LCD_LIGHT_OPEN; 
 573   2        }
 574   1        else
 575   1        {
 576   2          //do nothing
 577   2        }
 578   1      }
 579          
 580          
 581          //-----------¿ª»úÑ¡Ôñ½çÃæ
 582          static uint8_t Tik_HmiFac_Tick_100mS_OK_flash = 0;//OKÉÁË¸¶ÁÊý
 583          void HmiFactoryDefault_Tik_Cnt(void)
 584          {
 585   1        if(Tik_HmiFac_Tick_100mS_10S < (u8)250)
 586   1        {
 587   2          Tik_HmiFac_Tick_100mS_10S++;
 588   2        }
 589   1        if(Tik_HmiFac_Tick_100mS_OK_flash <(u8)250 )
 590   1        {
 591   2          Tik_HmiFac_Tick_100mS_OK_flash++;
 592   2        }
 593   1      }
 594          
 595          void  HmiFactoryDefaultFunc(void)//GUI --- 
 596          {
 597   1        uint16_t Pre_Disp_Deg_10;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶È¸öÎ» ÏÔÊ¾
 598   1        uint16_t Pre_Disp_Deg_1;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶ÈÐ¡Êý ÏÔÊ¾
 599   1        uint16_t Pre_Disp_Deg_CQK_10;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶È¸öÎ» ÏÔÊ¾
 600   1        uint16_t Pre_Disp_Deg_CQK_1;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶ÈÐ¡Êý ÏÔÊ¾
 601   1      
 602   1        if(Tik_HmiFac_Tick_100mS_10S >= (u8)100)//10S
 603   1        {
 604   2          OK_not_Pressed_flag = 1;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 11  

 605   2        }   
 606   1        
 607   1        if(OK_not_Pressed_flag!=(uint8_t)0)
 608   1        {     
 609   2          if(Tik_HmiFac_Tick_100mS_OK_flash == (u8)1)
 610   2          {
 611   3            
 612   3          }     
 613   2          else if(Tik_HmiFac_Tick_100mS_OK_flash == (u8)5)
 614   2          {
 615   3      
 616   3          }     
 617   2          else if(Tik_HmiFac_Tick_100mS_OK_flash == (u8)10)
 618   2          {
 619   3            Back_Color=WHITE18;
 620   3            DISP_ICO_40X40(15,200,2,BLUE18);//ÏÔÊ¾OKÍ¼±ê  
 621   3            Back_Color=WHITE18;         
 622   3          }
 623   2          else if(Tik_HmiFac_Tick_100mS_OK_flash >= (u8)20)//0.5HzµÄÉÁË¸ÆµÂÊ
 624   2          {
 625   3            Tik_HmiFac_Tick_100mS_OK_flash = 0;       
 626   3            Back_Color=WHITE18; 
 627   3            DISP_ICO_40X40(15,200,2,RED18);//ÏÔÊ¾OKÍ¼±ê 
 628   3            Back_Color=WHITE18;
 629   3            Sound_Short();
 630   3          }
 631   2          else
 632   2          {
 633   3            //do nothing
 634   3          }
 635   2        }
 636   1              
 637   1      //ÒÔÏÂ¼ì²âKEY 
 638   1        if((Key_State_Present == KEY_STATE_Down_Short)//ÏòÏÂ¼üµ½¹¤³§Éè¶¨
 639   1          ||(Key_State_Present == KEY_STATE_Down_Long_First))
 640   1      
 641   1        {
 642   2          if(defalut_mode == (u8)Load_User_Pre_MODE)
 643   2          {
 644   3            HmiFac_Mode_Changed = 1;         
 645   3            defalut_mode = Load_Fac_MODE;  
 646   3          }
 647   2        } 
 648   1        else if((Key_State_Present == KEY_STATE_UP_Short)
 649   1          ||(Key_State_Present == KEY_STATE_UP_Long_First))
 650   1        {
 651   2          if(defalut_mode == (u8)Load_Fac_MODE)
 652   2          {
 653   3            HmiFac_Mode_Changed = 1;  
 654   3            defalut_mode = Load_User_Pre_MODE;
 655   3          }
 656   2        }
 657   1        else if((Key_State_Present == KEY_STATE_OK_Short)//½øÈë¿ª»úÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ»òÖ±½Ó½øÈ¥¿ª»úÔËÐÐ½çÃæ
 658   1             ||(Key_State_Present ==KEY_STATE_OK_Long_First))
 659   1        {
 660   2          Load_Settings_Before_Choice();//ÔÚÑ¡Ôñ·½¿ò³öÏÖÖ®Ç°£¬Òª´¦ÀíµÄÊý¾Ý£¬ÒÔÍ¬Ê±¼æÈÝÓÐÎÞÑ¡Ôñ¼ÇÒä½çÃæ³ÌÐò         
 661   2          HmiFac_Mode_Changed = 0;  
 662   2          LCD_LIGHT_CLOSE;      
 663   2          if(defalut_mode == (u8)Load_Fac_MODE)//Ä¬ÐíÉè¶¨
 664   2          {          
 665   3            Work_State = UI_STATE_NON_INVASIVE_MODE;
 666   3            HmiEnterToWorkStateFunc(UI_STATE_NON_INVASIVE_MODE);
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 12  

 667   3          }
 668   2          else//ÉÏÒ»´ÎµÄÉè¶¨
 669   2          {
 670   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
 671   3            HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);           
 672   3          }        
 673   2        }
 674   1        else
 675   1        {
 676   2          //do nothing
 677   2        }
 678   1      
 679   1        if(HmiFac_Mode_Changed!=(uint8_t)0)
 680   1        {
 681   2          HmiFac_Mode_Changed = 0;          
 682   2              
 683   2          data_flash.Language = Lan_English;//·ÇFANEMÖ»ÓÐÓ¢Óï
 684   2      
 685   2          
 686   2          if(data_flash.Work_Mode==(u8)Noninvasive_Mode)    //¼ÆËãÒªÏÔÊ¾µÄÊý¾Ý  
 687   2          {           
 688   3            Pre_Disp_Deg_10 = data_flash.Set_RT_WCTemp * (u16)5 / (u16)10;//ÕûÊýÎ»
 689   3            Pre_Disp_Deg_1 = data_flash.Set_RT_WCTemp * (u16)5 % (u16)10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 690   3            
 691   3            Pre_Disp_Deg_CQK_10 = data_flash.Set_CQK_WCTemp * (u16)5 / (u16)10;//ÕûÊýÎ»
 692   3            Pre_Disp_Deg_CQK_1 = data_flash.Set_CQK_WCTemp * (u16)5 % (u16)10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 693   3          }
 694   2          else
 695   2          {
 696   3            Pre_Disp_Deg_10 = data_flash.Set_RT_YCTemp * (u16)5 / (u16)10;//ÕûÊýÎ»
 697   3            Pre_Disp_Deg_1 = data_flash.Set_RT_YCTemp * (u16)5 % (u16)10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 698   3            
 699   3            Pre_Disp_Deg_CQK_10 = data_flash.Set_CQK_YCTemp * (u16)5 / (u16)10;//ÕûÊýÎ»
 700   3            Pre_Disp_Deg_CQK_1 = data_flash.Set_CQK_YCTemp * (u16)5 % (u16)10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 701   3          } 
 702   2                
 703   2          if(defalut_mode == (u8)Load_User_Pre_MODE)  //ÓÃ»§ÉÏÒ»´ÎµÄÉè¶¨   
 704   2          {     //»­ºìÉ«¿ò
 705   3            Draw_Rectangle(Load_Fac_Set_X-10,Load_User_Pre_Set_Y-10,Load_Fac_Set_X+34,Load_User_Pre_Set_Y+242,WHITE
             -18,4);
 706   3            Draw_Rectangle(Load_User_Pre_Set_X-10,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X+34,Load_User_Pre_Set_Y
             -+242,RED18,4);//
 707   3            
 708   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,84,Load_User_Pre_Set_Y-10,WHITE18);//
 709   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-29,WHITE18);// 
 710   3           
 711   3            Draw_Rectangle_Real(203,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-10,RED18);//
 712   3            Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-29,RED18);//   
 713   3            
 714   3            if(data_flash.Work_Mode==(u8)Noninvasive_Mode)    //
 715   3            {
 716   4              CHAR str_modeNoinvasive[]="Mode:Noninvasive      ";
 717   4              strcpy((CHAR*)show_str,str_modeNoinvasive);       
 718   4              LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y,16,280,(const u8*)show_str,0,BLUE18);
 719   4            }
 720   3            else
 721   3            {
 722   4              CHAR str_modeInvasive[]="Mode:Invasive         ";
 723   4              strcpy((CHAR*)show_str,str_modeInvasive);
 724   4              LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y,16,280,(const u8*)show_str,0,BLUE18);
 725   4            }
 726   3            
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 13  

 727   3            LCD_ShowxNum(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*8),16,2,Pre_Disp_Deg_10,0x00,BLUE18);//»¼Õ
             -ß¶ËÎÂ¶È
 728   3            if(Pre_Disp_Deg_1 == (u16)0)//ÎÞÐ¡Êý
 729   3            {
 730   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*11),16,280,(const u8*)"C  ",0,BLUE18);/
             -/
 731   4              Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 732   4            }
 733   3            else//ÓÐÐ¡Êý
 734   3            {
 735   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*10),16,280,(const u8*)".5",0,BLUE18);//
             -.5
 736   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*13),16,280,(const u8*)"C ",0,BLUE18);//
 737   4              Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*12),2,BLUE18);//ÎÂ¶ÈÍ¼±ê                
 738   4            } 
 739   3      
 740   3            LCD_ShowxNum(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*8)+(8*15),16,2,Pre_Disp_Deg_CQK_10,0x00,BL
             -UE18);//³öÆø¿Ú¶ËÎÂ¶È
 741   3            if(Pre_Disp_Deg_CQK_1 == (u16)0)//ÎÞÐ¡Êý
 742   3            {
 743   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*11)+(8*15),16,280,(const u8*)"C  ",0,BL
             -UE18);//
 744   4              Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 745   4            }
 746   3            else//ÓÐÐ¡Êý
 747   3            {
 748   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*10)+(8*15),16,280,(const u8*)".5",0,BLU
             -E18);//.5
 749   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*13)+(8*15),16,280,(const u8*)"C ",0,BLU
             -E18);//
 750   4              Draw_Circle((Load_User_Pre_Set_X - 56) +12,(Load_User_Pre_Set_Y+4+(8*12))+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê 
             -              
 751   4            }               
 752   3            
 753   3            if(data_flash.In_Exp_Ratio == (u8)1)//1:1
 754   3            {
 755   4              LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,(const u8*)"  ",0,BLUE18);//
             -1:1
 756   4            }
 757   3            else
 758   3            {
 759   4              LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,(const u8*)".",0,BLUE18); 
 760   4              LCD_ShowxNum(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*11),16,1,(u32)data_flash.In_Exp_Ratio-(u3
             -2)1,(u8)0x0,BLUE18);//
 761   4            }                       
 762   3          }
 763   2          else  //¹¤³§Éè¶¨
 764   2          {
 765   3            CHAR str_invasive[]="Invasive         ";
 766   3            CHAR str_patient39C[]="Patient:39 C  ";
 767   3            CHAR str_chamber36C[]="Chamber:36 C  ";
 768   3            
 769   3            
 770   3            Draw_Rectangle(Load_Fac_Set_X-10,Load_User_Pre_Set_Y-10,Load_Fac_Set_X+34,Load_User_Pre_Set_Y+242,RED18
             -,4);
 771   3            Draw_Rectangle(Load_User_Pre_Set_X-10,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X+34,Load_User_Pre_Set_Y
             -+242,WHITE18,4);//
 772   3           
 773   3            Draw_Rectangle_Real(203,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-10,WHITE18);//            
 774   3            Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-29,WHITE18);//
 775   3           
 776   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,84,Load_User_Pre_Set_Y-10,RED18);//
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 14  

 777   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-29,RED18);//  
 778   3            strcpy((CHAR*)show_str,str_invasive);
 779   3            LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y+(8*5),16,280,(const u8*)show_str,0,BLUE18);
             -//ÓÐ´´          
 780   3            strcpy((CHAR*)show_str,str_patient39C);       
 781   3            LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y,16,280,(const u8*)show_str,0,BLUE18);
 782   3            Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê  
 783   3            strcpy((CHAR*)show_str,str_chamber36C);           
 784   3            LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*15),16,280,show_str,0,BLUE18);
 785   3            Draw_Circle((Load_User_Pre_Set_X - 56) +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 786   3            LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,(const u8*)".3",0,BLUE18);//1
             -:1.3 
 787   3          }
 788   2          LCD_LIGHT_OPEN; 
 789   2        } 
 790   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü
 791   1      }
 792          
 793          //-----------¿ª»úÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ
 794          
 795          void HmiNon_InvasiveSel_Tik_Cnt(void)
 796          {
 797   1        if(Tik_HmiNon_InvasiveSel_Tick_100mS < (u8)250)
 798   1        {
 799   2          Tik_HmiNon_InvasiveSel_Tick_100mS++;
 800   2        }
 801   1      }
 802          
 803          void  HmiNon_InvasiveSelFunc(void)//ÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ
 804          {
 805   1        WDT_CONTR = 0x3F; //¿ªÆôWDT,ÔÚ22.1184Ê±Ê±¼äÎª4.55S  
 806   1        {
 807   2          if((Key_State_Present == KEY_STATE_UP_Short)//
 808   2               ||(Key_State_Present ==KEY_STATE_UP_Long_First))
 809   2          {
 810   3      
 811   3            if(Work_Mode==(u8)0)
 812   3            {
 813   4              Work_Mode=1;
 814   4            }
 815   3            else
 816   3            {
 817   4              Work_Mode=0;  
 818   4            }
 819   3      
 820   3            if(Work_Mode==(u8)0)  //ÎÞ´´Ä£Ê½
 821   3            { 
 822   4              Draw_Rectangle(75,182,162,262,RED18,4);//
 823   4              Draw_Rectangle(75,58,162,136,WHITE18,4);
 824   4            }else  //ÎÞ´´Ä£Ê½
 825   3            { 
 826   4              Draw_Rectangle(75,182,162,262,WHITE18,4);
 827   4              Draw_Rectangle(75,58,162,136,RED18,4);
 828   4            }
 829   3      
 830   3          }
 831   2          else if((Key_State_Present == KEY_STATE_OK_Short)//½øÈëÔËÐÐ×´Ì¬
 832   2               ||(Key_State_Present ==KEY_STATE_OK_Long_First)
 833   2               ||(Tik_HmiNon_InvasiveSel_Tick_100mS > (u8)30))
 834   2      
 835   2          {
 836   3           LCD_LIGHT_CLOSE;    
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 15  

 837   3           Work_State = UI_STATE_RUNNING_NORMAL_MODE;
 838   3           HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);
 839   3          }
 840   2          else
 841   2          {
 842   3            //do nothing
 843   3          }
 844   2        } 
 845   1        data_flash.Work_Mode = Work_Mode;//Ñ¡¶¨µÄÄ£Ê½
 846   1      
 847   1        Setting_write_to_flash();//Ð´Èëµ½FLASH    
 848   1      
 849   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
 850   1      }
 851          
 852          
 853          //-----------ÔËÐÐ½çÃæ
 854          DISPLAY_Temp_Kind Display_Temp_Kind = DISPLAY_Temperature_Patient;     //ÏÔÊ¾ÎÂ¶ÈÀàÐÍ 0-»¼Õß¶ËÎÂ¶È 1-³öÆø¿
             -ÚÎÂ¶È
 855          
 856          void  HmiRunningFunc(void)//
 857          {
 858   1        static uint8_t Display_Return_Cnt = 0;
 859   1        if((Key_State_Present == KEY_STATE_UP_Short)//ÇÐ»»ÏÔÊ¾
 860   1          ||(Key_State_Present == KEY_STATE_UP_Long_First))
 861   1        {
 862   2          Display_Return_Cnt = 0;
 863   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 864   2          {
 865   3            Display_Temp_Kind = DISPLAY_Temperature_Chamber;
 866   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,1,BLACK18);
 867   3            Display_In_Exp_Ratio(In_Exp_Ratio,1);     
 868   3          } 
 869   2          else  
 870   2          {
 871   3            Display_Temp_Kind = DISPLAY_Temperature_Patient;
 872   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 873   3            Display_In_Exp_Ratio(In_Exp_Ratio,0);
 874   3          } 
 875   2          RefreshTempHumidyFunc(1);   
 876   2        }
 877   1        else if(Key_State_Present == KEY_STATE_Down_Long_First)//¸Ä±äÄ£Ê½
 878   1        {
 879   2          Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
 880   2          Sound_Short();    
 881   2          Set_RT_WCTemp = 340;// ÇÐ»»Ä£Ê½¼´ÎÂ¶ÈÉè¶¨»Ø¸´³ö³§Éè¶¨
 882   2          Set_RT_YCTemp = 390;//
 883   2          Set_CQK_WCTemp = 310;//
 884   2          Set_CQK_YCTemp = 360;//
 885   2      
 886   2          RT_Temp_Reach_Set_Cnt = 0;//ÈËÌå¶Ë´ïµ½ÎÂ¶È¼ÆÊýÇåÁã
 887   2          CQK_Temp_Reach_Set_Cnt = 0;
 888   2      
 889   2          if(Work_Mode==(u8)Invasive_Mode)  
 890   2          { 
 891   3            Work_Mode=Noninvasive_Mode; 
 892   3            Set_RT_Temp=(INT)Set_RT_WCTemp; 
 893   3            Set_CQK_Temp=Set_CQK_WCTemp;    
 894   3          }
 895   2          else
 896   2          {
 897   3            Work_Mode=Invasive_Mode;  
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 16  

 898   3            Set_RT_Temp=(INT)Set_RT_YCTemp;   
 899   3            Set_CQK_Temp=Set_CQK_YCTemp;        
 900   3          }
 901   2          data_flash.Set_RT_WCTemp = (uint8_t)(Set_RT_WCTemp/(u16)5);//
 902   2          data_flash.Set_RT_YCTemp = (uint8_t)(Set_RT_YCTemp/(u16)5);//
 903   2          data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/(u16)5);//
 904   2          data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/(u16)5);//
 905   2          data_flash.Work_Mode = Work_Mode;// 
 906   2          Setting_write_to_flash(); 
 907   2          Refresh_Work_Mode();//ÇÐ»»Í¼±ê        
 908   2        }
 909   1        else if(Key_State_Present == KEY_STATE_OK_Long_First)//³¤°´OK½øÈëÉè¶¨×´Ì¬
 910   1        {
 911   2          Sound_Short();
 912   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 913   2          {
 914   3            Work_State = UI_STATE_SetTempPatient_MODE;//Éè¶¨»¼Õß¶ËÎÂ¶È
 915   3            HmiEnterToWorkStateFunc(UI_STATE_SetTempPatient_MODE);  
 916   3            Remeber_Temp_Value= (uint16_t)Set_RT_Temp;
 917   3          }
 918   2          else
 919   2          {
 920   3            Work_State = UI_STATE_SetTempChamber_MODE;//Éè¶¨³öÆø¿ÚÎÂ¶È
 921   3            HmiEnterToWorkStateFunc(UI_STATE_SetTempChamber_MODE);
 922   3            Remeber_Temp_Value = Set_CQK_Temp;      
 923   3          }
 924   2        } 
 925   1        else if(Key_State_Present == KEY_STATE_Mute_Long_First)//³¤°´MUTE½øÈëÊ±¼äÉè¶¨×´Ì¬
 926   1        {
 927   2          Sound_Short();
 928   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 929   2          {
 930   3            Work_State = UI_STATE_SetTime_MODE;//Éè¶¨ÈÕÆÚºÍÊ±¼ä
 931   3            HmiEnterToWorkStateFunc(UI_STATE_SetTime_MODE); 
 932   3      
 933   3          }
 934   2        }
 935   1        else if(Key_State_Present == KEY_STATE_OK_Short)//¶Ì°´OK¼üÇåÉ«¿é±ê¼Ç
 936   1        { 
 937   2          Draw_Rectangle_Real(POS_ALARM_COL_X,POS_ALARM_COL_Y,POS_ALARM_COL_X+10,POS_ALARM_COL_Y+45,WHITE18);
 938   2          WireInOut_State_Confirm();//Õý³£ÔËÐÐ½çÃæ,°´ÏÂÈ·ÈÏ¼üÈ·¶¨»ØÂ·µÄÄ£Ê½   
 939   2        }
 940   1        else
 941   1        {
 942   2          //do nothing
 943   2        }
 944   1      
 945   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
 946   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
 947   1        {
 948   2          Display_Return_Cnt = 0;
 949   2        }
 950   1        if(Display_Return_Cnt < (u8)90)
 951   1        {
 952   2          Display_Return_Cnt++;
 953   2        }
 954   1        else
 955   1        {
 956   2          if(Display_Temp_Kind == DISPLAY_Temperature_Chamber)
 957   2          {
 958   3            Back_Color=WHITE18;
 959   3            Display_Temp_Kind = DISPLAY_Temperature_Patient;  
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 17  

 960   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 961   3            Display_In_Exp_Ratio(In_Exp_Ratio,0);
 962   3          }     
 963   2        }
 964   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
 965   1      }
 966          
 967          
 968          //-----------»¼Õß¶ËÎÂ¶ÈÉèÖÃ½çÃæ
 969          void  HmiSetTempPatientFunc(void)//GUI --- 
 970          {
 971   1        static uint8_t Set_Temp_Cnt=0; 
 972   1        static uint8_t Display_Return_Cnt = 0;
 973   1        Set_Temp_Cnt++;
 974   1        if(Set_Temp_Cnt > (u8)10)
 975   1        {
 976   2          Set_Temp_Cnt = 0;
 977   2        }
 978   1        Back_Color=WHITE18;
 979   1        if(Set_Temp_Cnt == (u8)0)
 980   1        {
 981   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
 982   2        }
 983   1        else if(Set_Temp_Cnt == (u8)5)
 984   1        {
 985   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,WHITE18);
 986   2        }
 987   1        else
 988   1        {
 989   2          //do nothing
 990   2        }
 991   1          
 992   1        
 993   1        if((Key_State_Present == KEY_STATE_UP_Short)//Ôö¼Ó
 994   1            ||(Key_State_Present == KEY_STATE_UP_Long_First)
 995   1            ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))
 996   1        { 
 997   2          if(Work_Mode==(u8)Noninvasive_Mode)
 998   2          {
 999   3            if(Remeber_Temp_Value<(u16)Const_NoninvasPatientTemp_Max)
1000   3            {
1001   4              Remeber_Temp_Value=Remeber_Temp_Value+(u16)5;
1002   4            } 
1003   3          }
1004   2          else
1005   2          {
1006   3            if(Remeber_Temp_Value<(u16)Const_InvasPatientTemp_Max)
1007   3            {
1008   4              Remeber_Temp_Value=Remeber_Temp_Value+(u16)5;
1009   4            }  
1010   3          } 
1011   2          Display_SET_Temp(Remeber_Temp_Value);       
1012   2        }
1013   1        else if((Key_State_Present == KEY_STATE_Down_Short)//¼õÐ¡
1014   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1015   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1016   1        { 
1017   2          if(Work_Mode==(u8)Noninvasive_Mode)  //ÎÞ´´
1018   2          {
1019   3            if(Remeber_Temp_Value>(u16)Const_NoninvasPatientTemp_Min)
1020   3            {
1021   4              Remeber_Temp_Value=Remeber_Temp_Value-(u16)5;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 18  

1022   4            } 
1023   3          } 
1024   2          else
1025   2          {
1026   3            if(Remeber_Temp_Value>(u16)Const_InvasPatientTemp_Min)
1027   3            {
1028   4              Remeber_Temp_Value=Remeber_Temp_Value-(u16)5;
1029   4            }
1030   3          }
1031   2          Display_SET_Temp(Remeber_Temp_Value);   
1032   2        }
1033   1        else if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1034   1        {   
1035   2          Work_State = UI_STATE_SetInExp_MODE;
1036   2          HmiEnterToWorkStateFunc(UI_STATE_SetInExp_MODE);
1037   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1038   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾ 
1039   2          Display_Return_Cnt = 0;   
1040   2        }
1041   1        else if(Key_State_Present == KEY_STATE_OK_Short)//È·ÈÏ
1042   1        {
1043   2          Sound_Short();
1044   2          if(Set_RT_Temp != (INT)Remeber_Temp_Value)//ÈôÎ´¸Ä±äÈËÌå¶ËÎÂ¶ÈÉè¶¨Ôò²»½øÐÐ²Ù×÷
1045   2          {
1046   3            Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
1047   3            Set_RT_Temp=(INT)Remeber_Temp_Value;
1048   3            if(Work_Mode == (u8)Noninvasive_Mode)
1049   3            {
1050   4              Set_RT_WCTemp=(uint16_t)Set_RT_Temp;
1051   4              data_flash.Set_RT_WCTemp = (uint8_t)(Set_RT_WCTemp/(u16)5);//ÎÞ´´Éè¶¨ÎÂ¶È 
1052   4              
1053   4              if(Set_RT_WCTemp >= (u16)320) 
1054   4              {
1055   5                Set_CQK_WCTemp = 310;//ÈËÌå¶Ë>=32Ê±³öÆø¿ÚÎÂ¶ÈÎª31
1056   5              }
1057   4              else
1058   4              {
1059   5                Set_CQK_WCTemp = 300;//ÈËÌå¶Ë>=32Ê±³öÆø¿ÚÎÂ¶ÈÎª31 
1060   5              }         
1061   4              data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/(u16)5);                           
1062   4              Set_CQK_Temp = (uint8_t)Set_CQK_WCTemp; 
1063   4            }
1064   3            else
1065   3            {
1066   4              Set_RT_YCTemp=(uint16_t)Set_RT_Temp; 
1067   4              data_flash.Set_RT_YCTemp = (uint8_t)(Set_RT_YCTemp/(u16)5);//ÓÐ´´Éè¶¨ÎÂ¶È 
1068   4              
1069   4              if(Set_RT_YCTemp >= (u16)370) 
1070   4              {
1071   5                Set_CQK_YCTemp = Set_RT_YCTemp - (u16)30;//ÈËÌå¶Ë>=37Ê±³öÆø¿ÚÎÂ¶ÈÎªRT-3
1072   5              }
1073   4              else
1074   4              {
1075   5                Set_CQK_YCTemp = 340; //ÓÐ´´³öÆø¿ÚÉè¶¨ÎÂ¶È 
1076   5              }
1077   4              data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/(u16)5);
1078   4              Set_CQK_Temp = Set_CQK_YCTemp;                          
1079   4            }
1080   3          }   
1081   2          
1082   2          Setting_write_to_flash(); 
1083   2          Display_Return_Cnt = 0;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 19  

1084   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1085   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1086   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1087   2        }
1088   1        else
1089   1        {
1090   2          //do nothing
1091   2        }
1092   1        
1093   1        
1094   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1095   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1096   1        {
1097   2          Display_Return_Cnt = 0;
1098   2        }
1099   1        if(Display_Return_Cnt < (u8)90)
1100   1        {
1101   2          Display_Return_Cnt++;
1102   2        }
1103   1        else
1104   1        {
1105   2          Display_Return_Cnt = 0;
1106   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1107   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1108   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1109   2        }
1110   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1111   1      }
1112          
1113          //-----------³öÆø¿ÚÎÂ¶ÈÉèÖÃ½çÃæ
1114          void  HmiSetTempChamberFunc(void)//GUI
1115          {
1116   1        static uint8_t Set_Temp_Cnt=0; 
1117   1        static uint8_t Display_Return_Cnt = 0;
1118   1        Set_Temp_Cnt++;
1119   1        if(Set_Temp_Cnt > (u8)10)
1120   1        {
1121   2          Set_Temp_Cnt = 0;
1122   2        }
1123   1        Back_Color=WHITE18;
1124   1        if(Set_Temp_Cnt == (u8)0)
1125   1        {
1126   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1127   2        } 
1128   1        else if(Set_Temp_Cnt == (u8)5)
1129   1        {
1130   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,WHITE18);
1131   2        }
1132   1        else
1133   1        {
1134   2          //do nothing
1135   2        }
1136   1          
1137   1        
1138   1        if((Key_State_Present == KEY_STATE_UP_Short)//Ôö¼Ó
1139   1            ||(Key_State_Present == KEY_STATE_UP_Long_First)
1140   1            ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))
1141   1        { 
1142   2          if(Work_Mode==(u8)Noninvasive_Mode)//ÎÞ´´
1143   2          {//³öÆø¿ÚÎÂ¶È×î´ó32¶È
1144   3            if(Remeber_Temp_Value<(uint16_t)Const_NoninvasChamberTemp_Max)
1145   3            {
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 20  

1146   4              Remeber_Temp_Value=Remeber_Temp_Value+(u16)5;
1147   4            } 
1148   3          }
1149   2          else if(Work_Mode==(uint8_t)Invasive_Mode)
1150   2          {//³öÆø¿ÚºÍ»¼Õß¶ËÎÂ¶È²îÎª-4/+3
1151   3            if((Remeber_Temp_Value<(u16)Const_InvasChamberTemp_Max)&&(Remeber_Temp_Value<((uint16_t)Set_RT_Temp+(u1
             -6)30)))
1152   3            {
1153   4              Remeber_Temp_Value=Remeber_Temp_Value+(u16)5;
1154   4            }
1155   3          } 
1156   2          else
1157   2          {
1158   3            //do nothing
1159   3          }
1160   2          Display_SET_Temp(Remeber_Temp_Value);       
1161   2        }
1162   1        else if((Key_State_Present == KEY_STATE_Down_Short)//¼õÐ¡
1163   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1164   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1165   1        { 
1166   2          if(Work_Mode==(u8)Noninvasive_Mode)  //ÎÞ´´
1167   2          {//×îÐ¡30¶È
1168   3            if(Remeber_Temp_Value>(u16)Const_NoninvasChamberTemp_Min)
1169   3            {
1170   4              Remeber_Temp_Value=Remeber_Temp_Value-(u16)5;
1171   4            } 
1172   3          } 
1173   2          else if(Work_Mode==(u8)Invasive_Mode) //ÓÐ´´ ³öÆø¿ÚºÍ»¼Õß¶ËÎÂ¶È²îÎª-4/+3 //×îÐ¡34¶È
1174   2          {
1175   3            if((Remeber_Temp_Value>(u16)Const_InvasChamberTemp_Min)&&(Remeber_Temp_Value>((uint16_t)Set_RT_Temp-(u1
             -6)40)))
1176   3            {
1177   4              Remeber_Temp_Value=Remeber_Temp_Value-(u16)5;
1178   4            }
1179   3          } 
1180   2          else
1181   2          {
1182   3            //do nothing
1183   3          }
1184   2          Display_SET_Temp(Remeber_Temp_Value);   
1185   2        }
1186   1        else if(Key_State_Present == KEY_STATE_OK_Short)//È·ÈÏ
1187   1        {
1188   2          Sound_Short();
1189   2          if(Set_CQK_Temp != Remeber_Temp_Value)//ÈôÎ´¸Ä±äÈËÌå¶ËÎÂ¶ÈÉè¶¨Ôò²»½øÐÐ²Ù×÷
1190   2          {
1191   3            Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
1192   3            Set_CQK_Temp=Remeber_Temp_Value;
1193   3            if(Work_Mode==(u8)Noninvasive_Mode)
1194   3            {
1195   4              Set_CQK_WCTemp=Set_CQK_Temp;
1196   4              data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/(u16)5);//ÎÞ´´Éè¶¨ÎÂ¶È                                     
1197   4            }
1198   3            else
1199   3            {
1200   4              Set_CQK_YCTemp=Set_CQK_Temp; 
1201   4              data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/(u16)5);//ÓÐ´´Éè¶¨ÎÂ¶È                                           
1202   4            } 
1203   3            
1204   3            Display_Return_Cnt = 0;
1205   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 21  

1206   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1207   3            RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾ 
1208   3          }   
1209   2        }
1210   1        else
1211   1        {
1212   2          //do nothing
1213   2        }
1214   1        
1215   1        Setting_write_to_flash(); 
1216   1          
1217   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1218   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1219   1        {
1220   2          Display_Return_Cnt = 0;
1221   2        }
1222   1        if(Display_Return_Cnt < (u8)90)
1223   1        {
1224   2          Display_Return_Cnt++;
1225   2        }
1226   1        else
1227   1        {
1228   2          Display_Return_Cnt = 0;
1229   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1230   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1231   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1232   2        }
1233   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1234   1      }
1235          
1236          
1237          static uint8_t SetTimeKind = 2;//2-7//Äê/ÔÂ/ÈÕ/Ê±/·Ö/Ãë
1238          static uint8_t TempTime[7];
1239          
1240          static void EnterSetTime(void)//½øÈëÊ±¼äÉè¶¨
1241          {
1242   1        SetTimeKind = 2;
1243   1        RX8010_GetTime(TempTime); 
1244   1      //  Set_Hour_Value
1245   1      }
1246          
1247          static void  Date_Is_Correct(void)
1248          {
1249   1        uint16_t temp1;
1250   1        u8  Temp_Bit1;
1251   1        //½«BCDÂë×ª»¯Îª10½øÖÆ,Éè¶¨Ê±¼ä´Ó2000Äêµ½2099Äê======================================
1252   1        Temp_Bit1=(u8)0;
1253   1        temp1=(((u16)TempTime[6]& (u16)0x0F)%(u16)10)+ ((((u16)TempTime[6]>>(u16)4)%(u16)10)*(u16)10);
1254   1        //ÄÜ±»4Õû³ý£¬µ«ÊÇ²»ÄÜ±»100Õû³ýÎªÈòÄê£¬»òÕßÄÜ±»400Õû³ý=====
1255   1        if((temp1%(u8)4)==(u8)0 )
1256   1        {
1257   2          Temp_Bit1=1;
1258   2        } 
1259   1        if((TempTime[4]==(u8)0x04) || (TempTime[4]==(u8)0x06) || (TempTime[4]==(u8)0x09) || (TempTime[4]==(u8)0x1
             -1))
1260   1        {
1261   2          if(TempTime[3]>(u8)0x30) 
1262   2          {
1263   3            TempTime[3]=0x30;
1264   3          }
1265   2        }
1266   1        if(Temp_Bit1!=(u8)0) //ÈòÄê29Ìì£¬Æ½Äê28Ìì
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 22  

1267   1        {
1268   2          if(TempTime[4]==(u8)2)
1269   2          {
1270   3            if(TempTime[3]>(u8)0x29)
1271   3            {
1272   4              TempTime[3]=0x29;
1273   4            }       
1274   3          }
1275   2        }else
1276   1        {
1277   2          if(TempTime[4]==(u8)2)
1278   2          {
1279   3            if(TempTime[3]>(u8)0x28)
1280   3            {
1281   4              TempTime[3]=0x28;
1282   4            }       
1283   3          }
1284   2        } 
1285   1      }
1286          
1287          //-----------ÈÕÆÚÊ±¼äÉèÖÃ½çÃæ
1288          void  HmiSetTimeFunc(void)
1289          {
1290   1        static uint8_t Display_Return_Cnt = 0;
1291   1        static uint8_t Set_Time_Cnt=0; 
1292   1      //  uint8_t i;
1293   1      //  uint8_t color;
1294   1        
1295   1        Set_Time_Cnt++;
1296   1        if(Set_Time_Cnt > (u8)6)
1297   1        {
1298   2          Set_Time_Cnt = 0;
1299   2        }
1300   1        
1301   1        if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1302   1        {
1303   2          SetTimeKind++;
1304   2          
1305   2          Back_Color=WHITE18; 
1306   2      //    color=BLACK18;    
1307   2          DisPlayTime(TempTime,2); //ÏÔÊ¾Ê±¼ä
1308   2          DisPlayTime(TempTime,3); //ÏÔÊ¾Ê±¼ä
1309   2          DisPlayTime(TempTime,4); //ÏÔÊ¾Ê±¼ä
1310   2          DisPlayTime(TempTime,5); //ÏÔÊ¾Ê±¼ä
1311   2          DisPlayTime(TempTime,6); //ÏÔÊ¾Ê±¼ä
1312   2          DisPlayTime(TempTime,7); //ÏÔÊ¾Ê±¼ä
1313   2          
1314   2          if(SetTimeKind > (u8)7)
1315   2          {
1316   3            SetTimeKind = 2;
1317   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1318   3          }   
1319   2        } 
1320   1        else if((Key_State_Present == KEY_STATE_UP_Short)//UP
1321   1                ||(Key_State_Present == KEY_STATE_UP_Long_First)
1322   1                ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))  
1323   1        {
1324   2          Set_Time_Cnt = 0;//Ç¿ÖÆË¢ÐÂ
1325   2          if(SetTimeKind==(u8)2) //Éè¶¨Äê·Ý
1326   2          {
1327   3            TempTime[6]++;
1328   3            if((TempTime[6]&(uint8_t)0x0F)>=(u8)10)
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 23  

1329   3            {
1330   4                 TempTime[6]=(TempTime[6]& (uint8_t)0xF0)+(u8)0x10;;
1331   4            }
1332   3            if(TempTime[6]>(u8)0x99)
1333   3            {
1334   4                  TempTime[6]=0x99;
1335   4            }
1336   3            Date_Is_Correct();            
1337   3      
1338   3          }else if(SetTimeKind==(u8)3) //Éè¶¨ÔÂ·Ý
1339   2          {
1340   3            TempTime[4]++;
1341   3            if((TempTime[4]&(uint8_t)0x0F)>=(u8)10)
1342   3            {
1343   4                 TempTime[4]=(TempTime[4]& (uint8_t)0xF0)+(u8)0x10;
1344   4            }
1345   3            if(TempTime[4]>(u8)0x12)
1346   3            {
1347   4                  TempTime[4]=0x12;
1348   4            }
1349   3            Date_Is_Correct();
1350   3          }else if(SetTimeKind==(u8)4) //Éè¶¨ÈÕ
1351   2          {
1352   3            TempTime[3]++;
1353   3            if((TempTime[3]&(uint8_t)0x0F)>=(u8)10)
1354   3            {
1355   4                 TempTime[3]=(TempTime[3]& (uint8_t)0xF0)+(u8)0x10;
1356   4            }
1357   3            if(TempTime[3]>(u8)0x31)
1358   3            {
1359   4                  TempTime[3]=0x31;
1360   4            }
1361   3            Date_Is_Correct();  
1362   3          }else if(SetTimeKind==(u8)5) //Éè¶¨Ê±
1363   2          {
1364   3            {
1365   4              TempTime[2]++;                
1366   4              if((TempTime[2]&(uint8_t)0x0F)>=(u8)10)
1367   4              {
1368   5                   TempTime[2]=(TempTime[2] & (uint8_t)0xF0)+(u8)0x10;
1369   5              }
1370   4              if(TempTime[2]>(u8)0x23)
1371   4              {
1372   5                    TempTime[2]=0x23; 
1373   5              }
1374   4            }             
1375   3          }else if(SetTimeKind==(u8)6) //Éè¶¨·Ö
1376   2          {
1377   3            TempTime[1]++;
1378   3            if((TempTime[1]&(uint8_t)0x0F)>=(u8)10)
1379   3            {
1380   4                 TempTime[1]=(TempTime[1]& (uint8_t)0xF0)+(u8)0x10;
1381   4            }
1382   3            if(TempTime[1]>(u8)0x59)
1383   3            {
1384   4                  TempTime[1]=0x59;
1385   4            }
1386   3          }else if(SetTimeKind==(u8)7) //Éè¶¨Ãë
1387   2          {
1388   3            TempTime[0]++;
1389   3            if((TempTime[0]&(uint8_t)0x0F)>=(u8)10)
1390   3            {
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 24  

1391   4                 TempTime[0]=(TempTime[0]& (uint8_t)0xF0)+(u8)0x10;
1392   4            }
1393   3            if(TempTime[0]>(u8)0x59)
1394   3            {
1395   4                  TempTime[0]=0x59;
1396   4            }
1397   3          }
1398   2          else
1399   2          {
1400   3            //do nothing
1401   3          }
1402   2        }
1403   1        else if((Key_State_Present == KEY_STATE_Down_Short)//
1404   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1405   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1406   1        {
1407   2          Set_Time_Cnt = 0;//Ç¿ÖÆË¢ÐÂ
1408   2          if((SetTimeKind==(u8)2) && (TempTime[6]>(u8)0x10)) //Éè¶¨Äê·Ý
1409   2          {
1410   3            TempTime[6]--;
1411   3            if((TempTime[6]&(uint8_t)0x0F)>(u8)9)
1412   3            {
1413   4              TempTime[6]&=(uint8_t)0xF9;
1414   4            }       
1415   3            Date_Is_Correct();  
1416   3          }else if((SetTimeKind==(u8)3) && (TempTime[4]>(u8)1)) //Éè¶¨ÔÂ·Ý
1417   2          {
1418   3            TempTime[4]--;
1419   3            if((TempTime[4]&(uint8_t)0x0F)>(u8)9)
1420   3            {
1421   4              TempTime[4]&=(uint8_t)0xF9;
1422   4            }       
1423   3            Date_Is_Correct();  
1424   3          }else if((SetTimeKind==(u8)4) && (TempTime[3]>(u8)1)) //Éè¶¨ÈÕ
1425   2          {
1426   3            TempTime[3]--;
1427   3            if((TempTime[3]&(uint8_t)0x0F)>(u8)9)
1428   3            {
1429   4              TempTime[3]&=(uint8_t)0xF9;
1430   4            }       
1431   3          }else if((SetTimeKind==(u8)5) && (TempTime[2]>(u8)0))  //Éè¶¨Ê±
1432   2          { 
1433   3            {
1434   4              TempTime[2]--;
1435   4              if((TempTime[2]&(uint8_t)0x0F)>(u8)9)
1436   4              {
1437   5                TempTime[2]&=(uint8_t)0xF9;
1438   5              }           
1439   4            }
1440   3          }else if((SetTimeKind==(u8)6)  && (TempTime[1]>(u8)0)) //Éè¶¨·Ö
1441   2          {
1442   3            TempTime[1]--;
1443   3            if((TempTime[1]&(uint8_t)0x0F)>(u8)9)
1444   3            {
1445   4              TempTime[1]&=(uint8_t)0xF9;
1446   4            }       
1447   3          }else if((SetTimeKind==(u8)7) && (TempTime[0]>(u8)0)) //Éè¶¨Ãë
1448   2          {
1449   3            TempTime[0]--;
1450   3            if((TempTime[0]&(uint8_t)0x0F)>(u8)9)
1451   3            {
1452   4              TempTime[0]&=(uint8_t)0xF9;
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 25  

1453   4            }       
1454   3          }
1455   2          else
1456   2          {
1457   3            //do nothing
1458   3          }
1459   2        } 
1460   1        else if(Key_State_Present == KEY_STATE_OK_Short)//
1461   1        {
1462   2          Sound_Short();
1463   2          RX8010_SetTime(TempTime);   
1464   2          Display_Return_Cnt = 0;
1465   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;    
1466   2        } 
1467   1        else
1468   1        {
1469   2          //do nothing
1470   2        }
1471   1        
1472   1      //  color = BLACK18;
1473   1        if(Set_Time_Cnt == (u8)0)
1474   1        {
1475   2          Back_Color=GREEN18;
1476   2        }
1477   1        else if(Set_Time_Cnt == (u8)3)
1478   1        {
1479   2          Back_Color=WHITE18; 
1480   2        }
1481   1        else
1482   1        {
1483   2          //do nothing
1484   2        }
1485   1            
1486   1        
1487   1        if((Set_Time_Cnt == (u8)0) ||(Set_Time_Cnt == (u8)3))
1488   1        {
1489   2          DisPlayTime(TempTime,SetTimeKind); //ÏÔÊ¾Ê±¼ä
1490   2         }
1491   1          
1492   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1493   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1494   1        {
1495   2          Display_Return_Cnt = 0;
1496   2        }
1497   1        if(Display_Return_Cnt < (u8)90)
1498   1        {
1499   2          Display_Return_Cnt++;
1500   2        }
1501   1        else
1502   1        {
1503   2          Display_Return_Cnt = 0;
1504   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1505   2      //    DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+34*3+5,ICO_DU,BLACK18);
1506   2      //    RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1507   2        }
1508   1        
1509   1          
1510   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü    
1511   1      }
1512          
1513          
1514          //uint8_t  In_Exp_Ratio=4;   //InºÍExp¼ÓÈÈ·½Ê½µÄ±ÈÀý  //1-1:1 2-1:1.1 3-1:1.2 4-1:1.3 5-1:1.4 6-1:1.5
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 26  

1515          static uint8_t  In_Exp_Ratio_temp=3;   //InºÍExp¼ÓÈÈ·½Ê½µÄ±ÈÀýÁÙÊ±±äÁ¿
1516          static void EnterSetInExp(void)//½øÈëInExpÉè¶¨
1517          { 
1518   1        In_Exp_Ratio_temp = In_Exp_Ratio; 
1519   1        Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);  
1520   1      }
1521          
1522          void  HmiSetInExpFunc(void)//InExpÉèÖÃ½çÃæ
1523          {
1524   1        static uint8_t Display_Return_Cnt = 0;
1525   1        static uint8_t Set_InExp_Cnt=0; 
1526   1        
1527   1        Set_InExp_Cnt++;
1528   1        if(Set_InExp_Cnt > (u8)6)
1529   1        {
1530   2          Set_InExp_Cnt = 0;
1531   2        }
1532   1        Back_Color=WHITE18;
1533   1        if(Set_InExp_Cnt == (u8)0)
1534   1        {
1535   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+120,16,200,(const u8*)"In/Exp:",0,BLACK18);
1536   2        } 
1537   1        else if(Set_InExp_Cnt == (u8)3)
1538   1        {
1539   2          LCD_ShowString(POS_RT_RH_X ,POS_RT_RH_Y+120,16,200,(const u8*)"In/Exp:",0,WHITE18); 
1540   2        }
1541   1        else
1542   1        {
1543   2          //do nothing
1544   2        }
1545   1            
1546   1        
1547   1        if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1548   1        {
1549   2          Work_State = UI_STATE_SetTempPatient_MODE;
1550   2          HmiEnterToWorkStateFunc(UI_STATE_SetTempPatient_MODE);
1551   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,0);    
1552   2        }
1553   1        else if(Key_State_Present == KEY_STATE_UP_Short)//UP
1554   1        {
1555   2          if(In_Exp_Ratio_temp < (u8)6)
1556   2          {
1557   3            In_Exp_Ratio_temp++;          
1558   3          }
1559   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);
1560   2        } 
1561   1        else if(Key_State_Present == KEY_STATE_Down_Short)//DOWN
1562   1        {
1563   2          if(In_Exp_Ratio_temp > (u8)1)
1564   2          {
1565   3            In_Exp_Ratio_temp--;
1566   3          }
1567   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);
1568   2        }
1569   1        else if(Key_State_Present == KEY_STATE_OK_Short)//OK
1570   1        {
1571   2          Sound_Short();
1572   2          In_Exp_Ratio = In_Exp_Ratio_temp;
1573   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1574   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,0);  
1575   2          data_flash.In_Exp_Ratio = In_Exp_Ratio;// 
1576   2          Setting_write_to_flash();     
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 27  

1577   2        } 
1578   1        else
1579   1        {
1580   2          //do nothing
1581   2        }
1582   1        
1583   1        //  Setting_write_to_flash(); 
1584   1          //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1585   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1586   1        {
1587   2          Display_Return_Cnt = 0;
1588   2        }
1589   1        if(Display_Return_Cnt < (u8)90)
1590   1        {
1591   2          Display_Return_Cnt++;
1592   2        }
1593   1        else
1594   1        {
1595   2          Display_Return_Cnt = 0;
1596   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1597   2          Display_In_Exp_Ratio(In_Exp_Ratio,0);   
1598   2        } 
1599   1        
1600   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü    
1601   1      }
1602          
1603          
1604          //--------ÆÁ±£Ä£Ê½
1605          //¼ÆÊ±º¯Êý,·ÅÈëÖÐ¶Ï
1606          void HmiScreenSaverMode_Tik_Cnt(void)
1607          {
1608   1        if(Tik_ScreenSaver_Tick_100mS < (u16)30000)
1609   1        {
1610   2          Tik_ScreenSaver_Tick_100mS++;
1611   2        }
1612   1      }
1613          
1614          void  HmiScreenSaverModeFunc(void)
1615          {
1616   1        uint16_t i=0;
1617   1        uint8_t DispEnable = 0;
1618   1        static uint8_t ReCnt=0;
1619   1        
1620   1      //  DispEnable = 0;
1621   1        ReCnt++;
1622   1        if(ReCnt > (u8)10)//1S
1623   1        {
1624   2          ReCnt = 0;  
1625   2          if(Work_State == UI_STATE_SCREENSAVER_MODE)
1626   2          {
1627   3            DispEnable = 1; 
1628   3          }
1629   2        }   
1630   1        
1631   1        if(Work_State != UI_STATE_SCREENSAVER_MODE)//²»ÔÚÆÁ±£Ä£Ê½
1632   1        {
1633   2          if(Tik_ScreenSaver_Tick_100mS > (u16)3000)//5·ÖÖÓºó½øÈëÆÁ±£Ä£Ê½
1634   2          {
1635   3            Work_State = UI_STATE_SCREENSAVER_MODE;
1636   3            LCD_LIGHT_CLOSE;
1637   3            Draw_Rectangle_Real(0,0,239,319,BLACK18);           
1638   3            DispEnable = 1; 
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 28  

1639   3          }
1640   2        }
1641   1        else//ÔÚÆÁ±£Ä£Ê½
1642   1        {   
1643   2          //do nothing
1644   2        } 
1645   1        
1646   1        if(((uint16_t)Key_State_Present!=(uint16_t)0)//°´ÏÂ°´¼ü
1647   1        //»ò³öÏÖ´íÎó
1648   1              ||((ERR_Kind)!=(u8)0) //ÎÞË®,´«¸ÐÆ÷´íÎó,¸ßÎÂµÈ´íÎó
1649   1              ||(Wire_Mode_Mismatch == (uint8_t)1)  //·¢ÈÈË¿Î´Ñ¡¶¨
1650   1              ||(HeaterPlate_State==(u8)0))//Ë®¹ÞÎ´×°ºÃ»ò·¢ÈÈÅÌ¿ªÂ·
1651   1        {
1652   2          Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1653   2          Tik_ScreenSaver_Tick_100mS = 0;
1654   2          DispEnable = 0;
1655   2          
1656   2          if(Work_State == UI_STATE_SCREENSAVER_MODE)//ÔÚÆÁ±£Ä£Ê½
1657   2          {
1658   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1659   3            HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);  
1660   3            Err_Base_HeaterWire_DISP_Enable();//ÆÁ±£Ê±ÖÃÏà¹Ø±êÖ¾,ÒÔ±ãÁÁÆÁÊ±ÏÔÊ¾Ö÷»úºÍÏßµÄÍ¼ÐÎ
1661   3          }
1662   2        }   
1663   1          
1664   1        if(DispEnable!=(uint8_t)0)
1665   1        {
1666   2      //    DispEnable = 0;   
1667   2          Back_Color=BLACK18;
1668   2          i=Diplay_RTtemp;
1669   2          if(i>=(u16)1000)//ÏÔÊ¾ÎÂ¶È
1670   2          {
1671   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X,(u8)((i/(u16)1000)%(u16)10),GREEN18);  
1672   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X+42,(u8)((i/(u16)1000)%(u16)10),GREEN18); 
1673   3            Draw_Rectangle_Real(POS_SCREEN_Y,POS_SCREEN_X+82,POS_SCREEN_Y+8,POS_SCREEN_X +88,BLACK18);       
1674   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X +90,(u8)((i/(u16)1000)%(u16)10),GREEN18);    
1675   3            DISP_ICO_32X40(POS_SCREEN_Y,POS_SCREEN_X +133,ICO_DU,GREEN18);  
1676   3          }
1677   2          else
1678   2          {
1679   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X,(u8)((i/(u16)100)%(u16)10),GREEN18);  
1680   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X+42,(u8)((i%(u16)100)/(u16)10),GREEN18); 
1681   3            Draw_Rectangle_Real(POS_SCREEN_Y,POS_SCREEN_X+82,POS_SCREEN_Y+8,POS_SCREEN_X +88,GREEN18);       
1682   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X +90,(u8)(i%(u16)10),GREEN18);    
1683   3            DISP_ICO_32X40(POS_SCREEN_Y,POS_SCREEN_X +133,ICO_DU,GREEN18);             
1684   3          } 
1685   2          LCD_LIGHT_OPEN;  
1686   2        }
1687   1      }
1688          
1689          
1690          
1691          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9869    ----
   CONSTANT SIZE    =    659    ----
   XDATA SIZE       =     33     149
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   GUI                                                               04/19/2019 09:37:29 PAGE 29  

   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
