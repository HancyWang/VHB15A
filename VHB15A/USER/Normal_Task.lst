C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE NORMAL_TASK
OBJECT MODULE PLACED IN ..\OBJ\Normal_Task.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\CODE\Normal_Task.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER N
                    -OAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sh
                    -t31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\Normal_Task.lst) TABS(2) OBJE
                    -CT(..\OBJ\Normal_Task.obj)

line level    source

   1          #include "all.h"
   2          
   3          //2019.03.30
   4          sbit P20 = (uint8_t)0xA0^(uint8_t)0;
   5          sbit P21 = (uint8_t)0xA0^(uint8_t)1;
   6          sbit P22 = (uint8_t)0xA0^(uint8_t)2;
   7          sbit P23 = (uint8_t)0xA0^(uint8_t)3;
   8          
   9          WORK_STATUS Work_State = UI_STATE_POWER_OFF_MODE;//工作状态定义
  10          
  11          void ManageTask(void)//Task0:Task Manager ----20mS
  12          {
  13   1          static uint8_t Manage_Tik_100mS_Cnt = 0;
  14   1          static uint8_t Manage_Tik_250mS_Cnt = 0;
  15   1          static uint8_t Manage_Tik_1000mS_Cnt = 0;        
  16   1                   
  17   1          WS_TaskState = ManageTIFG;
  18   1          if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)   
  19   1          { 
  20   2              WS_DelTaskIfg(WS_TaskState); 
  21   2              {         
  22   3                //20mS任务
  23   3                WS_SetTaskIfg(KeyScanTIFG);//按键扫描任务 20mS          
  24   3                WS_SetTaskIfg(UartRecTIFG);//串口接收进程
  25   3                
  26   3                if(Work_State != UI_STATE_DATAREADER_MODE)//数据传输界面屏蔽以下任务
  27   3                {         
  28   4                  if(Work_State != UI_STATE_POWER_OFF_MODE)
  29   4                  {         
  30   5                    WS_SetTaskIfg(GetTemp_HpChamberTIFG);      //读取加热盘盘和出气口的温度 20mS
  31   5                    WS_SetTaskIfg(GetTempHumidity_PatientTIFG); //读取患者端温度和温度 20mS
  32   5                  }         
  33   4                  //100mS任务
  34   4                  Manage_Tik_100mS_Cnt++;
  35   4                  if(Manage_Tik_100mS_Cnt >= 5)//
  36   4                  {
  37   5                    Manage_Tik_100mS_Cnt = 0;
  38   5        //            time_test_lcd_backlight();
  39   5                    if(Work_State == UI_STATE_SERVICE_MODE)
  40   5                    {         
  41   6                      WS_SetTaskIfg(HmiServiceModeTIFG);//服务模式
  42   6                    }
  43   5                    else if(Work_State == UI_STATE_POST_MODE)
  44   5                    {
  45   6                      WS_SetTaskIfg(HmiPostTIFG);//开机自检
  46   6                    }         
  47   5                    else if(Work_State == UI_STATE_FACTORY_DEFAULT_SEL_MODE)
  48   5                    {
  49   6                      WS_SetTaskIfg(HmiFactoryDefaultSelTIFG);//开机选择功能
  50   6                    }
  51   5                    else if(Work_State == UI_STATE_NON_INVASIVE_MODE)
  52   5                    {
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 2   

  53   6                      WS_SetTaskIfg(HmiNon_InvasiveSelTIFG);//开机有创无创选择
  54   6                    }
  55   5                    else if(Work_State == UI_STATE_RUNNING_NORMAL_MODE)
  56   5                    {
  57   6                      WS_SetTaskIfg(HmiRunningTIFG);//正常运行状态
  58   6                    }
  59   5                    else if(Work_State == UI_STATE_SetTempPatient_MODE)
  60   5                    {
  61   6                      WS_SetTaskIfg(HmiSetTempPatientTIFG);//患者端温度设定
  62   6                    }
  63   5                    else if(Work_State == UI_STATE_SetTempChamber_MODE)
  64   5                    {
  65   6                      WS_SetTaskIfg(HmiSetTempChamberTIFG);//出气口温度设定
  66   6                    }
  67   5                    else if(Work_State == UI_STATE_SetInExp_MODE)
  68   5                    {
  69   6                      WS_SetTaskIfg(HmiSetInExpTIFG);//InExp设定
  70   6                    }
  71   5                    else if(Work_State == UI_STATE_SetTime_MODE)
  72   5                    {
  73   6                      WS_SetTaskIfg(HmiSetTimeTIFG);//时间设定
  74   6                    }
  75   5                    else
  76   5                    {
  77   6                      //do nothing
  78   6                    }             
  79   5                    
  80   5                    if((Work_State != UI_STATE_POWER_OFF_MODE)
  81   5                      &&(Work_State != UI_STATE_POST_MODE)
  82   5                      &&(Work_State != UI_STATE_FACTORY_DEFAULT_SEL_MODE)
  83   5                      &&(Work_State != UI_STATE_NON_INVASIVE_MODE)  
  84   5                      &&(Work_State != UI_STATE_SERVICE_MODE))//除以上模式外          
  85   5                    {
  86   6                      WS_SetTaskIfg(HmiScreenSaverModeTIFG);//屏保模式 
  87   6                    }
  88   5      
  89   5                    
  90   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
  91   5                      ||(Work_State == UI_STATE_SetTempPatient_MODE)
  92   5                      ||(Work_State == UI_STATE_SetTempChamber_MODE)
  93   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
  94   5                      ||(Work_State == UI_STATE_SetTime_MODE))
  95   5                    { 
  96   6                      if((Work_State != UI_STATE_SetTime_MODE)//设定时间时不刷新实时RTC时间 
  97   6                        &&(Work_State != UI_STATE_SCREENSAVER_MODE))
  98   6                      {
  99   7                        WS_SetTaskIfg(RefreshRTCTimeTIFG);//刷新RTC时间     
 100   7                      }               
 101   6                    }
 102   5                  }
 103   4                  
 104   4                  //240mS任务
 105   4                  Manage_Tik_250mS_Cnt++;
 106   4                  if(Manage_Tik_250mS_Cnt >= 12)//
 107   4                  {
 108   5                    Manage_Tik_250mS_Cnt = 0;
 109   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
 110   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
 111   5                      ||(Work_State == UI_STATE_SetTime_MODE))
 112   5                    {
 113   6                      if((Work_State != UI_STATE_SetTempPatient_MODE)
 114   6                        &&(Work_State != UI_STATE_SetTempChamber_MODE))
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 3   

 115   6                      {   
 116   7                        WS_SetTaskIfg(RefreshTempHumidyTIFG);//刷新实时温度和湿度
 117   7                      }
 118   6                    }
 119   5                    
 120   5                    if((Work_State != UI_STATE_POWER_OFF_MODE)
 121   5                      &&(Work_State != UI_STATE_POST_MODE)
 122   5                      &&(Work_State != UI_STATE_FACTORY_DEFAULT_SEL_MODE)
 123   5                      &&(Work_State != UI_STATE_NON_INVASIVE_MODE)
 124   5                      &&(Work_State != UI_STATE_SERVICE_MODE))//除以上模式外                  
 125   5                    {
 126   6                      WS_SetTaskIfg(AlarmErrorTIFG);//报警和错误事件处理,错误事件刷新 
 127   6                    }
 128   5                  }
 129   4                            
 130   4                  //1000mS任务
 131   4                  Manage_Tik_1000mS_Cnt++;
 132   4                  if(Manage_Tik_1000mS_Cnt >= 50)//
 133   4                  {
 134   5                    Manage_Tik_1000mS_Cnt = 0;
 135   5                    if((Work_State == UI_STATE_RUNNING_NORMAL_MODE)
 136   5                      ||(Work_State == UI_STATE_SCREENSAVER_MODE)
 137   5                      ||(Work_State == UI_STATE_SetTempPatient_MODE)
 138   5                      ||(Work_State == UI_STATE_SetTempChamber_MODE)
 139   5                      ||(Work_State == UI_STATE_SetInExp_MODE)
 140   5                      ||(Work_State == UI_STATE_SetTime_MODE))
 141   5                    {             
 142   6                      WS_SetTaskIfg(HeaterWireModeDetTIFG); //加热线状态检测 1S
 143   6                      WS_SetTaskIfg(HeaterPlateWireControlTIFG);//回路加热线温度的控制 1S(仅运算，驱动在定时中断)
 144   6                      WS_SetTaskIfg(LowPowerModeTIFG);//低功率模式 1S
 145   6                      WS_SetTaskIfg(SaveDateToFlashTIFG);//保存数据到FLASH 1S 
 146   6                      WS_SetTaskIfg(LowTempDet1STIFG);//低温低湿检测1S
 147   6                      WS_SetTaskIfg(RefreshRunTimeTIFG);//刷新运行时间 1S
 148   6                    }             
 149   5                  }         
 150   4                } 
 151   3              }          
 152   2          }
 153   1      }
 154          
 155          KEY_STATUS KeyToFuncVal = KEY_STATE_ReleaseValue; 
 156          void KeyScanTask(void) //1
 157          {
 158   1          BitStatus bit_status;
 159   1          WS_TaskState = KeyScanTIFG;
 160   1          if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 161   1          {   
 162   2              WS_DelTaskIfg(WS_TaskState);
 163   2              {
 164   3                bit_status = KEY_LEFT_UP_IN;//UP
 165   3                if((INT)bit_status == (INT)RESET)
 166   3                {
 167   4                  KeyToFuncVal = KEY_STATE_PressValue;     
 168   4                }
 169   3                else
 170   3                {
 171   4                  KeyToFuncVal = KEY_STATE_ReleaseValue;
 172   4                }
 173   3                Key_Multifun(Key_UP_Element,&Key_UP);
 174   3                
 175   3                bit_status = KEY_LEFT_DOWN_IN;//DOWN
 176   3                if((INT)bit_status == (INT)RESET)
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 4   

 177   3                {
 178   4                  KeyToFuncVal = KEY_STATE_PressValue;     
 179   4                }
 180   3                else
 181   3                {
 182   4                  KeyToFuncVal = KEY_STATE_ReleaseValue; 
 183   4                }
 184   3                  
 185   3                Key_Multifun(Key_Down_Element,&Key_Down);
 186   3                
 187   3                bit_status = KEY_RIGHT_UP_IN;//OK
 188   3                if((INT)bit_status == (INT)RESET)
 189   3                {
 190   4                  KeyToFuncVal = KEY_STATE_PressValue;     
 191   4                }
 192   3                else
 193   3                {
 194   4                  KeyToFuncVal = KEY_STATE_ReleaseValue; 
 195   4                }
 196   3                  
 197   3                Key_Multifun(Key_OK_Element,&Key_OK);
 198   3                
 199   3                bit_status = KEY_RIGHT_DOWN_IN;//MUTE
 200   3                if((INT)bit_status == (INT)RESET)
 201   3                {
 202   4                  KeyToFuncVal = KEY_STATE_PressValue;        
 203   4                }
 204   3                else
 205   3                {
 206   4                  KeyToFuncVal = KEY_STATE_ReleaseValue; 
 207   4                }
 208   3                  
 209   3                Key_Multifun(Key_Mute_Element,&Key_Mute);         
 210   3              }
 211   2          }
 212   1      }
 213          
 214          void HmiServiceModeTask(void)//2
 215          {
 216   1        WS_TaskState = HmiServiceModeTIFG;
 217   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 218   1        {   
 219   2          WS_DelTaskIfg(WS_TaskState);
 220   2          {
 221   3            HmiServiceModeFunc();
 222   3          }
 223   2        }
 224   1      }
 225          
 226          void HmiPostTask(void)//3
 227          {
 228   1        WS_TaskState = HmiPostTIFG;
 229   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 230   1        {   
 231   2          WS_DelTaskIfg(WS_TaskState);
 232   2          {
 233   3            HmiPostFunc();
 234   3          }
 235   2        }
 236   1      }
 237          
 238          void HmiFactoryDefaultSelTask(void)//4
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 5   

 239          {
 240   1        WS_TaskState = HmiFactoryDefaultSelTIFG;
 241   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 242   1        {   
 243   2          WS_DelTaskIfg(WS_TaskState);
 244   2          {
 245   3            HmiFactoryDefaultFunc();
 246   3      //      time_test_lcd_backlight();
 247   3          }
 248   2        }
 249   1      }
 250          
 251          void HmiNon_InvasiveSelTask(void)//5
 252          {
 253   1        WS_TaskState = HmiNon_InvasiveSelTIFG;
 254   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 255   1        {   
 256   2          WS_DelTaskIfg(WS_TaskState);
 257   2          {
 258   3            HmiNon_InvasiveSelFunc();
 259   3          }
 260   2        } 
 261   1      }
 262          
 263          void HmiRunningTask(void)//6
 264          {
 265   1        WS_TaskState = HmiRunningTIFG;
 266   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 267   1        {   
 268   2          WS_DelTaskIfg(WS_TaskState);
 269   2          {
 270   3            HmiRunningFunc();
 271   3          }
 272   2        }   
 273   1      }
 274          
 275          void HmiSetTempPatientTask(void)//7
 276          {
 277   1        WS_TaskState = HmiSetTempPatientTIFG;
 278   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 279   1        {   
 280   2          WS_DelTaskIfg(WS_TaskState);
 281   2          {
 282   3            HmiSetTempPatientFunc();
 283   3          }
 284   2        } 
 285   1      }
 286          
 287          void HmiSetTempChamberTask(void)//8
 288          {
 289   1        WS_TaskState = HmiSetTempChamberTIFG;
 290   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 291   1        {   
 292   2          WS_DelTaskIfg(WS_TaskState);
 293   2          {
 294   3            HmiSetTempChamberFunc();
 295   3          }
 296   2        } 
 297   1      } 
 298          
 299          void HmiSetInExpTask(void)//9
 300          {
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 6   

 301   1        WS_TaskState = HmiSetInExpTIFG;
 302   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 303   1        {   
 304   2          WS_DelTaskIfg(WS_TaskState);
 305   2          {
 306   3            HmiSetInExpFunc();
 307   3          }
 308   2        }
 309   1      }
 310          
 311          void HmiSetTimeTask(void)//10
 312          {
 313   1        WS_TaskState = HmiSetTimeTIFG;
 314   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 315   1        {   
 316   2          WS_DelTaskIfg(WS_TaskState);
 317   2          {
 318   3            HmiSetTimeFunc();
 319   3          }
 320   2        }
 321   1      }
 322          
 323          void HmiScreenSaverModeTask(void)//11
 324          {
 325   1        WS_TaskState = HmiScreenSaverModeTIFG;
 326   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 327   1        {   
 328   2          WS_DelTaskIfg(WS_TaskState);
 329   2          {
 330   3            HmiScreenSaverModeFunc();
 331   3          }
 332   2        }
 333   1      }
 334          
 335          void GetTemp_HpChamberTask(void)//12
 336          {
 337   1        WS_TaskState = GetTemp_HpChamberTIFG;
 338   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 339   1        {   
 340   2          WS_DelTaskIfg(WS_TaskState);
 341   2          {
 342   3            GetTemp_HpChamberFunc();
 343   3          }
 344   2        }   
 345   1      }
 346          
 347          void GetTempHumidity_PatientTask(void)//13
 348          {
 349   1        WS_TaskState = GetTempHumidity_PatientTIFG;
 350   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 351   1        {   
 352   2          WS_DelTaskIfg(WS_TaskState);
 353   2          {
 354   3            GetTempHumidity_PatientFunc();
 355   3          }
 356   2        }   
 357   1      }
 358          
 359          void RefreshTempHumidyTask(void)//14
 360          {
 361   1        WS_TaskState = RefreshTempHumidyTIFG;
 362   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 7   

 363   1        {   
 364   2          WS_DelTaskIfg(WS_TaskState);
 365   2          {
 366   3            RefreshTempHumidyFunc(0);
 367   3          }
 368   2        }   
 369   1      }
 370          
 371          void RefreshRunTimeTask(void)//15
 372          {
 373   1        WS_TaskState = RefreshRunTimeTIFG;
 374   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 375   1        {   
 376   2          WS_DelTaskIfg(WS_TaskState);
 377   2          {
 378   3            RefreshRunTimeFunc(0);
 379   3          }
 380   2        }     
 381   1      }
 382          
 383          void RefreshRTCTimeTask(void)//16
 384          {
 385   1        WS_TaskState = RefreshRTCTimeTIFG;
 386   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 387   1        {   
 388   2          WS_DelTaskIfg(WS_TaskState);
 389   2          {
 390   3            if((Work_State != UI_STATE_SetTime_MODE)//设定时间时不刷新实时RTC时间 
 391   3                &&(Work_State != UI_STATE_SCREENSAVER_MODE))
 392   3            {
 393   4              RefreshRTCTimeFunc(); 
 394   4            } 
 395   3            
 396   3          }
 397   2        }   
 398   1      }
 399          
 400          void HeaterWireControlTask(void)//17
 401          {
 402   1        WS_TaskState = HeaterPlateWireControlTIFG;
 403   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 404   1        {   
 405   2          WS_DelTaskIfg(WS_TaskState);
 406   2          {
 407   3            HeaterPlateWireControlFunc();
 408   3          }
 409   2        }
 410   1      }
 411          
 412          void LowPowerModeTask(void)//18
 413          {
 414   1        WS_TaskState = LowPowerModeTIFG;
 415   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 416   1        {   
 417   2          WS_DelTaskIfg(WS_TaskState);
 418   2          {
 419   3            LowPowerModeFunc();
 420   3          }
 421   2        }
 422   1      }
 423          
 424          void HeaterWireModeDetTask(void)//19
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 8   

 425          {
 426   1        WS_TaskState = HeaterWireModeDetTIFG;
 427   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 428   1        {   
 429   2          WS_DelTaskIfg(WS_TaskState);
 430   2          {
 431   3            HeaterWireModeDetFunc();
 432   3          }
 433   2        }
 434   1      }
 435          
 436          void AlarmErrorTask(void)//20
 437          {
 438   1        WS_TaskState = AlarmErrorTIFG;
 439   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 440   1        {   
 441   2          WS_DelTaskIfg(WS_TaskState);
 442   2          {
 443   3            AlarmErrorFunc();
 444   3          }
 445   2        }
 446   1      }
 447          
 448          void LowTempDet1STask(void)//21
 449          {
 450   1        WS_TaskState = LowTempDet1STIFG;
 451   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 452   1        {   
 453   2          WS_DelTaskIfg(WS_TaskState);
 454   2          {
 455   3            LowTempDet1SFunc();
 456   3          }
 457   2        }
 458   1      }
 459          
 460          void SaveDateToFlashTask(void)//22
 461          {
 462   1        WS_TaskState = SaveDateToFlashTIFG;
 463   1        if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 464   1        {   
 465   2          WS_DelTaskIfg(WS_TaskState);
 466   2          {
 467   3            SaveDateToFlashFunc();
 468   3          }
 469   2        }
 470   1      }
 471          
 472          void UartRecTask(void)//23
 473          {
 474   1          WS_TaskState = UartRecTIFG;
 475   1          if(WS_TaskJudge(WS_TaskState)!=(uint8_t)0)
 476   1          {   
 477   2              WS_DelTaskIfg(WS_TaskState);         
 478   2              UART_RecData_Func();   
 479   2          }
 480   1      }
 481          
 482          
 483          
 484          
 485          
 486          
C51 COMPILER V9.52.0.0   NORMAL_TASK                                                       04/04/2019 16:21:57 PAGE 9   

 487          
 488          
 489          
 490          
 491          
 492          
 493          
 494          
 495          
 496          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1436    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
