C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE GUI
OBJECT MODULE PLACED IN ..\OBJ\GUI.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\CODE\GUI.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER NOAREGS I
                    -NCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sht31;..\H
                    -ARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\GUI.lst) TABS(2) OBJECT(..\OBJ\GUI.ob
                    -j)

line level    source

   1          #include "all.h"
   2          
   3          //2019.03.29
   4          sfr WDT_CONTR = 0xC1;
   5          sbit P21 = 0xA0^1;
   6          sbit P22 = 0xA0^2;
   7          sbit P23 = 0xA0^3;
   8          sbit P40 = 0xC0^0;
   9          
  10          static uint8_t Tik_POST_Tick_100mS = 0;//ÔËÐÐÄ£Ê½µÄÊ±±ê
  11          static uint8_t Tik_HmiFac_Tick_100mS_10S = 0;//10SÄÚ²»ÏìÓ¦ÔòÉÁË¸·ÅÈëÇ°Ì¨ÈÎÎñ
  12          static uint8_t OK_not_Pressed_flag = 0;//OK¼üÃ»ÓÐ±»°´ÏÂ±êÖ¾£¬10SºóÆô¶¯´Ë±êÖ¾
  13          static uint8_t HmiFac_Mode_Changed = 1;//Ä£Ê½±»¸Ä±ä
  14          //static uint8_t HmiLan_Sel_Changed = 1;//Ä£Ê½±»¸Ä±ä
  15          static uint8_t Tik_HmiNon_InvasiveSel_Tick_100mS = 0;//ÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæµÄÊ±±ê
  16          static uint16_t  Tik_ScreenSaver_Tick_100mS = 0;
  17          
  18          static uint16_t   Remeber_Temp_Value;//¼ÇÒäÉè¶¨µÄÊýÖµ
  19          
  20          static void Display_SET_Temp(uint16_t Temp);
  21          static void EnterSetTime(void);//½øÈëÊ±¼äÉè¶¨
  22          static void EnterSetInExp(void);//½øÈëInExpÉè¶¨
  23          static void Date_Is_Correct(void);//ÈÕÆÚÐ£Õý
  24          static void Display_In_Exp_Ratio(uint8_t Dis,uint8_t Dp_en);//ÏÔÊ¾In/Exp 
  25          
  26          static void Display_In_Exp_Ratio(uint8_t Dis,uint8_t Dp_en)//ÏÔÊ¾In/Exp  
  27          {
  28   1        if(Dp_en!=(uint8_t)0)
  29   1        {
  30   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+120,16,200,"In/Exp:",0,BLACK18);   
  31   2      
  32   2          show_str[0]='1';
  33   2          show_str[1]=':';
  34   2          show_str[2]='1';
  35   2          if(Dis <= 1)  //1-1:1 2-1:1.1 3-1:1.2 4-1:1.3 5-1:1.4 6-1:1.5
  36   2          {
  37   3            show_str[3]=' ';
  38   3            show_str[4]=' ';
  39   3          }
  40   2          else
  41   2          {
  42   3            show_str[3]='.';
  43   3            show_str[4]='0' + Dis-1;
  44   3          }
  45   2          show_str[5] = '\0';
  46   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+180,16,200,show_str,0,BLACK18); 
  47   2        }
  48   1        else
  49   1        {
  50   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+120,16,200,"In/Exp:",0,WHITE18); //²»ÏÔÊ¾
  51   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+180,16,200,"      ",0,WHITE18);  
  52   2        }
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 2   

  53   1        
  54   1      }
  55          
  56          void DisPlayTime(const uint8_t TempTime[7],uint8_t TimeKind)//ÏÔÊ¾Ê±¼ä
  57          {
  58   1        uint8_t i;
  59   1        uint8_t color;
  60   1        //2-7//Äê/ÔÂ/ÈÕ/Ê±/·Ö/Ãë
  61   1        
  62   1        color = BLACK18;
  63   1        if(TimeKind == 7)
  64   1        { //ÏÔÊ¾Ãë-------------------------------------------------    
  65   2          i=(TempTime[0]&0xF)%10;
  66   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+68,i,BLACK18);   
  67   2          i=(TempTime[0]>>4)& 0x7;
  68   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+56,i,color);
  69   2        }
  70   1        else if(TimeKind == 6)
  71   1        { //ÏÔÊ¾·Ö========------------------------------------------     
  72   2          i=(TempTime[1]&0xF)%10;
  73   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+40,i,color);
  74   2          i=(TempTime[1]>>4) & 0x7;
  75   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+28,i,color);
  76   2        }
  77   1        else if(TimeKind == 5)
  78   1        { //ÏÔÊ¾Ê±,²ÉÓÃ24Ð¡ÖÆ===========================      
  79   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y,TempTime[2]>>4,color);//BCDÂë
  80   2          DISP_TIME_10X16(POS_SYSTIME_X,POS_SYSTIME_Y+12,TempTime[2]&0x0f,color);
  81   2        }
  82   1        else if(TimeKind == 4)   
  83   1        {//ÏÔÊ¾ÈÕ
  84   2          i=(TempTime[3]&0xF)%10;
  85   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+92,i,color);
  86   2          i=(TempTime[3]>>4)& 0x03;
  87   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+80,i,color);   
  88   2        }
  89   1        else if(TimeKind == 3)       
  90   1        {//ÏÔÊ¾ÔÂ
  91   2          i=(TempTime[4]&0xF)%10;
  92   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+64,i,color);
  93   2          i=(TempTime[4]>>4)& 0x1;
  94   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+52,i,color);
  95   2        }
  96   1        else if(TimeKind == 2)
  97   1        {//ÏÔÊ¾Äê  
  98   2          i=(TempTime[6]&0xF)%10;
  99   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+36,i,color);
 100   2          i=(TempTime[6]>>4)%10;
 101   2          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+24,i,color);
 102   2        } 
 103   1        else
 104   1        {
 105   2          //do nothing
 106   2        }
 107   1      }
 108          
 109          //ÏÔÊ¾Éè¶¨ÎÂ¶È
 110          static void Display_SET_Temp(uint16_t Temp)
 111          {
 112   1        Back_Color=WHITE18;   //ÏÔÊ¾Éè¶¨Öµ
 113   1        //ÎÂ¶ÈÍ¼±ê¿ªÊ¼ÉÁË¸,½øÈëÎÂ¶ÈÉè¶¨
 114   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y,(uint8_t)(Temp/100),BLACK18);  
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 3   

 115   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y+34,Temp%100/10,BLACK18);   
 116   1        DISP_TEMP_30X56(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*2)+5,Temp%10,BLACK18);
 117   1        Draw_Rectangle_Real(POS_RT_TEMP_X+1,POS_RT_TEMP_Y+67,POS_RT_TEMP_X+8,POS_RT_TEMP_Y+71,BLACK18); //»­µã //
             -»­µã
 118   1      }
 119          
 120          
 121          //-----------½øÈëÄ³¸ö¹¤×÷Ä£Ê½½çÃæ
 122          void  HmiEnterToWorkStateFunc(WORK_STATUS State)
 123          {
 124   1        switch(State) 
 125   1        { 
 126   2          case UI_STATE_SERVICE_MODE:
 127   2          { 
 128   3            LCD_LIGHT_CLOSE;
 129   3            Back_Color=WHITE18;
 130   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 131   3      
 132   3            break;
 133   3          }   
 134   2          case UI_STATE_POST_MODE:
 135   2          {
 136   3            Tik_POST_Tick_100mS = 0;      
 137   3            LCD_LIGHT_CLOSE;
 138   3            Back_Color=WHITE18;
 139   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 140   3            break;
 141   3          }
 142   2          case UI_STATE_FACTORY_DEFAULT_SEL_MODE:
 143   2          {
 144   3            Tik_HmiFac_Tick_100mS_10S = 0;      
 145   3            OK_not_Pressed_flag = 0;//OK¼üÃ»ÓÐ±»°´ÏÂ±êÖ¾£¬10SºóÆô¶¯´Ë±êÖ¾
 146   3            
 147   3      
 148   3            {
 149   4              Mem_Flash_Recall(); //¶ÁÈ¡ÉÏ´ÎµÄ¼ÇÒä²¢ÑéÖ¤Êý¾Ý          
 150   4      
 151   4              defalut_mode = Load_User_Pre_MODE;  //Ô¤ÉèÄ£Ê½Ñ¡Ôñ  
 152   4              HmiFac_Mode_Changed = 1;//Ä£Ê½±»¸Ä±ä
 153   4              
 154   4              LCD_LIGHT_CLOSE;
 155   4              Draw_Rectangle(0,0,239,319,BLUE18,4);
 156   4              Draw_Rectangle_Real(0,0,239,319,WHITE18); 
 157   4              
 158   4              Back_Color=WHITE18;
 159   4              {
 160   5                CHAR str_previousSetting[]="Previous Settings";
 161   5                CHAR str_defaultSetting[]="Default Settings";
 162   5                CHAR str_select[]="Select";
 163   5                CHAR str_enter[]="Enter";
 164   5                CHAR str_Patient39C[]="Patient:39 C  ";
 165   5                CHAR str_chamber36C[]="Chamber:36 C  ";
 166   5                
 167   5                strcpy(show_str,str_previousSetting);       
 168   5                LCD_ShowString(Load_User_Pre_Set_X,Load_User_Pre_Set_Y+14,24,280,show_str,0,BLUE18);  
 169   5                strcpy(show_str,str_defaultSetting);        
 170   5                LCD_ShowString(Load_Fac_Set_X,Load_Fac_Set_Y+14,24,280,show_str,0,BLUE18);  
 171   5                strcpy(show_str,str_select);        
 172   5                LCD_ShowString(20,125,16,280,show_str,0,BLUE18);
 173   5                strcpy(show_str,str_enter);       
 174   5                LCD_ShowString(20,245,16,280,show_str,0,BLUE18);
 175   5                  
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 4   

 176   5                Back_Color=WHITE18;   
 177   5                strcpy(show_str,str_Patient39C);          
 178   5                LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y,16,280,show_str,0,BLUE18);
 179   5                Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê    
 180   5                strcpy(show_str,str_chamber36C);            
 181   5                LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*15),16,280,show_str,0,BLUE18);
 182   5                Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê       
             -    
 183   5                LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y,16,280,"In/Exp:1:1.3",0,BLUE18);//            
 184   5                Draw_Rectangle(Load_Fac_Set_X+39,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X-15,Load_User_Pre_Set_Y+24
             -2,RED18,2);//»­²ÎÊý¿ò         
 185   5                Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-10,RED18);//»­Ñ¡Ôñ²ÎÊýºáÏß       
             -    
 186   5              }
 187   4            
 188   4              Back_Color=WHITE18;
 189   4              DISP_ICO_40X40(15,30,3,BLUE18);//ÏÔÊ¾UPÍ¼±ê 
 190   4              DISP_ICO_40X40(15,80,4,BLUE18);//ÏÔÊ¾DOWNÍ¼±ê 
 191   4              DISP_ICO_40X40(15,200,2,BLUE18);//ÏÔÊ¾OKÍ¼±ê
 192   4            }   
 193   3            break;
 194   3          } 
 195   2            
 196   2          case UI_STATE_NON_INVASIVE_MODE:
 197   2          {     
 198   3            Tik_HmiNon_InvasiveSel_Tick_100mS = 0;//ÓÐ´´ÎÞ´´µÄÊ±±ê
 199   3            LCD_LIGHT_CLOSE;
 200   3            Draw_Rectangle_Real(0,0,239,319,WHITE18); //ÇåÆÁ
 201   3            Back_Color=WHITE18;
 202   3            Disp_WuChuang(POS_Select_WC_X,POS_Select_WC_Y,BLUE18);
 203   3            Disp_YouChuang(POS_Select_YC_X,POS_Select_YC_Y,BLUE18);
 204   3            Draw_Rectangle(75,182,162,262,WHITE18,4);
 205   3            Draw_Rectangle(75,58,162,136,RED18,4);
 206   3            LCD_LIGHT_OPEN; 
 207   3            break;
 208   3          }
 209   2          
 210   2          case UI_STATE_RUNNING_NORMAL_MODE:
 211   2          {
 212   3      //      Tik_HmiRunning_Tick_100mS = 0;
 213   3            LCD_LIGHT_CLOSE;      
 214   3            DrawWorkWindows();      
 215   3            RefreshRunTimeFunc(1);//Ç¿ÖÆË¢ÐÂÔËÐÐÊ±¼ä
 216   3            RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂ¶ÈÏÔÊ¾     
 217   3            LCD_LIGHT_OPEN;
 218   3            Tik_ScreenSaver_Tick_100mS = 0;
 219   3            break;
 220   3          } 
 221   2      
 222   2          case UI_STATE_SetTempPatient_MODE:
 223   2          {
 224   3            Remeber_Temp_Value = (uint16_t)Set_RT_Temp; 
 225   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);    
 226   3            Display_SET_Temp(Remeber_Temp_Value);     
 227   3      //      Set_CQK_Subtract_RT = Set_CQK_Temp - Set_RT_Temp;//³öÆø¿ÚºÍÈËÌå¶ËÉè¶¨ÎÂ¶È²î£¬¼ÇÒä´Ë²îÖµ 
 228   3            break;
 229   3          }
 230   2          
 231   2          case UI_STATE_SetTempChamber_MODE:
 232   2          {
 233   3            Remeber_Temp_Value = Set_CQK_Temp;  
 234   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);    
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 5   

 235   3            Display_SET_Temp(Remeber_Temp_Value);   
 236   3            break;
 237   3          }
 238   2          
 239   2          case UI_STATE_SetTime_MODE: 
 240   2          {
 241   3            EnterSetTime();
 242   3            break;
 243   3          }
 244   2          
 245   2          case UI_STATE_SetInExp_MODE: 
 246   2          {
 247   3      //      Display_In_Exp_Ratio(In_Exp_Ratio,1); 
 248   3            EnterSetInExp();//½øÈëInExpÉè¶¨
 249   3            break;
 250   3          }
 251   2          default:
 252   2            break;
 253   2        }
 254   1      }
 255          
 256          //
 257          void HmiServiceModeFunc(void)
 258          {
 259   1        static uint8_t ServiceMode_Step = 0;
 260   1        //ÏÔÊ¾ÆÁ´¿É«²âÊÔ  
 261   1        if(ServiceMode_Step == 0)
 262   1        {
 263   2          ServiceMode_Step = 1;
 264   2          Draw_Rectangle_Real(0,0,239,319,RED18);   //ºì
 265   2          Back_Color=RED18;
 266   2          LCD_ShowString(220,20,16,200,"LCD TEST_RED(Test 1/6)",0,WHITE18);
 267   2          LCD_ShowString(200,20,16,200,"Press Left Up Key...",0,WHITE18); 
 268   2          LCD_LIGHT_OPEN; 
 269   2        }
 270   1        else if(ServiceMode_Step == 1)
 271   1        {
 272   2          if(Key_State_Present == KEY_STATE_UP_Short)//ÏòÏÂ¼üµ½¹¤³§Éè¶¨
 273   2          {
 274   3            ServiceMode_Step = 2;     
 275   3            Draw_Rectangle_Real(0,0,239,319,GREEN18);  //ÂÌ
 276   3            Back_Color=GREEN18;
 277   3            LCD_ShowString(220,20,16,200,"LCD TEST_GREEN(Test 2/6)",0,RED18);
 278   3            LCD_ShowString(200,20,16,200,"Press Left Down Key...",0,RED18);
 279   3          }   
 280   2        }
 281   1        else if(ServiceMode_Step == 2)
 282   1        {
 283   2          if(Key_State_Present == KEY_STATE_Down_Short)
 284   2          {
 285   3            ServiceMode_Step = 3;
 286   3            Draw_Rectangle_Real(0,0,239,319,BLUE18);   //À¶
 287   3            Back_Color=BLUE18;
 288   3            LCD_ShowString(220,20,16,200,"LCD TEST_BLUE(Test 3/6)",0,RED18);
 289   3            LCD_ShowString(200,20,16,200,"Press Right Down Key...",0,RED18);  
 290   3          }
 291   2        }
 292   1        else if(ServiceMode_Step == 3)
 293   1        { 
 294   2          if(Key_State_Present == KEY_STATE_Mute_Short)
 295   2          {
 296   3            ServiceMode_Step = 4;
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 6   

 297   3            Draw_Rectangle_Real(0,0,239,319,BLACK18);  //ºÚ
 298   3            Back_Color=BLACK18;
 299   3            LCD_ShowString(220,20,16,200,"LCD TEST_BLACK(Test 4/6)",0,RED18);
 300   3            LCD_ShowString(200,20,16,200,"Press Right Up Key...",0,RED18);  
 301   3          }
 302   2        }
 303   1        else if(ServiceMode_Step == 4)
 304   1        { 
 305   2          if(Key_State_Present == KEY_STATE_OK_Short)
 306   2          {
 307   3            //LCD²âÊÔ½áÊø 
 308   3            ServiceMode_Step = 5;
 309   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);  //W25X¶ÁÐ´²âÊÔ
 310   3            Back_Color=WHITE18;
 311   3            LCD_ShowString(220,20,16,280,"W25X Write&Read Test(Test 5/6)",0,GRAY18);
 312   3            LCD_ShowString(200,20,16,200,"Press Left Up Key...",0,GRAY18);    
 313   3      
 314   3            //WX25 ²âÊÔ
 315   3            SPI_Erase_Sector(0x100000);//1M×Ö½ÚÆðÆôÉÈÇø²Á³ý
 316   3            WDT_CONTR = 0x3F; ; 
 317   3            delay_ms(300);
 318   3            SaveData[0] = 'O';
 319   3            SaveData[1] = 'K'; 
 320   3            SPI_Write_nBytes(0x100000,2,SaveData);
 321   3            delay_ms(10);
 322   3            SaveData[0] = 0xff;
 323   3            SaveData[1] = 0xff;
 324   3            SPI_Read_nBytes(0x100000,2,SaveData); 
 325   3            //*/
 326   3            
 327   3            if((SaveData[0] == 'O')&&(SaveData[1] == 'K'))
 328   3            {                
 329   4              LCD_ShowString(160,70,16,200,"W25X TEST OK!",0,RED18);
 330   4            }
 331   3            else
 332   3            {
 333   4              LCD_ShowString(160,70,16,200,"W25X TEST Fail!",0,RED18);
 334   4              while(1>0)
 335   4              {
 336   5                WDT_CONTR = 0x3F;
 337   5              }
 338   4            } 
 339   3            //ÏÔÊ¾°æ±¾ºÅ
 340   3            LCD_Show_Verion();
 341   3          }
 342   2        }
 343   1        else if(ServiceMode_Step == 5)
 344   1        {
 345   2          if((KEY_LEFT_DOWN_IN == 0)&&(KEY_RIGHT_DOWN_IN == 0))  //ÏÔÊ¾°æ±¾ÈÕÆÚ
 346   2          {
 347   3            //ÏÔÊ¾ÈÕÆÚ  
 348   3            LCD_ShowString(20,20,16,200,DATE_VER,0,GRAY18);   
 349   3          }
 350   2          else if(Key_State_Present == KEY_STATE_UP_Short)
 351   2          {
 352   3            ServiceMode_Step = 6;
 353   3            
 354   3            LCD_LIGHT_CLOSE;//±³¹â 
 355   3            Back_Color=WHITE18;   
 356   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);  //°×
 357   3            LCD_ShowString(220,20,16,280,"Temperature & Humidity(Test 6/6)",0,RED18);
 358   3      
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 7   

 359   3            DISP_ICO_52X64(POS_ICO_TEMP_X-8,POS_ICO_TEMP_Y,0,BLACK18);//ÈËÌå¶ËÍ¼±ê
 360   3            DISP_ICO_32X40(POS_RT_TEMP_X-8,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î»
 361   3            DISP_ICO_40X40(POS_ICO_SHIDU_X,POS_ICO_TEMP_Y,0,BLACK18); //Êª¶ÈÍ¼±ê
 362   3            DISP_ICO_32X40(POS_RT_RH_X+2,POS_RT_RH_Y+(19*2),ICO_PER,BLACK18); //ÏÔÊ¾Êª¶Èµ¥Î»  
 363   3            DISP_RH14X24(POS_RT_RH_X+5,POS_RT_RH_Y+70,0,BLACK18);
 364   3            DISP_RH14X24(POS_RT_RH_X+5,POS_RT_RH_Y+84,1,BLACK18);
 365   3            DISP_ICO_52X64(55,POS_ICO_TEMP_Y,1,BLACK18); //³öÆø¿ÚÎÂ¶ÈÍ¼±ê
 366   3            DISP_ICO_32X40(55,POS_ICO_TEMP_Y+(35*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î»
 367   3            DISP_HEAT_36X24(15,POS_ICO_TEMP_Y+5,BLACK18);//¼ÓÈÈÅÌÎÂ¶ÈÍ¼±ê 
 368   3            DISP_ICO_32X40(5,POS_ICO_TEMP_Y+(35*3)+5,ICO_DU,BLACK18);//ÎÂ¶Èµ¥Î» 
 369   3            LCD_LIGHT_OPEN;//¿ª±³¹â     
 370   3          }
 371   2          else
 372   2          {
 373   3            //do nothing
 374   3          }
 375   2        }
 376   1        else if(ServiceMode_Step == 6)
 377   1        {
 378   2          ServiceMode_TempHumidy_Disp(); //²âÊÔÄ£Ê½ÏÂÏÔÊ¾ÎÂÊª¶È
 379   2          
 380   2          if(KEY_RIGHT_UP_IN==0)
 381   2          {
 382   3            if(JEP_Temp<=800)
 383   3            {
 384   4              Micro_Temp_Val = 201;
 385   4            }
 386   3            else
 387   3            {
 388   4              Micro_Temp_Val = 0;
 389   4            }
 390   3            if(RT_Temp<=400)
 391   3            {
 392   4              Micro_Temp_In = 201;
 393   4              Micro_Temp_Out = 201;
 394   4            }
 395   3            else
 396   3            {
 397   4              Micro_Temp_In = 0;
 398   4              Micro_Temp_Out = 0;
 399   4            }
 400   3          }
 401   2          else
 402   2          {
 403   3            Micro_Temp_Val = 0;
 404   3            Micro_Temp_In = 0;
 405   3            Micro_Temp_Out = 0;
 406   3          }
 407   2          
 408   2          if((KEY_LEFT_DOWN_IN == 0)&&(KEY_RIGHT_DOWN_IN==0))//Í¬Ê±°´ÏÂÁ½¼ü,½øÈëÕý³£¹¤×÷Ä£Ê½
 409   2          {     
 410   3            Test_Mode_Dis_Jrp_Ctl = 1; //ÊÇ´Ó²âÊÔÄ£Ê½½øÈëÕý³£Ä£Ê½,¼´ÏÔÊ¾¼ÓÈÈÅÌ¿ØÖÆµÄÊý¾Ý  
 411   3            Work_State = UI_STATE_POST_MODE;
 412   3            HmiEnterToWorkStateFunc(UI_STATE_POST_MODE);      
 413   3          }   
 414   2        }
 415   1        else
 416   1        {
 417   2          //do nothing
 418   2        }
 419   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü
 420   1      }  
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 8   

 421          
 422          //-----------POST½çÃæ
 423          void HmiPostFunc_Tik_Cnt(void)
 424          {
 425   1        if(Tik_POST_Tick_100mS < 250)
 426   1        {
 427   2          Tik_POST_Tick_100mS++;
 428   2        }
 429   1      }
 430          
 431          void  HmiPostFunc(void)//GUI --- 
 432          { 
 433   1        static uint8_t Post_Step=0;
 434   1        uint8_t i;
 435   1      
 436   1        //LCD_LIGHT_OPEN;//¿ª±³¹â   
 437   1        if(Post_Step == 0)//RTC×Ô¼ì1
 438   1        {
 439   2          //LCD_ShowString(220,20,16,200,"POST_STEP0!",0,RED18);
 440   2          i = RX8010_Initialize();//RTC³õÊ¼»¯ 
 441   2          if(i == RX8010_INIT_FAIL)//RTC³õÊ¼»¯Ê§Ð§
 442   2          {
 443   3            Post_Step = 255;//FAIL,ÐèÖØÐÂ¿ª»ú»òËÍÐÞ
 444   3            LCD_LIGHT_CLOSE;//±³¹â
 445   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 446   3            LCD_ShowString(180,20,16,200,"RTC Initialize Fail!",0,RED18);
 447   3            LCD_ShowString(140,40,16,300,"Please restart,if the problem",0,RED18);
 448   3            LCD_ShowString(120,20,16,300,"reproduce,contact to the supplier!",0,RED18);
 449   3            WDT_CONTR = 0x3F; 
 450   3            LCD_LIGHT_OPEN;//±³¹â
 451   3          }
 452   2          else if(i == RX8010_INIT_OK)//RTCÎ´³õÊ¼»¯£¬Ôò×Ô¶¯³õÊ¼»¯³É¹¦
 453   2          {
 454   3            Post_Step = 1;//
 455   3            Tik_POST_Tick_100mS = 0;
 456   3            LCD_LIGHT_CLOSE;//±³¹â
 457   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 458   3            LCD_ShowString(220,20,16,200,"RTC Initialize OK!",0,RED18);
 459   3            LCD_LIGHT_OPEN;//¿ª±³¹â     
 460   3            Draw_Rectangle_Real(0,0,239,319,WHITE18);
 461   3          }
 462   2          else
 463   2          {
 464   3            Post_Step = 2;//
 465   3          }
 466   2        }
 467   1        else if(Post_Step == 1)//RTC×Ô¼ì2-×Ô¶¯³õÊ¼»¯,µÈ´ý2S
 468   1        {
 469   2          //LCD_ShowString(190,20,16,200,"POST STEP1!",0,RED18);
 470   2          if(Tik_POST_Tick_100mS > 20)
 471   2          {
 472   3            Post_Step = 2;
 473   3          }   
 474   2        }
 475   1        else if(Post_Step == 2)//FLASH×Ô¼ì1
 476   1        {
 477   2          //LCD_ShowString(160,20,16,200,"POST STEP2!",0,RED18);    
 478   2          SPI_Read_nBytes(0x100000,2,SaveData); 
 479   2          if((SaveData[0] == 'O')&&(SaveData[1] == 'K'))//Ð£Ñé³É¹¦
 480   2          {
 481   3            Post_Step = 4;
 482   3          }
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 9   

 483   2          else
 484   2          {
 485   3            Post_Step = 3;
 486   3            SPI_Erase_Sector(0x100000);//1M×Ö½ÚÆðÆôÉÈÇø²Á³ý
 487   3          }
 488   2        }
 489   1        else if(Post_Step == 3)//FLASH×Ô¼ì2
 490   1        {
 491   2          //LCD_ShowString(130,20,16,200,"POST STEP3!",0,RED18);    
 492   2          SaveData[0] = 'O';
 493   2          SaveData[1] = 'K'; 
 494   2          SPI_Write_nBytes(0x100000,2,SaveData);
 495   2          delay_ms(10);
 496   2          SaveData[0] = 0xff;
 497   2          SaveData[1] = 0xff;
 498   2          SPI_Read_nBytes(0x100000,2,SaveData); 
 499   2            
 500   2          if((SaveData[0] == 'O')&&(SaveData[1] == 'K'))
 501   2          {                
 502   3            Post_Step = 4;//OK
 503   3          }
 504   2          else
 505   2          {
 506   3            Post_Step = 255;//FAIL,ÐèÖØÐÂ¿ª»ú»òËÍÐÞ       
 507   3            LCD_ShowString(180,20,16,200,"Memory Initialize Fail!",0,RED18);
 508   3            LCD_ShowString(140,40,16,300,"Please restart,if the problem",0,RED18);
 509   3            LCD_ShowString(120,20,16,300,"reproduce,contact to the supplier!",0,RED18);
 510   3          }     
 511   2        }
 512   1        else if(Post_Step == 4)//HP SENSOR-2
 513   1        {
 514   2          //LCD_ShowString(100,20,16,200,"POST STEP4!",0,RED18);    
 515   2          Tik_POST_Tick_100mS = 0;
 516   2          Post_Step = 5;
 517   2        }
 518   1        else if(Post_Step == 5)//HP SENSOR-2
 519   1        {
 520   2          //LCD_ShowString(70,20,16,200,"POST STEP5!",0,RED18); 
 521   2          //LCD_ShowxNum(130,70,16,3,No_HeatSensor_Times,0x80,BLACK18); //
 522   2          if(Tik_POST_Tick_100mS > 10)//ÑÓÊ±1S
 523   2          {
 524   3            if(No_HeatSensor_Times>25)//¼ÓÈÈÅÌ´«¸ÐÆ÷´íÎó¼ì²â,1S¿ÉÒÔ¼ì²âµ½50´Î
 525   3            {
 526   4              Post_Step = 6;
 527   4              Tik_POST_Tick_100mS = 0;
 528   4            } 
 529   3            else
 530   3            {
 531   4              Post_Step = 7;//PASS    
 532   4            }
 533   3          }
 534   2        }
 535   1        else if(Post_Step == 6)//HP SENSOR-3 ¼ì²âÁ½´Î
 536   1        {
 537   2          //LCD_ShowString(40,20,16,200,"POST STEP6!",0,RED18);
 538   2          //LCD_ShowxNum(130,150,16,3,No_HeatSensor_Times,0x80,BLACK18); //·¢ÈÈÅÌ¼ÓÈÈµÄÄ£Ê½ÏÔÊ¾   
 539   2          if(Tik_POST_Tick_100mS > 30)//ÑÓÊ±3S
 540   2          {
 541   3            if(No_HeatSensor_Times>100)//¼ÓÈÈÅÌ´«¸ÐÆ÷´íÎó¼ì²â 4S¼ì²âµ½200´Î
 542   3            {
 543   4              Post_Step = 255;
 544   4              LCD_ShowString(180,20,16,200,"Sensor Initialize Fail!",0,RED18);
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 10  

 545   4              LCD_ShowString(140,40,16,300,"Please restart,if the problem",0,RED18);
 546   4              LCD_ShowString(120,20,16,300,"reproduce,contact to the supplier!",0,RED18);        
 547   4            }
 548   3            else
 549   3            {
 550   4              Post_Step = 7;//PASS    
 551   4            }
 552   3          }
 553   2        }
 554   1        else if(Post_Step == 7)//
 555   1        {
 556   2          //LCD_ShowString(10,20,16,200,"POST_STEP7!",0,RED18);   
 557   2          Work_State = UI_STATE_FACTORY_DEFAULT_SEL_MODE;
 558   2          HmiEnterToWorkStateFunc(UI_STATE_FACTORY_DEFAULT_SEL_MODE);
 559   2        }
 560   1        else if(Post_Step == 255)//FAIL
 561   1        {
 562   2          LCD_LIGHT_OPEN; 
 563   2        }
 564   1        else
 565   1        {
 566   2          //do nothing
 567   2        }
 568   1      }
 569          
 570          
 571          //-----------¿ª»úÑ¡Ôñ½çÃæ
 572          static uint8_t Tik_HmiFac_Tick_100mS_OK_flash = 0;//OKÉÁË¸¶ÁÊý
 573          void HmiFactoryDefault_Tik_Cnt(void)
 574          {
 575   1        if(Tik_HmiFac_Tick_100mS_10S < 250)
 576   1        {
 577   2          Tik_HmiFac_Tick_100mS_10S++;
 578   2        }
 579   1        if(Tik_HmiFac_Tick_100mS_OK_flash <250 )
 580   1        {
 581   2          Tik_HmiFac_Tick_100mS_OK_flash++;
 582   2        }
 583   1      }
 584          
 585          void  HmiFactoryDefaultFunc(void)//GUI --- 
 586          {
 587   1        uint16_t Pre_Disp_Deg_10;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶È¸öÎ» ÏÔÊ¾
 588   1        uint16_t Pre_Disp_Deg_1;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶ÈÐ¡Êý ÏÔÊ¾
 589   1        uint16_t Pre_Disp_Deg_CQK_10;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶È¸öÎ» ÏÔÊ¾
 590   1        uint16_t Pre_Disp_Deg_CQK_1;//ÉÏÒ»´ÎÉè¶¨ÎÂ¶ÈÐ¡Êý ÏÔÊ¾
 591   1      
 592   1        if(Tik_HmiFac_Tick_100mS_10S >= 100)//10S
 593   1        {
 594   2          OK_not_Pressed_flag = 1;
 595   2        }   
 596   1        
 597   1        if(OK_not_Pressed_flag!=(uint8_t)0)
 598   1        {     
 599   2          if(Tik_HmiFac_Tick_100mS_OK_flash == 1)
 600   2          {
 601   3            
 602   3          }     
 603   2          else if(Tik_HmiFac_Tick_100mS_OK_flash == 5)
 604   2          {
 605   3      
 606   3          }     
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 11  

 607   2          else if(Tik_HmiFac_Tick_100mS_OK_flash == 10)
 608   2          {
 609   3            Back_Color=WHITE18;
 610   3            DISP_ICO_40X40(15,200,2,BLUE18);//ÏÔÊ¾OKÍ¼±ê  
 611   3            Back_Color=WHITE18;         
 612   3          }
 613   2          else if(Tik_HmiFac_Tick_100mS_OK_flash >= 20)//0.5HzµÄÉÁË¸ÆµÂÊ
 614   2          {
 615   3            Tik_HmiFac_Tick_100mS_OK_flash = 0;       
 616   3            Back_Color=WHITE18; 
 617   3            DISP_ICO_40X40(15,200,2,RED18);//ÏÔÊ¾OKÍ¼±ê 
 618   3            Back_Color=WHITE18;
 619   3            Sound_Short();
 620   3          }
 621   2          else
 622   2          {
 623   3            //do nothing
 624   3          }
 625   2        }
 626   1              
 627   1      //ÒÔÏÂ¼ì²âKEY 
 628   1        if((Key_State_Present == KEY_STATE_Down_Short)//ÏòÏÂ¼üµ½¹¤³§Éè¶¨
 629   1          ||(Key_State_Present == KEY_STATE_Down_Long_First))
 630   1      
 631   1        {
 632   2          if(defalut_mode == Load_User_Pre_MODE)
 633   2          {
 634   3            HmiFac_Mode_Changed = 1;         
 635   3            defalut_mode = Load_Fac_MODE;  
 636   3          }
 637   2        } 
 638   1        else if((Key_State_Present == KEY_STATE_UP_Short)
 639   1          ||(Key_State_Present == KEY_STATE_UP_Long_First))
 640   1        {
 641   2          if(defalut_mode == Load_Fac_MODE)
 642   2          {
 643   3            HmiFac_Mode_Changed = 1;  
 644   3            defalut_mode = Load_User_Pre_MODE;
 645   3          }
 646   2        }
 647   1        else if((Key_State_Present == KEY_STATE_OK_Short)//½øÈë¿ª»úÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ»òÖ±½Ó½øÈ¥¿ª»úÔËÐÐ½çÃæ
 648   1             ||(Key_State_Present ==KEY_STATE_OK_Long_First))
 649   1        {
 650   2          Load_Settings_Before_Choice();//ÔÚÑ¡Ôñ·½¿ò³öÏÖÖ®Ç°£¬Òª´¦ÀíµÄÊý¾Ý£¬ÒÔÍ¬Ê±¼æÈÝÓÐÎÞÑ¡Ôñ¼ÇÒä½çÃæ³ÌÐò         
 651   2          HmiFac_Mode_Changed = 0;  
 652   2          LCD_LIGHT_CLOSE;      
 653   2          if(defalut_mode == Load_Fac_MODE)//Ä¬ÐíÉè¶¨
 654   2          {          
 655   3            Work_State = UI_STATE_NON_INVASIVE_MODE;
 656   3            HmiEnterToWorkStateFunc(UI_STATE_NON_INVASIVE_MODE);
 657   3          }
 658   2          else//ÉÏÒ»´ÎµÄÉè¶¨
 659   2          {
 660   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
 661   3            HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);           
 662   3          }        
 663   2        }
 664   1        else
 665   1        {
 666   2          //do nothing
 667   2        }
 668   1      
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 12  

 669   1        if(HmiFac_Mode_Changed!=(uint8_t)0)
 670   1        {
 671   2          HmiFac_Mode_Changed = 0;          
 672   2              
 673   2          data_flash.Language = Lan_English;//·ÇFANEMÖ»ÓÐÓ¢Óï
 674   2      
 675   2          
 676   2          if(data_flash.Work_Mode==Noninvasive_Mode)    //¼ÆËãÒªÏÔÊ¾µÄÊý¾Ý  
 677   2          {           
 678   3            Pre_Disp_Deg_10 = data_flash.Set_RT_WCTemp * 5 / 10;//ÕûÊýÎ»
 679   3            Pre_Disp_Deg_1 = data_flash.Set_RT_WCTemp * 5 % 10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 680   3            
 681   3            Pre_Disp_Deg_CQK_10 = data_flash.Set_CQK_WCTemp * 5 / 10;//ÕûÊýÎ»
 682   3            Pre_Disp_Deg_CQK_1 = data_flash.Set_CQK_WCTemp * 5 % 10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 683   3          }
 684   2          else
 685   2          {
 686   3            Pre_Disp_Deg_10 = data_flash.Set_RT_YCTemp * 5 / 10;//ÕûÊýÎ»
 687   3            Pre_Disp_Deg_1 = data_flash.Set_RT_YCTemp * 5 % 10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 688   3            
 689   3            Pre_Disp_Deg_CQK_10 = data_flash.Set_CQK_YCTemp * 5 / 10;//ÕûÊýÎ»
 690   3            Pre_Disp_Deg_CQK_1 = data_flash.Set_CQK_YCTemp * 5 % 10;//ÈôÊÇ0ÔòÎÞÐ¡Êý,ÊÇ5ÔòÏÔÊ¾5
 691   3          } 
 692   2                
 693   2          if(defalut_mode == Load_User_Pre_MODE)  //ÓÃ»§ÉÏÒ»´ÎµÄÉè¶¨   
 694   2          {     //»­ºìÉ«¿ò
 695   3            Draw_Rectangle(Load_Fac_Set_X-10,Load_User_Pre_Set_Y-10,Load_Fac_Set_X+34,Load_User_Pre_Set_Y+242,WHITE
             -18,4);
 696   3            Draw_Rectangle(Load_User_Pre_Set_X-10,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X+34,Load_User_Pre_Set_Y
             -+242,RED18,4);//
 697   3            
 698   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,84,Load_User_Pre_Set_Y-10,WHITE18);//
 699   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-29,WHITE18);// 
 700   3           
 701   3            Draw_Rectangle_Real(203,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-10,RED18);//
 702   3            Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-29,RED18);//   
 703   3            
 704   3            if(data_flash.Work_Mode==Noninvasive_Mode)    //
 705   3            {
 706   4              CHAR str_modeNoinvasive[]="Mode:Noninvasive      ";
 707   4              strcpy(show_str,str_modeNoinvasive);        
 708   4              LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y,16,280,show_str,0,BLUE18);
 709   4            }
 710   3            else
 711   3            {
 712   4              CHAR str_modeInvasive[]="Mode:Invasive         ";
 713   4              strcpy(show_str,str_modeInvasive);
 714   4              LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y,16,280,show_str,0,BLUE18);
 715   4            }
 716   3            
 717   3            LCD_ShowxNum(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*8),16,2,Pre_Disp_Deg_10,0x00,BLUE18);//»¼Õ
             -ß¶ËÎÂ¶È
 718   3            if(Pre_Disp_Deg_1 == 0)//ÎÞÐ¡Êý
 719   3            {
 720   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*11),16,280,"C  ",0,BLUE18);//
 721   4              Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 722   4            }
 723   3            else//ÓÐÐ¡Êý
 724   3            {
 725   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*10),16,280,".5",0,BLUE18);//.5
 726   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*13),16,280,"C ",0,BLUE18);//
 727   4              Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*12),2,BLUE18);//ÎÂ¶ÈÍ¼±ê                
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 13  

 728   4            } 
 729   3      
 730   3            LCD_ShowxNum(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*8)+(8*15),16,2,Pre_Disp_Deg_CQK_10,0x00,BL
             -UE18);//³öÆø¿Ú¶ËÎÂ¶È
 731   3            if(Pre_Disp_Deg_CQK_1 == 0)//ÎÞÐ¡Êý
 732   3            {
 733   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*11)+(8*15),16,280,"C  ",0,BLUE18);//
 734   4              Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 735   4            }
 736   3            else//ÓÐÐ¡Êý
 737   3            {
 738   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*10)+(8*15),16,280,".5",0,BLUE18);//.5
 739   4              LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*13)+(8*15),16,280,"C ",0,BLUE18);//
 740   4              Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*12)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê         
             -      
 741   4            }               
 742   3            
 743   3            if(data_flash.In_Exp_Ratio == 1)//1:1
 744   3            {
 745   4              LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,"  ",0,BLUE18);//1:1
 746   4            }
 747   3            else
 748   3            {
 749   4              LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,".",0,BLUE18); 
 750   4              LCD_ShowxNum(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*11),16,1,data_flash.In_Exp_Ratio-1,0x0,BL
             -UE18);//
 751   4            }                       
 752   3          }
 753   2          else  //¹¤³§Éè¶¨
 754   2          {
 755   3            CHAR str_invasive[]="Invasive         ";
 756   3            CHAR str_patient39C[]="Patient:39 C  ";
 757   3            CHAR str_chamber36C[]="Chamber:36 C  ";
 758   3            
 759   3            
 760   3            Draw_Rectangle(Load_Fac_Set_X-10,Load_User_Pre_Set_Y-10,Load_Fac_Set_X+34,Load_User_Pre_Set_Y+242,RED18
             -,4);
 761   3            Draw_Rectangle(Load_User_Pre_Set_X-10,Load_User_Pre_Set_Y-10,Load_User_Pre_Set_X+34,Load_User_Pre_Set_Y
             -+242,WHITE18,4);//
 762   3           
 763   3            Draw_Rectangle_Real(203,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-10,WHITE18);//            
 764   3            Draw_Rectangle_Real(143,Load_User_Pre_Set_Y-30,204,Load_User_Pre_Set_Y-29,WHITE18);//
 765   3           
 766   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,84,Load_User_Pre_Set_Y-10,RED18);//
 767   3            Draw_Rectangle_Real(83,Load_User_Pre_Set_Y-30,144,Load_User_Pre_Set_Y-29,RED18);//  
 768   3            strcpy(show_str,str_invasive);
 769   3            LCD_ShowString(Load_User_Pre_Set_X - 36,Load_User_Pre_Set_Y+(8*5),16,280,show_str,0,BLUE18);//ÓÐ´´          
 770   3            strcpy(show_str,str_patient39C);        
 771   3            LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y,16,280,show_str,0,BLUE18);
 772   3            Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10),2,BLUE18);//ÎÂ¶ÈÍ¼±ê  
 773   3            strcpy(show_str,str_chamber36C);            
 774   3            LCD_ShowString(Load_User_Pre_Set_X - 56,Load_User_Pre_Set_Y+(8*15),16,280,show_str,0,BLUE18);
 775   3            Draw_Circle(Load_User_Pre_Set_X - 56 +12,Load_User_Pre_Set_Y+4+(8*10)+(8*15),2,BLUE18);//ÎÂ¶ÈÍ¼±ê
 776   3            LCD_ShowString(Load_User_Pre_Set_X - 76,Load_User_Pre_Set_Y+(8*10),16,280,".3",0,BLUE18);//1:1.3 
 777   3          }
 778   2          LCD_LIGHT_OPEN; 
 779   2        } 
 780   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü
 781   1      }
 782          
 783          //-----------¿ª»úÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ
 784          
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 14  

 785          void HmiNon_InvasiveSel_Tik_Cnt(void)
 786          {
 787   1        if(Tik_HmiNon_InvasiveSel_Tick_100mS < 250)
 788   1        {
 789   2          Tik_HmiNon_InvasiveSel_Tick_100mS++;
 790   2        }
 791   1      }
 792          
 793          void  HmiNon_InvasiveSelFunc(void)//ÓÐ´´ÎÞ´´Ñ¡Ôñ½çÃæ
 794          {
 795   1        WDT_CONTR = 0x3F; //¿ªÆôWDT,ÔÚ22.1184Ê±Ê±¼äÎª4.55S  
 796   1        {
 797   2          if((Key_State_Present == KEY_STATE_UP_Short)//
 798   2               ||(Key_State_Present ==KEY_STATE_UP_Long_First))
 799   2          {
 800   3      
 801   3            if(Work_Mode==0)
 802   3            {
 803   4              Work_Mode=1;
 804   4            }
 805   3            else
 806   3            {
 807   4              Work_Mode=0;  
 808   4            }
 809   3      
 810   3            if(Work_Mode==0)  //ÎÞ´´Ä£Ê½
 811   3            { 
 812   4              Draw_Rectangle(75,182,162,262,RED18,4);//
 813   4              Draw_Rectangle(75,58,162,136,WHITE18,4);
 814   4            }else  //ÎÞ´´Ä£Ê½
 815   3            { 
 816   4              Draw_Rectangle(75,182,162,262,WHITE18,4);
 817   4              Draw_Rectangle(75,58,162,136,RED18,4);
 818   4            }
 819   3      
 820   3          }
 821   2          else if((Key_State_Present == KEY_STATE_OK_Short)//½øÈëÔËÐÐ×´Ì¬
 822   2               ||(Key_State_Present ==KEY_STATE_OK_Long_First)
 823   2               ||(Tik_HmiNon_InvasiveSel_Tick_100mS > 30))
 824   2      
 825   2          {
 826   3           LCD_LIGHT_CLOSE;    
 827   3           Work_State = UI_STATE_RUNNING_NORMAL_MODE;
 828   3           HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);
 829   3          }
 830   2          else
 831   2          {
 832   3            //do nothing
 833   3          }
 834   2        } 
 835   1        data_flash.Work_Mode = Work_Mode;//Ñ¡¶¨µÄÄ£Ê½
 836   1      
 837   1        Setting_write_to_flash();//Ð´Èëµ½FLASH    
 838   1      
 839   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
 840   1      }
 841          
 842          
 843          //-----------ÔËÐÐ½çÃæ
 844          DISPLAY_Temp_Kind Display_Temp_Kind = DISPLAY_Temperature_Patient;     //ÏÔÊ¾ÎÂ¶ÈÀàÐÍ 0-»¼Õß¶ËÎÂ¶È 1-³öÆø¿
             -ÚÎÂ¶È
 845          
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 15  

 846          void  HmiRunningFunc(void)//
 847          {
 848   1        static uint8_t Display_Return_Cnt = 0;
 849   1        if((Key_State_Present == KEY_STATE_UP_Short)//ÇÐ»»ÏÔÊ¾
 850   1          ||(Key_State_Present == KEY_STATE_UP_Long_First))
 851   1        {
 852   2          Display_Return_Cnt = 0;
 853   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 854   2          {
 855   3            Display_Temp_Kind = DISPLAY_Temperature_Chamber;
 856   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,1,BLACK18);
 857   3            Display_In_Exp_Ratio(In_Exp_Ratio,1);     
 858   3          } 
 859   2          else  
 860   2          {
 861   3            Display_Temp_Kind = DISPLAY_Temperature_Patient;
 862   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 863   3            Display_In_Exp_Ratio(In_Exp_Ratio,0);
 864   3          } 
 865   2          RefreshTempHumidyFunc(1);   
 866   2        }
 867   1        else if(Key_State_Present == KEY_STATE_Down_Long_First)//¸Ä±äÄ£Ê½
 868   1        {
 869   2          Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
 870   2          Sound_Short();    
 871   2          Set_RT_WCTemp = 340;// ÇÐ»»Ä£Ê½¼´ÎÂ¶ÈÉè¶¨»Ø¸´³ö³§Éè¶¨
 872   2          Set_RT_YCTemp = 390;//
 873   2          Set_CQK_WCTemp = 310;//
 874   2          Set_CQK_YCTemp = 360;//
 875   2      
 876   2          RT_Temp_Reach_Set_Cnt = 0;//ÈËÌå¶Ë´ïµ½ÎÂ¶È¼ÆÊýÇåÁã
 877   2          CQK_Temp_Reach_Set_Cnt = 0;
 878   2      
 879   2          if(Work_Mode==Invasive_Mode)  
 880   2          { 
 881   3            Work_Mode=Noninvasive_Mode; 
 882   3            Set_RT_Temp=(INT)Set_RT_WCTemp; 
 883   3            Set_CQK_Temp=Set_CQK_WCTemp;    
 884   3          }
 885   2          else
 886   2          {
 887   3            Work_Mode=Invasive_Mode;  
 888   3            Set_RT_Temp=(INT)Set_RT_YCTemp;   
 889   3            Set_CQK_Temp=Set_CQK_YCTemp;        
 890   3          }
 891   2          data_flash.Set_RT_WCTemp = (uint8_t)(Set_RT_WCTemp/5);//
 892   2          data_flash.Set_RT_YCTemp = (uint8_t)(Set_RT_YCTemp/5);//
 893   2          data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/5);//
 894   2          data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/5);//
 895   2          data_flash.Work_Mode = Work_Mode;// 
 896   2          Setting_write_to_flash(); 
 897   2          Refresh_Work_Mode();//ÇÐ»»Í¼±ê        
 898   2        }
 899   1        else if(Key_State_Present == KEY_STATE_OK_Long_First)//³¤°´OK½øÈëÉè¶¨×´Ì¬
 900   1        {
 901   2          Sound_Short();
 902   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 903   2          {
 904   3            Work_State = UI_STATE_SetTempPatient_MODE;//Éè¶¨»¼Õß¶ËÎÂ¶È
 905   3            HmiEnterToWorkStateFunc(UI_STATE_SetTempPatient_MODE);  
 906   3            Remeber_Temp_Value= (uint16_t)Set_RT_Temp;
 907   3          }
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 16  

 908   2          else
 909   2          {
 910   3            Work_State = UI_STATE_SetTempChamber_MODE;//Éè¶¨³öÆø¿ÚÎÂ¶È
 911   3            HmiEnterToWorkStateFunc(UI_STATE_SetTempChamber_MODE);
 912   3            Remeber_Temp_Value = Set_CQK_Temp;      
 913   3          }
 914   2        } 
 915   1        else if(Key_State_Present == KEY_STATE_Mute_Long_First)//³¤°´MUTE½øÈëÊ±¼äÉè¶¨×´Ì¬
 916   1        {
 917   2          Sound_Short();
 918   2          if(Display_Temp_Kind == DISPLAY_Temperature_Patient)
 919   2          {
 920   3            Work_State = UI_STATE_SetTime_MODE;//Éè¶¨ÈÕÆÚºÍÊ±¼ä
 921   3            HmiEnterToWorkStateFunc(UI_STATE_SetTime_MODE); 
 922   3      
 923   3          }
 924   2        }
 925   1        else if(Key_State_Present == KEY_STATE_OK_Short)//¶Ì°´OK¼üÇåÉ«¿é±ê¼Ç
 926   1        { 
 927   2          Draw_Rectangle_Real(POS_ALARM_COL_X,POS_ALARM_COL_Y,POS_ALARM_COL_X+10,POS_ALARM_COL_Y+45,WHITE18);
 928   2          WireInOut_State_Confirm();//Õý³£ÔËÐÐ½çÃæ,°´ÏÂÈ·ÈÏ¼üÈ·¶¨»ØÂ·µÄÄ£Ê½   
 929   2        }
 930   1        else
 931   1        {
 932   2          //do nothing
 933   2        }
 934   1      
 935   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
 936   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
 937   1        {
 938   2          Display_Return_Cnt = 0;
 939   2        }
 940   1        if(Display_Return_Cnt < 90)
 941   1        {
 942   2          Display_Return_Cnt++;
 943   2        }
 944   1        else
 945   1        {
 946   2          if(Display_Temp_Kind == DISPLAY_Temperature_Chamber)
 947   2          {
 948   3            Back_Color=WHITE18;
 949   3            Display_Temp_Kind = DISPLAY_Temperature_Patient;  
 950   3            DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 951   3            Display_In_Exp_Ratio(In_Exp_Ratio,0);
 952   3          }     
 953   2        }
 954   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
 955   1      }
 956          
 957          
 958          //-----------»¼Õß¶ËÎÂ¶ÈÉèÖÃ½çÃæ
 959          void  HmiSetTempPatientFunc(void)//GUI --- 
 960          {
 961   1        static uint8_t Set_Temp_Cnt=0; 
 962   1        static uint8_t Display_Return_Cnt = 0;
 963   1        Set_Temp_Cnt++;
 964   1        if(Set_Temp_Cnt > 10)
 965   1        {
 966   2          Set_Temp_Cnt = 0;
 967   2        }
 968   1        Back_Color=WHITE18;
 969   1        if(Set_Temp_Cnt == 0)
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 17  

 970   1        {
 971   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
 972   2        }
 973   1        else if(Set_Temp_Cnt == 5)
 974   1        {
 975   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,WHITE18);
 976   2        }
 977   1        else
 978   1        {
 979   2          //do nothing
 980   2        }
 981   1          
 982   1        
 983   1        if((Key_State_Present == KEY_STATE_UP_Short)//Ôö¼Ó
 984   1            ||(Key_State_Present == KEY_STATE_UP_Long_First)
 985   1            ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))
 986   1        { 
 987   2          if(Work_Mode==Noninvasive_Mode)
 988   2          {
 989   3            if(Remeber_Temp_Value<Const_NoninvasPatientTemp_Max)
 990   3            {
 991   4              Remeber_Temp_Value=Remeber_Temp_Value+5;
 992   4            } 
 993   3          }
 994   2          else
 995   2          {
 996   3            if(Remeber_Temp_Value<Const_InvasPatientTemp_Max)
 997   3            {
 998   4              Remeber_Temp_Value=Remeber_Temp_Value+5;
 999   4            }  
1000   3          } 
1001   2          Display_SET_Temp(Remeber_Temp_Value);       
1002   2        }
1003   1        else if((Key_State_Present == KEY_STATE_Down_Short)//¼õÐ¡
1004   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1005   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1006   1        { 
1007   2          if(Work_Mode==Noninvasive_Mode)  //ÎÞ´´
1008   2          {
1009   3            if(Remeber_Temp_Value>Const_NoninvasPatientTemp_Min)
1010   3            {
1011   4              Remeber_Temp_Value=Remeber_Temp_Value-5;
1012   4            } 
1013   3          } 
1014   2          else
1015   2          {
1016   3            if(Remeber_Temp_Value>Const_InvasPatientTemp_Min)
1017   3            {
1018   4              Remeber_Temp_Value=Remeber_Temp_Value-5;
1019   4            }
1020   3          }
1021   2          Display_SET_Temp(Remeber_Temp_Value);   
1022   2        }
1023   1        else if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1024   1        {   
1025   2          Work_State = UI_STATE_SetInExp_MODE;
1026   2          HmiEnterToWorkStateFunc(UI_STATE_SetInExp_MODE);
1027   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1028   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾ 
1029   2          Display_Return_Cnt = 0;   
1030   2        }
1031   1        else if(Key_State_Present == KEY_STATE_OK_Short)//È·ÈÏ
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 18  

1032   1        {
1033   2          Sound_Short();
1034   2          if(Set_RT_Temp != (INT)Remeber_Temp_Value)//ÈôÎ´¸Ä±äÈËÌå¶ËÎÂ¶ÈÉè¶¨Ôò²»½øÐÐ²Ù×÷
1035   2          {
1036   3            Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
1037   3            Set_RT_Temp=(INT)Remeber_Temp_Value;
1038   3            if(Work_Mode == Noninvasive_Mode)
1039   3            {
1040   4              Set_RT_WCTemp=(uint16_t)Set_RT_Temp;
1041   4              data_flash.Set_RT_WCTemp = (uint8_t)(Set_RT_WCTemp/5);//ÎÞ´´Éè¶¨ÎÂ¶È 
1042   4              
1043   4              if(Set_RT_WCTemp >= 320) 
1044   4              {
1045   5                Set_CQK_WCTemp = 310;//ÈËÌå¶Ë>=32Ê±³öÆø¿ÚÎÂ¶ÈÎª31
1046   5              }
1047   4              else
1048   4              {
1049   5                Set_CQK_WCTemp = 300;//ÈËÌå¶Ë>=32Ê±³öÆø¿ÚÎÂ¶ÈÎª31 
1050   5              }         
1051   4              data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/5);                            
1052   4              Set_CQK_Temp = (uint8_t)Set_CQK_WCTemp; 
1053   4            }
1054   3            else
1055   3            {
1056   4              Set_RT_YCTemp=(uint16_t)Set_RT_Temp; 
1057   4              data_flash.Set_RT_YCTemp = (uint8_t)(Set_RT_YCTemp/5);//ÓÐ´´Éè¶¨ÎÂ¶È 
1058   4              
1059   4              if(Set_RT_YCTemp >= 370) 
1060   4              {
1061   5                Set_CQK_YCTemp = Set_RT_YCTemp - 30;//ÈËÌå¶Ë>=37Ê±³öÆø¿ÚÎÂ¶ÈÎªRT-3
1062   5              }
1063   4              else
1064   4              {
1065   5                Set_CQK_YCTemp = 340; //ÓÐ´´³öÆø¿ÚÉè¶¨ÎÂ¶È 
1066   5              }
1067   4              data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/5);
1068   4              Set_CQK_Temp = Set_CQK_YCTemp;                          
1069   4            }
1070   3          }   
1071   2          
1072   2          Setting_write_to_flash(); 
1073   2          Display_Return_Cnt = 0;
1074   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1075   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1076   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1077   2        }
1078   1        else
1079   1        {
1080   2          //do nothing
1081   2        }
1082   1        
1083   1        
1084   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1085   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1086   1        {
1087   2          Display_Return_Cnt = 0;
1088   2        }
1089   1        if(Display_Return_Cnt < 90)
1090   1        {
1091   2          Display_Return_Cnt++;
1092   2        }
1093   1        else
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 19  

1094   1        {
1095   2          Display_Return_Cnt = 0;
1096   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1097   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1098   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1099   2        }
1100   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1101   1      }
1102          
1103          //-----------³öÆø¿ÚÎÂ¶ÈÉèÖÃ½çÃæ
1104          void  HmiSetTempChamberFunc(void)//GUI
1105          {
1106   1        static uint8_t Set_Temp_Cnt=0; 
1107   1        static uint8_t Display_Return_Cnt = 0;
1108   1        Set_Temp_Cnt++;
1109   1        if(Set_Temp_Cnt > 10)
1110   1        {
1111   2          Set_Temp_Cnt = 0;
1112   2        }
1113   1        Back_Color=WHITE18;
1114   1        if(Set_Temp_Cnt == 0)
1115   1        {
1116   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1117   2        } 
1118   1        else if(Set_Temp_Cnt == 5)
1119   1        {
1120   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,WHITE18);
1121   2        }
1122   1        else
1123   1        {
1124   2          //do nothing
1125   2        }
1126   1          
1127   1        
1128   1        if((Key_State_Present == KEY_STATE_UP_Short)//Ôö¼Ó
1129   1            ||(Key_State_Present == KEY_STATE_UP_Long_First)
1130   1            ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))
1131   1        { 
1132   2          if(Work_Mode==Noninvasive_Mode)//ÎÞ´´
1133   2          {//³öÆø¿ÚÎÂ¶È×î´ó32¶È
1134   3            if(Remeber_Temp_Value<(uint16_t)Const_NoninvasChamberTemp_Max)
1135   3            {
1136   4              Remeber_Temp_Value=Remeber_Temp_Value+5;
1137   4            } 
1138   3          }
1139   2          else if(Work_Mode==(uint8_t)Invasive_Mode)
1140   2          {//³öÆø¿ÚºÍ»¼Õß¶ËÎÂ¶È²îÎª-4/+3
1141   3            if((Remeber_Temp_Value<Const_InvasChamberTemp_Max)&&(Remeber_Temp_Value<((uint16_t)Set_RT_Temp+30)))
1142   3            {
1143   4              Remeber_Temp_Value=Remeber_Temp_Value+5;
1144   4            }
1145   3          } 
1146   2          else
1147   2          {
1148   3            //do nothing
1149   3          }
1150   2          Display_SET_Temp(Remeber_Temp_Value);       
1151   2        }
1152   1        else if((Key_State_Present == KEY_STATE_Down_Short)//¼õÐ¡
1153   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1154   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1155   1        { 
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 20  

1156   2          if(Work_Mode==Noninvasive_Mode)  //ÎÞ´´
1157   2          {//×îÐ¡30¶È
1158   3            if(Remeber_Temp_Value>Const_NoninvasChamberTemp_Min)
1159   3            {
1160   4              Remeber_Temp_Value=Remeber_Temp_Value-5;
1161   4            } 
1162   3          } 
1163   2          else if(Work_Mode==Invasive_Mode) //ÓÐ´´ ³öÆø¿ÚºÍ»¼Õß¶ËÎÂ¶È²îÎª-4/+3 //×îÐ¡34¶È
1164   2          {
1165   3            if((Remeber_Temp_Value>Const_InvasChamberTemp_Min)&&(Remeber_Temp_Value>((uint16_t)Set_RT_Temp-40)))
1166   3            {
1167   4              Remeber_Temp_Value=Remeber_Temp_Value-5;
1168   4            }
1169   3          } 
1170   2          else
1171   2          {
1172   3            //do nothing
1173   3          }
1174   2          Display_SET_Temp(Remeber_Temp_Value);   
1175   2        }
1176   1        else if(Key_State_Present == KEY_STATE_OK_Short)//È·ÈÏ
1177   1        {
1178   2          Sound_Short();
1179   2          if(Set_CQK_Temp != Remeber_Temp_Value)//ÈôÎ´¸Ä±äÈËÌå¶ËÎÂ¶ÈÉè¶¨Ôò²»½øÐÐ²Ù×÷
1180   2          {
1181   3            Working_Normal = 0;//¹¤×÷Ê±¼äÇåÁã
1182   3            Set_CQK_Temp=Remeber_Temp_Value;
1183   3            if(Work_Mode==Noninvasive_Mode)
1184   3            {
1185   4              Set_CQK_WCTemp=Set_CQK_Temp;
1186   4              data_flash.Set_CQK_WCTemp = (uint8_t)(Set_CQK_WCTemp/5);//ÎÞ´´Éè¶¨ÎÂ¶È                                    
1187   4            }
1188   3            else
1189   3            {
1190   4              Set_CQK_YCTemp=Set_CQK_Temp; 
1191   4              data_flash.Set_CQK_YCTemp = (uint8_t)(Set_CQK_YCTemp/5);//ÓÐ´´Éè¶¨ÎÂ¶È                                          
1192   4            } 
1193   3            
1194   3            Display_Return_Cnt = 0;
1195   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1196   3            DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1197   3            RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾ 
1198   3          }   
1199   2        }
1200   1        else
1201   1        {
1202   2          //do nothing
1203   2        }
1204   1        
1205   1        Setting_write_to_flash(); 
1206   1          
1207   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1208   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1209   1        {
1210   2          Display_Return_Cnt = 0;
1211   2        }
1212   1        if(Display_Return_Cnt < 90)
1213   1        {
1214   2          Display_Return_Cnt++;
1215   2        }
1216   1        else
1217   1        {
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 21  

1218   2          Display_Return_Cnt = 0;
1219   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1220   2          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
1221   2          RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1222   2        }
1223   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1224   1      }
1225          
1226          
1227          static uint8_t SetTimeKind = 2;//2-7//Äê/ÔÂ/ÈÕ/Ê±/·Ö/Ãë
1228          static uint8_t TempTime[7];
1229          
1230          static void EnterSetTime(void)//½øÈëÊ±¼äÉè¶¨
1231          {
1232   1        SetTimeKind = 2;
1233   1        RX8010_GetTime(TempTime); 
1234   1      //  Set_Hour_Value
1235   1      }
1236          
1237          static void  Date_Is_Correct(void)
1238          {
1239   1        uint16_t temp1;
1240   1        bit  Temp_Bit1;
1241   1        //½«BCDÂë×ª»¯Îª10½øÖÆ,Éè¶¨Ê±¼ä´Ó2000Äêµ½2099Äê======================================
1242   1        Temp_Bit1=0;
1243   1        temp1=((TempTime[6]& 0x0F)%10)+ (((TempTime[6]>>4)%10)*10);
1244   1        //ÄÜ±»4Õû³ý£¬µ«ÊÇ²»ÄÜ±»100Õû³ýÎªÈòÄê£¬»òÕßÄÜ±»400Õû³ý=====
1245   1        if((temp1%4)==0 )
1246   1        {
1247   2          Temp_Bit1=1;
1248   2        } 
1249   1        if((TempTime[4]==0x04) || (TempTime[4]==0x06) || (TempTime[4]==0x09) || (TempTime[4]==0x11))
1250   1        {
1251   2          if(TempTime[3]>0x30) 
1252   2          {
1253   3            TempTime[3]=0x30;
1254   3          }
1255   2        }
1256   1        if(Temp_Bit1) //ÈòÄê29Ìì£¬Æ½Äê28Ìì
1257   1        {
1258   2          if(TempTime[4]==2)
1259   2          {
1260   3            if(TempTime[3]>0x29)
1261   3            {
1262   4              TempTime[3]=0x29;
1263   4            }       
1264   3          }
1265   2        }else
1266   1        {
1267   2          if(TempTime[4]==2)
1268   2          {
1269   3            if(TempTime[3]>0x28)
1270   3            {
1271   4              TempTime[3]=0x28;
1272   4            }       
1273   3          }
1274   2        } 
1275   1      }
1276          
1277          //-----------ÈÕÆÚÊ±¼äÉèÖÃ½çÃæ
1278          void  HmiSetTimeFunc(void)
1279          {
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 22  

1280   1        static uint8_t Display_Return_Cnt = 0;
1281   1        static uint8_t Set_Time_Cnt=0; 
1282   1      //  uint8_t i;
1283   1      //  uint8_t color;
1284   1        
1285   1        Set_Time_Cnt++;
1286   1        if(Set_Time_Cnt > 6)
1287   1        {
1288   2          Set_Time_Cnt = 0;
1289   2        }
1290   1        
1291   1        if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1292   1        {
1293   2          SetTimeKind++;
1294   2          
1295   2          Back_Color=WHITE18; 
1296   2      //    color=BLACK18;    
1297   2          DisPlayTime(TempTime,2); //ÏÔÊ¾Ê±¼ä
1298   2          DisPlayTime(TempTime,3); //ÏÔÊ¾Ê±¼ä
1299   2          DisPlayTime(TempTime,4); //ÏÔÊ¾Ê±¼ä
1300   2          DisPlayTime(TempTime,5); //ÏÔÊ¾Ê±¼ä
1301   2          DisPlayTime(TempTime,6); //ÏÔÊ¾Ê±¼ä
1302   2          DisPlayTime(TempTime,7); //ÏÔÊ¾Ê±¼ä
1303   2          
1304   2          if(SetTimeKind > 7)
1305   2          {
1306   3            SetTimeKind = 2;
1307   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1308   3          }   
1309   2        } 
1310   1        else if((Key_State_Present == KEY_STATE_UP_Short)//UP
1311   1                ||(Key_State_Present == KEY_STATE_UP_Long_First)
1312   1                ||(Key_State_Present == KEY_STATE_UP_Long_Repeat))  
1313   1        {
1314   2          Set_Time_Cnt = 0;//Ç¿ÖÆË¢ÐÂ
1315   2          if(SetTimeKind==2) //Éè¶¨Äê·Ý
1316   2          {
1317   3            TempTime[6]++;
1318   3            if((TempTime[6]&0x0F)>=10)
1319   3            {
1320   4                 TempTime[6]=(TempTime[6]& 0xF0)+0x10;;
1321   4            }
1322   3            if(TempTime[6]>0x99)
1323   3            {
1324   4                  TempTime[6]=0x99;
1325   4            }
1326   3            Date_Is_Correct();            
1327   3      
1328   3          }else if(SetTimeKind==3) //Éè¶¨ÔÂ·Ý
1329   2          {
1330   3            TempTime[4]++;
1331   3            if((TempTime[4]&0x0F)>=10)
1332   3            {
1333   4                 TempTime[4]=(TempTime[4]& 0xF0)+0x10;
1334   4            }
1335   3            if(TempTime[4]>0x12)
1336   3            {
1337   4                  TempTime[4]=0x12;
1338   4            }
1339   3            Date_Is_Correct();
1340   3          }else if(SetTimeKind==4) //Éè¶¨ÈÕ
1341   2          {
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 23  

1342   3            TempTime[3]++;
1343   3            if((TempTime[3]&0x0F)>=10)
1344   3            {
1345   4                 TempTime[3]=(TempTime[3]& 0xF0)+0x10;
1346   4            }
1347   3            if(TempTime[3]>0x31)
1348   3            {
1349   4                  TempTime[3]=0x31;
1350   4            }
1351   3            Date_Is_Correct();  
1352   3          }else if(SetTimeKind==5) //Éè¶¨Ê±
1353   2          {
1354   3            {
1355   4              TempTime[2]++;                
1356   4              if((TempTime[2]&0x0F)>=10)
1357   4              {
1358   5                   TempTime[2]=(TempTime[2] & 0xF0)+0x10;
1359   5              }
1360   4              if(TempTime[2]>0x23)
1361   4              {
1362   5                    TempTime[2]=0x23; 
1363   5              }
1364   4            }             
1365   3          }else if(SetTimeKind==6) //Éè¶¨·Ö
1366   2          {
1367   3            TempTime[1]++;
1368   3            if((TempTime[1]&0x0F)>=10)
1369   3            {
1370   4                 TempTime[1]=(TempTime[1]& 0xF0)+0x10;
1371   4            }
1372   3            if(TempTime[1]>0x59)
1373   3            {
1374   4                  TempTime[1]=0x59;
1375   4            }
1376   3          }else if(SetTimeKind==7) //Éè¶¨Ãë
1377   2          {
1378   3            TempTime[0]++;
1379   3            if((TempTime[0]&0x0F)>=10)
1380   3            {
1381   4                 TempTime[0]=(TempTime[0]& 0xF0)+0x10;
1382   4            }
1383   3            if(TempTime[0]>0x59)
1384   3            {
1385   4                  TempTime[0]=0x59;
1386   4            }
1387   3          }
1388   2          else
1389   2          {
1390   3            //do nothing
1391   3          }
1392   2        }
1393   1        else if((Key_State_Present == KEY_STATE_Down_Short)//
1394   1               ||(Key_State_Present == KEY_STATE_Down_Long_First)
1395   1               ||(Key_State_Present == KEY_STATE_Down_Long_Repeat))
1396   1        {
1397   2          Set_Time_Cnt = 0;//Ç¿ÖÆË¢ÐÂ
1398   2          if((SetTimeKind==2) && (TempTime[6]>0x10)) //Éè¶¨Äê·Ý
1399   2          {
1400   3            TempTime[6]--;
1401   3            if((TempTime[6]&0x0F)>9)
1402   3            {
1403   4              TempTime[6]&=0xF9;
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 24  

1404   4            }       
1405   3            Date_Is_Correct();  
1406   3          }else if((SetTimeKind==3) && (TempTime[4]>1)) //Éè¶¨ÔÂ·Ý
1407   2          {
1408   3            TempTime[4]--;
1409   3            if((TempTime[4]&0x0F)>9)
1410   3            {
1411   4              TempTime[4]&=0xF9;
1412   4            }       
1413   3            Date_Is_Correct();  
1414   3          }else if((SetTimeKind==4) && (TempTime[3]>1)) //Éè¶¨ÈÕ
1415   2          {
1416   3            TempTime[3]--;
1417   3            if((TempTime[3]&0x0F)>9)
1418   3            {
1419   4              TempTime[3]&=0xF9;
1420   4            }       
1421   3          }else if((SetTimeKind==5) && (TempTime[2]>0))  //Éè¶¨Ê±
1422   2          { 
1423   3            {
1424   4              TempTime[2]--;
1425   4              if((TempTime[2]&0x0F)>9)
1426   4              {
1427   5                TempTime[2]&=0xF9;
1428   5              }           
1429   4            }
1430   3          }else if((SetTimeKind==6)  && (TempTime[1]>0)) //Éè¶¨·Ö
1431   2          {
1432   3            TempTime[1]--;
1433   3            if((TempTime[1]&0x0F)>9)
1434   3            {
1435   4              TempTime[1]&=0xF9;
1436   4            }       
1437   3          }else if((SetTimeKind==7) && (TempTime[0]>0)) //Éè¶¨Ãë
1438   2          {
1439   3            TempTime[0]--;
1440   3            if((TempTime[0]&0x0F)>9)
1441   3            {
1442   4              TempTime[0]&=0xF9;
1443   4            }       
1444   3          }
1445   2          else
1446   2          {
1447   3            //do nothing
1448   3          }
1449   2        } 
1450   1        else if(Key_State_Present == KEY_STATE_OK_Short)//
1451   1        {
1452   2          Sound_Short();
1453   2          RX8010_SetTime(TempTime);   
1454   2          Display_Return_Cnt = 0;
1455   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;    
1456   2        } 
1457   1        else
1458   1        {
1459   2          //do nothing
1460   2        }
1461   1        
1462   1      //  color = BLACK18;
1463   1        if(Set_Time_Cnt == 0)
1464   1        {
1465   2          Back_Color=GREEN18;
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 25  

1466   2        }
1467   1        else if(Set_Time_Cnt == 3)
1468   1        {
1469   2          Back_Color=WHITE18; 
1470   2        }
1471   1        else
1472   1        {
1473   2          //do nothing
1474   2        }
1475   1            
1476   1        
1477   1        if((Set_Time_Cnt == 0) ||(Set_Time_Cnt == 3))
1478   1        {
1479   2          DisPlayTime(TempTime,SetTimeKind); //ÏÔÊ¾Ê±¼ä
1480   2         }
1481   1          
1482   1        //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1483   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1484   1        {
1485   2          Display_Return_Cnt = 0;
1486   2        }
1487   1        if(Display_Return_Cnt < 90)
1488   1        {
1489   2          Display_Return_Cnt++;
1490   2        }
1491   1        else
1492   1        {
1493   2          Display_Return_Cnt = 0;
1494   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1495   2      //    DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+34*3+5,ICO_DU,BLACK18);
1496   2      //    RefreshTempHumidyFunc(1);//Ç¿ÖÆË¢ÐÂÎÂÎÂ¶ÈÏÔÊ¾   
1497   2        }
1498   1        
1499   1          
1500   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü    
1501   1      }
1502          
1503          
1504          //uint8_t  In_Exp_Ratio=4;   //InºÍExp¼ÓÈÈ·½Ê½µÄ±ÈÀý  //1-1:1 2-1:1.1 3-1:1.2 4-1:1.3 5-1:1.4 6-1:1.5
1505          static uint8_t  In_Exp_Ratio_temp=3;   //InºÍExp¼ÓÈÈ·½Ê½µÄ±ÈÀýÁÙÊ±±äÁ¿
1506          static void EnterSetInExp(void)//½øÈëInExpÉè¶¨
1507          { 
1508   1        In_Exp_Ratio_temp = In_Exp_Ratio; 
1509   1        Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);  
1510   1      }
1511          
1512          void  HmiSetInExpFunc(void)//InExpÉèÖÃ½çÃæ
1513          {
1514   1        static uint8_t Display_Return_Cnt = 0;
1515   1        static uint8_t Set_InExp_Cnt=0; 
1516   1        
1517   1        Set_InExp_Cnt++;
1518   1        if(Set_InExp_Cnt > 6)
1519   1        {
1520   2          Set_InExp_Cnt = 0;
1521   2        }
1522   1        Back_Color=WHITE18;
1523   1        if(Set_InExp_Cnt == 0)
1524   1        {
1525   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+120,16,200,"In/Exp:",0,BLACK18);
1526   2        } 
1527   1        else if(Set_InExp_Cnt == 3)
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 26  

1528   1        {
1529   2          LCD_ShowString(POS_RT_RH_X + 0,POS_RT_RH_Y+120,16,200,"In/Exp:",0,WHITE18); 
1530   2        }
1531   1        else
1532   1        {
1533   2          //do nothing
1534   2        }
1535   1            
1536   1        
1537   1        if(Key_State_Present == KEY_STATE_Mute_Short)//MUTE
1538   1        {
1539   2          Work_State = UI_STATE_SetTempPatient_MODE;
1540   2          HmiEnterToWorkStateFunc(UI_STATE_SetTempPatient_MODE);
1541   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,0);    
1542   2        }
1543   1        else if(Key_State_Present == KEY_STATE_UP_Short)//UP
1544   1        {
1545   2          if(In_Exp_Ratio_temp < 6)
1546   2          {
1547   3            In_Exp_Ratio_temp++;          
1548   3          }
1549   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);
1550   2        } 
1551   1        else if(Key_State_Present == KEY_STATE_Down_Short)//DOWN
1552   1        {
1553   2          if(In_Exp_Ratio_temp > 1)
1554   2          {
1555   3            In_Exp_Ratio_temp--;
1556   3          }
1557   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,1);
1558   2        }
1559   1        else if(Key_State_Present == KEY_STATE_OK_Short)//OK
1560   1        {
1561   2          Sound_Short();
1562   2          In_Exp_Ratio = In_Exp_Ratio_temp;
1563   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1564   2          Display_In_Exp_Ratio(In_Exp_Ratio_temp,0);  
1565   2          data_flash.In_Exp_Ratio = In_Exp_Ratio;// 
1566   2          Setting_write_to_flash();     
1567   2        } 
1568   1        else
1569   1        {
1570   2          //do nothing
1571   2        }
1572   1        
1573   1        //  Setting_write_to_flash(); 
1574   1          //ÒÔÏÂÎª10Sºó×Ô¶¯·µ»Ø 
1575   1        if((uint16_t)Key_State_Present!=(uint16_t)0)
1576   1        {
1577   2          Display_Return_Cnt = 0;
1578   2        }
1579   1        if(Display_Return_Cnt < 90)
1580   1        {
1581   2          Display_Return_Cnt++;
1582   2        }
1583   1        else
1584   1        {
1585   2          Display_Return_Cnt = 0;
1586   2          Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1587   2          Display_In_Exp_Ratio(In_Exp_Ratio,0);   
1588   2        } 
1589   1        
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 27  

1590   1        Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü    
1591   1      }
1592          
1593          
1594          //--------ÆÁ±£Ä£Ê½
1595          //¼ÆÊ±º¯Êý,·ÅÈëÖÐ¶Ï
1596          void HmiScreenSaverMode_Tik_Cnt(void)
1597          {
1598   1        if(Tik_ScreenSaver_Tick_100mS < 30000)
1599   1        {
1600   2          Tik_ScreenSaver_Tick_100mS++;
1601   2        }
1602   1      }
1603          
1604          void  HmiScreenSaverModeFunc(void)
1605          {
1606   1        uint16_t i=0;
1607   1        uint8_t DispEnable = 0;
1608   1        static uint8_t ReCnt=0;
1609   1        
1610   1      //  DispEnable = 0;
1611   1        ReCnt++;
1612   1        if(ReCnt > 10)//1S
1613   1        {
1614   2          ReCnt = 0;  
1615   2          if(Work_State == UI_STATE_SCREENSAVER_MODE)
1616   2          {
1617   3            DispEnable = 1; 
1618   3          }
1619   2        }   
1620   1        
1621   1        if(Work_State != UI_STATE_SCREENSAVER_MODE)//²»ÔÚÆÁ±£Ä£Ê½
1622   1        {
1623   2          if(Tik_ScreenSaver_Tick_100mS > 3000)//5·ÖÖÓºó½øÈëÆÁ±£Ä£Ê½
1624   2          {
1625   3            Work_State = UI_STATE_SCREENSAVER_MODE;
1626   3            LCD_LIGHT_CLOSE;
1627   3            Draw_Rectangle_Real(0,0,239,319,BLACK18);           
1628   3            DispEnable = 1; 
1629   3          }
1630   2        }
1631   1        else//ÔÚÆÁ±£Ä£Ê½
1632   1        {   
1633   2          //do nothing
1634   2        } 
1635   1        
1636   1        if(((uint16_t)Key_State_Present!=(uint16_t)0)//°´ÏÂ°´¼ü
1637   1        //»ò³öÏÖ´íÎó
1638   1              ||((ERR_Kind)!=0) //ÎÞË®,´«¸ÐÆ÷´íÎó,¸ßÎÂµÈ´íÎó
1639   1              ||(Wire_Mode_Mismatch == 1)  //·¢ÈÈË¿Î´Ñ¡¶¨
1640   1              ||(HeaterPlate_State==0))//Ë®¹ÞÎ´×°ºÃ»ò·¢ÈÈÅÌ¿ªÂ·
1641   1        {
1642   2          Key_State_Present = KEY_STATE_NONE; //Çå³ý°´¼ü  
1643   2          Tik_ScreenSaver_Tick_100mS = 0;
1644   2          DispEnable = 0;
1645   2          
1646   2          if(Work_State == UI_STATE_SCREENSAVER_MODE)//ÔÚÆÁ±£Ä£Ê½
1647   2          {
1648   3            Work_State = UI_STATE_RUNNING_NORMAL_MODE;
1649   3            HmiEnterToWorkStateFunc(UI_STATE_RUNNING_NORMAL_MODE);  
1650   3            Err_Base_HeaterWire_DISP_Enable();//ÆÁ±£Ê±ÖÃÏà¹Ø±êÖ¾,ÒÔ±ãÁÁÆÁÊ±ÏÔÊ¾Ö÷»úºÍÏßµÄÍ¼ÐÎ
1651   3          }
C51 COMPILER V9.52.0.0   GUI                                                               04/04/2019 16:21:58 PAGE 28  

1652   2        }   
1653   1          
1654   1        if(DispEnable!=(uint8_t)0)
1655   1        {
1656   2      //    DispEnable = 0;   
1657   2          Back_Color=BLACK18;
1658   2          i=Diplay_RTtemp;
1659   2          if(i>=1000)//ÏÔÊ¾ÎÂ¶È
1660   2          {
1661   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X,(i/1000)%10,GREEN18);  
1662   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X+42,(i/1000)%10,GREEN18); 
1663   3            Draw_Rectangle_Real(POS_SCREEN_Y,POS_SCREEN_X+82,POS_SCREEN_Y+8,POS_SCREEN_X +88,BLACK18);       
1664   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X +90,(i/1000)%10,GREEN18);    
1665   3            DISP_ICO_32X40(POS_SCREEN_Y,POS_SCREEN_X +133,ICO_DU,GREEN18);  
1666   3          }
1667   2          else
1668   2          {
1669   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X,(i/100)%10,GREEN18);  
1670   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X+42,(i%100)/10,GREEN18); 
1671   3            Draw_Rectangle_Real(POS_SCREEN_Y,POS_SCREEN_X+82,POS_SCREEN_Y+8,POS_SCREEN_X +88,GREEN18);       
1672   3            DISP_TEMP_38X64(POS_SCREEN_Y,POS_SCREEN_X +90,i%10,GREEN18);    
1673   3            DISP_ICO_32X40(POS_SCREEN_Y,POS_SCREEN_X +133,ICO_DU,GREEN18);             
1674   3          } 
1675   2          LCD_LIGHT_OPEN;  
1676   2        }
1677   1      }
1678          
1679          
1680          
1681          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9764    ----
   CONSTANT SIZE    =    659    ----
   XDATA SIZE       =     32     147
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
