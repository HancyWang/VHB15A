C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SHT21
OBJECT MODULE PLACED IN ..\OBJ\sht21.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\HARDWARE\sht21\sht21.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORD
                    -ER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWAR
                    -E\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\sht21.lst) TABS(2) OBJECT
                    -(..\OBJ\sht21.obj)

line level    source

   1          // #include "STC12C32AD.h"
   2           #include "all.h"
   3          // #include "sht21.h"
   4          // #include "delay.h" 
   5           //#include "lcd.h" 
   6           
   7          #define WriteCmd  0x80
   8          #define ReadCmd   0x81
   9          #define TempCmd   0xE3
  10          #define RHCmd     0xE5
  11          
  12           /***************************************************************************/
  13          
  14          #define SDA_CONF     P11
  15          #define SCL          P12
  16          #define SDA          P11
  17          #define ASK            0
  18          #define NO_ASK         1
  19          #define OUT_LOW        0
  20          //#define INPUT_HIGH     1
  21          #define SCL_INPUT_HIGH()   P1M1 |= 0x04;P1M0 &= 0xFB        //10 仅为输入
  22          #define SDA_INPUT_HIGH()   P1M1 |= 0x02;P1M0 &= 0xFD        //10 仅为输入
  23          #define SCL_OUTPUT_LOW()   P1M1 |= 0x04;P1M0 |= 0x04;SCL=OUT_LOW    //11 开漏 Set port as output for confi
             -guration
  24          #define SDA_OUTPUT_LOW()   P1M1 |= 0x02;P1M0 |= 0x02;SDA=OUT_LOW    //11 开漏 Set port as output for confi
             -guration
  25          //=============================================================
  26          
  27          
  28          static void SHT21_Start(void);
  29          static void SHT21_Stop(void);
  30          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum);
  31          static uint8_t SHT21_Write8Bit(uint8_t i_input);
  32          static uint8_t SHT21_Read8Bit(uint8_t ask);
  33          
  34          //extern uint8_t  Test_Mode_Dis_Data_Flag; //测试模式显示数据DATA的标志 外部变量
  35          
  36          
  37          //2019.03.29
  38          sfr P1M0 = 0x92; // 
  39          sfr P1M1 = 0x91;
  40          sbit P11 = 0x90^1;
  41          sbit P12 = 0x90^2;
  42          
  43          static void SHT21_Start(void)
  44          {
  45   1          SCL_INPUT_HIGH(); 
  46   1          SDA_INPUT_HIGH();
  47   1          delay_us(10);   
  48   1          SDA_OUTPUT_LOW();
  49   1          delay_us(10); //
  50   1          SCL_OUTPUT_LOW();   
C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 2   

  51   1      }
  52          
  53          
  54          static void SHT21_Stop(void)
  55           {
  56   1          SCL_OUTPUT_LOW();
  57   1          SDA_OUTPUT_LOW();   
  58   1          SCL_INPUT_HIGH();
  59   1          delay_us(10); //
  60   1          SDA_INPUT_HIGH();
  61   1          delay_us(10); //
  62   1      }
  63          
  64          
  65          /***************************************************************************/
  66          /***************************************************************************/
  67          static uint8_t SHT21_Write8Bit(uint8_t i_input)
  68          {
  69   1          uint16_t  i;
  70   1      
  71   1          for(i=(uint16_t)0x80; i>0; i>>=1)           //shift bit for masking (8 times)
  72   1          {
  73   2            SCL_OUTPUT_LOW();
  74   2            if((i &(uint8_t)i_input)!=(uint8_t)0)
  75   2            { 
  76   3              SDA_INPUT_HIGH();
  77   3            }     
  78   2            else
  79   2            { 
  80   3              SDA_OUTPUT_LOW(); //masking txByte, write bit to SDA-Line
  81   3            }              
  82   2      
  83   2            delay_us(10);                        //data set-up time (t_SU;DAT)
  84   2            SCL_INPUT_HIGH();                                //generate clock pulse on SCL
  85   2            delay_us(10);                        //SCL input_high time (t_HIGH)
  86   2          }
  87   1          SCL_OUTPUT_LOW();
  88   1          delay_us(10); 
  89   1          SDA_INPUT_HIGH();                       //release SDA-line
  90   1        
  91   1          SCL_INPUT_HIGH();                       //clk #9 for ack
  92   1          delay_us(10);                         //data set-up time (t_SU;DAT)
  93   1          
  94   1          i = 0;
  95   1          while(SDA_CONF)
  96   1          {
  97   2            if(++i>2400){SCL_OUTPUT_LOW();return(1);}
  98   2          }
  99   1          SCL_OUTPUT_LOW();
 100   1          return 0;
 101   1      }
 102          
 103          /***************************************************************************/
 104          static uint8_t SHT21_Read8Bit(uint8_t ask)
 105          {
 106   1          uint8_t  mask,rxByte=0;     
 107   1      
 108   1          SDA_INPUT_HIGH(); //release SDA-line
 109   1      
 110   1          for (mask=0x80; mask>0; mask>>=1) //shift bit for masking (8 times)
 111   1          {
 112   2            SCL_INPUT_HIGH();                   //sht21_start clock on SCL-line
C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 3   

 113   2            delay_us(10);                     //SCL input_high time (t_HIGH)
 114   2            if (SDA_CONF==1) 
 115   2            {
 116   3              rxByte=(rxByte | mask); //read bit
 117   3            }
 118   2            SCL_OUTPUT_LOW();
 119   2            delay_us(10);                     //data hold time(t_HD;DAT)
 120   2          }
 121   1          if(ask!=(uint8_t)0)
 122   1          {
 123   2            SDA_INPUT_HIGH();
 124   2          }
 125   1          else
 126   1          {
 127   2            SDA_OUTPUT_LOW();
 128   2          }                      //send acknowledge if necessary
 129   1          delay_us(10);                       //data set-up time (t_SU;DAT)
 130   1          SCL_INPUT_HIGH();                     //clk #9 for ack
 131   1          delay_us(10);                       //SCL input_high time (t_HIGH)
 132   1          SCL_OUTPUT_LOW();
 133   1          delay_us(10);
 134   1          SDA_INPUT_HIGH();                      //release SDA-line
 135   1          SDA_OUTPUT_LOW();
 136   1          delay_us(10);   
 137   1          return  rxByte;
 138   1      }
 139          
 140          
 141          
 142          /***************************************************************************/
 143          uint8_t SHT21_WriteTemp(void)
 144          {
 145   1        uint8_t  Read_SHT21_Err;
 146   1        SHT21_Start();
 147   1        Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 148   1        Read_SHT21_Err=SHT21_Write8Bit(TempCmd);
 149   1        SHT21_Start();
 150   1        Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 151   1        SCL_INPUT_HIGH();    // set SCL I/O port as input 
 152   1      
 153   1        return Read_SHT21_Err;
 154   1      }
 155          
 156          uint8_t SHT21_WriteRH(void)
 157          {
 158   1        uint8_t  Read_SHT21_Err;
 159   1        SHT21_Start();
 160   1        Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 161   1        Read_SHT21_Err=SHT21_Write8Bit(RHCmd);
 162   1        SHT21_Start();
 163   1        Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 164   1        SCL_INPUT_HIGH(); // set SCL I/O port as input
 165   1        
 166   1      
 167   1          return Read_SHT21_Err;
 168   1      }
 169          
 170          
 171          
 172          //// 打开或关闭SHT21内部加热功能
 173          //void  SHT21_Heater_On_Off(uint8_t Heater_State)
 174          //{
C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 4   

 175          //  uint8_t  Read_SHT21_Err;
 176          //  uint8_t UserReg;
 177          //  SHT21_Start();
 178          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd); 
 179          //  Read_SHT21_Err = SHT21_Write8Bit(0xE7);  *读用户寄存器指令
 180          //  SHT21_Start();
 181          //  Read_SHT21_Err = SHT21_Write8Bit(0x81); 
 182          //  UserReg =  SHT21_Read8Bit(NO_ASK);//读取用户寄存器
 183          //  UserReg &= 0x38;//保留3-4-5预留位
 184          //  UserReg |= 0x02;//不能启动OTP加载，RH 12bit T 14bit
 185          //  if(Heater_State)
 186          //  {
 187          //    UserReg |= 0x04;//启动片上加热器  
 188          //  } 
 189          
 190          //  SHT21_Start();
 191          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd);
 192          //  Read_SHT21_Err = SHT21_Write8Bit(0xE6);  //写用户寄存器指令
 193          //  Read_SHT21_Err = SHT21_Write8Bit(UserReg);   //写用户寄存器指令
 194          //  SHT21_Stop();
 195          //}
 196          
 197          
 198          
 199          /***************************************************************************/
 200          //返回SHT21_ERROR --- 未收到正确的数据
 201          //返回温度数据
 202          //返回湿度数据
 203          uint16_t SHT21_ReadData(void)
 204          {
 205   1        uint8_t TempH,TempL;
 206   1        UINT32  TempLong; 
 207   1        u8t  checksum;   //checksum
 208   1          u8t  Cdata[2];    //data array for checksum verification
 209   1        u8t  CRC8_error;   //checksum
 210   1      
 211   1        TempH=SHT21_Read8Bit(ASK);
 212   1        //delay_us(50);
 213   1          TempL=SHT21_Read8Bit(ASK);
 214   1        //delay_us(50);
 215   1        checksum=SHT21_Read8Bit(NO_ASK); //读到CRC8数据
 216   1        //checksum+=1;   //测试CRC
 217   1        SHT21_Stop();
 218   1      
 219   1        Cdata[0] =  TempH;
 220   1        Cdata[1] =  TempL;
 221   1        CRC8_error = SHT2x_CheckCrc(Cdata,2,checksum);
 222   1        if(CRC8_error == CHECKSUM_ERROR)//
 223   1        {
 224   2          return SHT21_ERROR;//CRC校验失败
 225   2        }
 226   1      
 227   1        TempLong=TempH;
 228   1        TempLong=(TempLong<<8)+(TempL & 0xFC);
 229   1      
 230   1      //  if(Work_State == UI_STATE_SERVICE_MODE)
 231   1        {
 232   2      
 233   2        ////   LCD_ShowxNum(150,220,24,3,TempH,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 234   2        ////   LCD_ShowxNum(150,268,24,3,TempL,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 235   2        }
 236   1        
C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 5   

 237   1        //if(TempL& 0x01==0x01) return SHT21_ERROR;
 238   1        if(TempLong==0x0)
 239   1        {
 240   2          return SHT21_ERROR;//数据为0
 241   2        }   
 242   1      
 243   1        if((TempL&0x02)==0x0)  //温度
 244   1        {
 245   2           TempLong=((1757*TempLong)>>16)-468; 
 246   2           //if(TempLong > 1250)  return SHT21_ERROR; //温度不能超过125
 247   2           //else 
 248   2          return  TempLong;
 249   2      
 250   2        }
 251   1        else  //湿度
 252   1        {
 253   2          TempLong=((1250*TempLong)>>16)-60;
 254   2          //if(TempLong > 1000) return SHT21_ERROR;  //湿度不能超过100
 255   2          //else//20141228发现错误
 256   2          
 257   2          TempLong |= 0x8000;//区别温度和湿度数据,温度最高位为1
 258   2          return  TempLong; 
 259   2        }
 260   1      } 
 261          
 262          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum)
 263          //==============================================================================
 264          {
 265   1        u8t crc = 0;  
 266   1        u8t byteCtr;
 267   1        u8t bit8;
 268   1        //calculates 8-Bit checksum with given polynomial
 269   1        for (byteCtr = 0; byteCtr < nbrOfBytes; ++byteCtr)
 270   1        { 
 271   2          crc ^= (Cdata[byteCtr]);
 272   2          for (bit8 = 8; bit8 > 0; --bit8)
 273   2          {
 274   3      //    if (crc & 0x80) crc = (crc << 1) ^ POLYNOMIAL;
 275   3      //      else crc = (crc << 1);
 276   3            if ((crc & (u8t)0x80)!=(u8t)0)
 277   3            {
 278   4              crc = (u8t)((crc << 1) ^ POLYNOMIAL);
 279   4            }       
 280   3            else
 281   3            {
 282   4              crc = (uint8_t)((crc << 1));
 283   4            }       
 284   3          }
 285   2        }
 286   1        if(crc != checksum) 
 287   1        {
 288   2          return CHECKSUM_ERROR;
 289   2        }
 290   1        else
 291   1        {
 292   2          return 0;
 293   2        }   
 294   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    877    ----
C51 COMPILER V9.52.0.0   SHT21                                                             04/04/2019 16:21:58 PAGE 6   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
