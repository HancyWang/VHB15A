C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SHT21
OBJECT MODULE PLACED IN ..\OBJ\sht21.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\sht21\sht21.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE O
                    -RDER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDW
                    -ARE\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\sht21.lst) TABS(2) OBJE
                    -CT(..\OBJ\sht21.obj)

line level    source

   1           #include "STC12C32AD.h"
   2           #include "all.h"
   3          // #include "sht21.h"
   4          // #include "delay.h" 
   5           //#include "lcd.h" 
   6           
   7          #define WriteCmd  0x80
   8          #define ReadCmd   0x81
   9          #define TempCmd   0xE3
  10          #define RHCmd     0xE5
  11          
  12           /***************************************************************************/
  13          
  14          #define SDA_CONF     P11
  15          #define SCL          P12
  16          #define SDA          P11
  17          #define ASK            0
  18          #define NO_ASK         1
  19          #define OUT_LOW        0
  20          //#define INPUT_HIGH     1
  21          //#define SCL_INPUT_HIGH()   P1M1 |= 0x04;P1M0 &= 0xFB        //10 仅为输入
  22          //#define SDA_INPUT_HIGH()   P1M1 |= 0x02;P1M0 &= 0xFD        //10 仅为输入
  23          //#define SCL_OUTPUT_LOW()   P1M1 |= 0x04;P1M0 |= 0x04;SCL=OUT_LOW    //11 开漏 Set port as output for con
             -figuration
  24          //#define SDA_OUTPUT_LOW()   P1M1 |= 0x02;P1M0 |= 0x02;SDA=OUT_LOW    //11 开漏 Set port as output for con
             -figuration
  25          //=============================================================
  26          
  27          
  28          
  29          
  30          static void SHT21_Start(void);
  31          static void SHT21_Stop(void);
  32          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum);
  33          static uint8_t SHT21_Write8Bit(uint8_t i_input);
  34          static uint8_t SHT21_Read8Bit(uint8_t ask);
  35          
  36          //extern uint8_t  Test_Mode_Dis_Data_Flag; //测试模式显示数据DATA的标志 外部变量
  37          
  38          
  39          ////2019.03.29
  40          //sfr P1M0 = 0x92; // 
  41          //sfr P1M1 = 0x91;
  42          //sbit P11 = (u8)0x90^(u8)1;
  43          //sbit P12 = (u8)0x90^(u8)2;
  44          
  45          
  46          static void SCL_INPUT_HIGH(void)
  47          {
  48   1        P1M1 |= (u8)0x04;
  49   1        P1M0 &= (u8)0xFB;       //10 仅为输入
  50   1      }
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 2   

  51          
  52          static void SDA_INPUT_HIGH(void)
  53          {
  54   1        P1M1 |= (u8)0x02;
  55   1        P1M0 &= (u8)0xFD; 
  56   1      } 
  57          static void SCL_OUTPUT_LOW(void)
  58          {
  59   1        P1M1 |= (u8)0x04;
  60   1        P1M0 |= (u8)0x04;
  61   1        SCL=(bit)OUT_LOW;
  62   1      }
  63          static void SDA_OUTPUT_LOW(void)
  64          {
  65   1        P1M1 |= (u8)0x02;
  66   1        P1M0 |= (u8)0x02;
  67   1        SDA=(bit)OUT_LOW;
  68   1      }
  69          
  70          static void SHT21_Start(void)
  71          {
  72   1          SCL_INPUT_HIGH(); 
  73   1          SDA_INPUT_HIGH();
  74   1          delay_us(10);   
  75   1          SDA_OUTPUT_LOW();
  76   1          delay_us(10); //
  77   1          SCL_OUTPUT_LOW();   
  78   1      }
  79          
  80          
  81          static void SHT21_Stop(void)
  82           {
  83   1          SCL_OUTPUT_LOW();
  84   1          SDA_OUTPUT_LOW();   
  85   1          SCL_INPUT_HIGH();
  86   1          delay_us(10); //
  87   1          SDA_INPUT_HIGH();
  88   1          delay_us(10); //
  89   1      }
  90          
  91          
  92          /***************************************************************************/
  93          /***************************************************************************/
  94          static uint8_t SHT21_Write8Bit(uint8_t i_input)
  95          {
  96   1          uint16_t  i;
  97   1          uint8_t ret=0;
  98   1      
  99   1          for(i=(uint16_t)0x80; i>(u16)0; i>>=1)           //shift bit for masking (8 times)
 100   1          {
 101   2            SCL_OUTPUT_LOW();
 102   2            if((i &(uint8_t)i_input)!=(uint8_t)0)
 103   2            { 
 104   3              SDA_INPUT_HIGH();
 105   3            }     
 106   2            else
 107   2            { 
 108   3              SDA_OUTPUT_LOW(); //masking txByte, write bit to SDA-Line
 109   3            }              
 110   2      
 111   2            delay_us(10);                        //data set-up time (t_SU;DAT)
 112   2            SCL_INPUT_HIGH();                                //generate clock pulse on SCL
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 3   

 113   2            delay_us(10);                        //SCL input_high time (t_HIGH)
 114   2          }
 115   1          SCL_OUTPUT_LOW();
 116   1          delay_us(10); 
 117   1          SDA_INPUT_HIGH();                       //release SDA-line
 118   1        
 119   1          SCL_INPUT_HIGH();                       //clk #9 for ack
 120   1          delay_us(10);                         //data set-up time (t_SU;DAT)
 121   1          
 122   1          i = 0;
 123   1          while(SDA_CONF)
 124   1          {
 125   2            if(++i>(u16)2400){SCL_OUTPUT_LOW();ret=(uint8_t)1;break;}
 126   2          }
 127   1      //    SCL_OUTPUT_LOW();
 128   1      //    return (uint8_t)0;
 129   1          if(ret==(uint8_t)0)
 130   1          {
 131   2            SCL_OUTPUT_LOW();
 132   2          }
 133   1          
 134   1          return ret;
 135   1      }
 136          
 137          /***************************************************************************/
 138          static uint8_t SHT21_Read8Bit(uint8_t ask)
 139          {
 140   1          uint8_t  mask,rxByte=0;     
 141   1      
 142   1          SDA_INPUT_HIGH(); //release SDA-line
 143   1      
 144   1          for (mask=(u8)0x80; mask>(u8)0; mask>>=1) //shift bit for masking (8 times)
 145   1          {
 146   2            SCL_INPUT_HIGH();                   //sht21_start clock on SCL-line
 147   2            delay_us(10);                     //SCL input_high time (t_HIGH)
 148   2            if (SDA_CONF) 
 149   2            {
 150   3              rxByte=(rxByte | mask); //read bit
 151   3            }
 152   2            SCL_OUTPUT_LOW();
 153   2            delay_us(10);                     //data hold time(t_HD;DAT)
 154   2          }
 155   1          if(ask!=(uint8_t)0)
 156   1          {
 157   2            SDA_INPUT_HIGH();
 158   2          }
 159   1          else
 160   1          {
 161   2            SDA_OUTPUT_LOW();
 162   2          }                      //send acknowledge if necessary
 163   1          delay_us(10);                       //data set-up time (t_SU;DAT)
 164   1          SCL_INPUT_HIGH();                     //clk #9 for ack
 165   1          delay_us(10);                       //SCL input_high time (t_HIGH)
 166   1          SCL_OUTPUT_LOW();
 167   1          delay_us(10);
 168   1          SDA_INPUT_HIGH();                      //release SDA-line
 169   1          SDA_OUTPUT_LOW();
 170   1          delay_us(10);   
 171   1          return  rxByte;
 172   1      }
 173          
 174          
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 4   

 175          
 176          /***************************************************************************/
 177          uint8_t SHT21_WriteTemp(void)
 178          {
 179   1        uint8_t  Read_SHT21_Err;
 180   1        SHT21_Start();
 181   1      //  Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 182   1      //  Read_SHT21_Err=SHT21_Write8Bit(TempCmd);
 183   1        if(SHT21_Write8Bit(WriteCmd)==(u8)1)
 184   1        {
 185   2          Read_SHT21_Err=(u8)1;
 186   2        }
 187   1        else
 188   1        {
 189   2          Read_SHT21_Err=(u8)0;
 190   2        }
 191   1        if(SHT21_Write8Bit(TempCmd)==(u8)1)
 192   1        {
 193   2          Read_SHT21_Err=(u8)1;
 194   2        }
 195   1        else
 196   1        {
 197   2          Read_SHT21_Err=(u8)0;
 198   2        }
 199   1        SHT21_Start();
 200   1      //  Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 201   1        if(SHT21_Write8Bit(ReadCmd)==(u8)1)
 202   1        {
 203   2          Read_SHT21_Err=(u8)1;
 204   2        }
 205   1        else
 206   1        {
 207   2          Read_SHT21_Err=(u8)0;
 208   2        }
 209   1        SCL_INPUT_HIGH();    // set SCL I/O port as input 
 210   1      
 211   1        return Read_SHT21_Err;
 212   1      }
 213          
 214          uint8_t SHT21_WriteRH(void)
 215          {
 216   1        uint8_t  Read_SHT21_Err;
 217   1        SHT21_Start();
 218   1      //  Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 219   1      //  Read_SHT21_Err=SHT21_Write8Bit(RHCmd);
 220   1        if(SHT21_Write8Bit(WriteCmd)==(u8)1)
 221   1        {
 222   2          Read_SHT21_Err=(u8)1;
 223   2        }
 224   1        else
 225   1        {
 226   2          Read_SHT21_Err=(u8)0;
 227   2        }
 228   1        if(SHT21_Write8Bit(RHCmd)==(u8)1)
 229   1        {
 230   2          Read_SHT21_Err=(u8)1;
 231   2        }
 232   1        else
 233   1        {
 234   2          Read_SHT21_Err=(u8)0;
 235   2        }
 236   1        SHT21_Start();
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 5   

 237   1      //  Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 238   1        if(SHT21_Write8Bit(ReadCmd)==(u8)1)
 239   1        {
 240   2          Read_SHT21_Err=(u8)1;
 241   2        }
 242   1        else
 243   1        {
 244   2          Read_SHT21_Err=(u8)0;
 245   2        }
 246   1        SCL_INPUT_HIGH(); // set SCL I/O port as input
 247   1        
 248   1      
 249   1        return Read_SHT21_Err;
 250   1      }
 251          
 252          
 253          
 254          //// 打开或关闭SHT21内部加热功能
 255          //void  SHT21_Heater_On_Off(uint8_t Heater_State)
 256          //{
 257          //  uint8_t  Read_SHT21_Err;
 258          //  uint8_t UserReg;
 259          //  SHT21_Start();
 260          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd); 
 261          //  Read_SHT21_Err = SHT21_Write8Bit(0xE7);  *读用户寄存器指令
 262          //  SHT21_Start();
 263          //  Read_SHT21_Err = SHT21_Write8Bit(0x81); 
 264          //  UserReg =  SHT21_Read8Bit(NO_ASK);//读取用户寄存器
 265          //  UserReg &= 0x38;//保留3-4-5预留位
 266          //  UserReg |= 0x02;//不能启动OTP加载，RH 12bit T 14bit
 267          //  if(Heater_State)
 268          //  {
 269          //    UserReg |= 0x04;//启动片上加热器  
 270          //  } 
 271          
 272          //  SHT21_Start();
 273          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd);
 274          //  Read_SHT21_Err = SHT21_Write8Bit(0xE6);  //写用户寄存器指令
 275          //  Read_SHT21_Err = SHT21_Write8Bit(UserReg);   //写用户寄存器指令
 276          //  SHT21_Stop();
 277          //}
 278          
 279          
 280          
 281          /***************************************************************************/
 282          //返回SHT21_ERROR --- 未收到正确的数据
 283          //返回温度数据
 284          //返回湿度数据
 285          uint16_t SHT21_ReadData(void)
 286          {
 287   1        uint8_t TempH,TempL;
 288   1        UINT32  TempLong; 
 289   1        u8t  checksum;   //checksum
 290   1          u8t  Cdata[2];    //data array for checksum verification
 291   1        u8t  CRC8_error;   //checksum
 292   1        uint8_t tmp=0;
 293   1        uint16_t ret=0;
 294   1      
 295   1        TempH=SHT21_Read8Bit(ASK);
 296   1        //delay_us(50);
 297   1          TempL=SHT21_Read8Bit(ASK);
 298   1        //delay_us(50);
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 6   

 299   1        checksum=SHT21_Read8Bit(NO_ASK); //读到CRC8数据
 300   1        //checksum+=1;   //测试CRC
 301   1        SHT21_Stop();
 302   1      
 303   1        Cdata[0] =  TempH;
 304   1        Cdata[1] =  TempL;
 305   1        CRC8_error = SHT2x_CheckCrc(Cdata,2,checksum);
 306   1        if(CRC8_error == (u8)CHECKSUM_ERROR)//
 307   1        {
 308   2      //    return SHT21_ERROR;//CRC校验失败
 309   2          ret=(uint16_t)SHT21_ERROR;
 310   2        }
 311   1        else
 312   1        {
 313   2          TempLong=TempH;
 314   2        //  TempLong=(TempLong<<8)+(UINT32)(TempL & (uint8_t)0xFC);
 315   2          TempLong<<=(UINT32)8;
 316   2          tmp=(TempL & (uint8_t)0xFC);
 317   2          TempLong+=(UINT32)tmp;
 318   2      
 319   2        //  if(Work_State == UI_STATE_SERVICE_MODE)
 320   2          {
 321   3      
 322   3          ////   LCD_ShowxNum(150,220,24,3,TempH,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 323   3          ////   LCD_ShowxNum(150,268,24,3,TempL,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 324   3          }
 325   2          
 326   2          //if(TempL& 0x01==0x01) return SHT21_ERROR;
 327   2          if(TempLong==(UINT32)0x0)
 328   2          {
 329   3      //      return SHT21_ERROR;//数据为0
 330   3            ret=(uint16_t)SHT21_ERROR;
 331   3          }
 332   2          else
 333   2          {
 334   3            if((TempL&(uint8_t)0x02)==(u8)0x0)  //温度
 335   3            {
 336   4              TempLong=(((UINT32)1757*TempLong)>>16)-(UINT32)468; 
 337   4              //if(TempLong > 1250) return SHT21_ERROR; //温度不能超过125
 338   4              //else 
 339   4              //        return  TempLong;
 340   4              ret=(uint16_t)TempLong;
 341   4      
 342   4            }
 343   3            else  //湿度
 344   3            {
 345   4              TempLong=(((UINT32)1250*TempLong)>>16)-(UINT32)60;
 346   4              //if(TempLong > 1000) return SHT21_ERROR;  //湿度不能超过100
 347   4              //else//20141228发现错误
 348   4              
 349   4              TempLong |= (UINT32)0x8000;//区别温度和湿度数据,温度最高位为1
 350   4      //        return  TempLong;
 351   4              ret=(uint16_t)TempLong;       
 352   4            }
 353   3          }
 354   2        }
 355   1        return ret;
 356   1      } 
 357          
 358          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum)
 359          //==============================================================================
 360          {
C51 COMPILER V9.59.0.0   SHT21                                                             04/19/2019 09:13:59 PAGE 7   

 361   1        u8t crc = 0;  
 362   1        u8t byteCtr;
 363   1        u8t bit8;
 364   1        uint16_t tmp=0;
 365   1        uint8_t res=0;
 366   1        //calculates 8-Bit checksum with given polynomial
 367   1        for (byteCtr = 0; byteCtr < nbrOfBytes; ++byteCtr)
 368   1        { 
 369   2          crc ^= (Cdata[byteCtr]);
 370   2          for (bit8 = 8; bit8 > (u8)0; --bit8)
 371   2          {
 372   3        //    if (crc & 0x80) crc = (crc << 1) ^ POLYNOMIAL;
 373   3        //      else crc = (crc << 1);
 374   3            if ((crc & (u8t)0x80)!=(u8t)0)
 375   3            {
 376   4        //        crc = (u8t)((uint16_t)(crc << 1) ^ (uint16_t)POLYNOMIAL);
 377   4              crc<<=(uint16_t)1;
 378   4              tmp=(crc ^ (uint16_t)POLYNOMIAL);
 379   4              crc = (u8t)tmp;
 380   4            }       
 381   3            else
 382   3            {
 383   4              crc = (uint8_t)((crc << 1));
 384   4            }       
 385   3          }
 386   2        }
 387   1        if(crc != checksum) 
 388   1        {
 389   2          res=(uint8_t)CHECKSUM_ERROR;
 390   2        }
 391   1        else
 392   1        {
 393   2          res=(uint8_t)0;
 394   2        } 
 395   1        return res;
 396   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1065    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
