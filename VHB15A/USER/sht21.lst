C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE SHT21
OBJECT MODULE PLACED IN ..\OBJ\sht21.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\sht21\sht21.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE O
                    -RDER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDW
                    -ARE\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\sht21.lst) TABS(2) OBJE
                    -CT(..\OBJ\sht21.obj)

line level    source

   1          // #include "STC12C32AD.h"
   2           #include "all.h"
   3          // #include "sht21.h"
   4          // #include "delay.h" 
   5           //#include "lcd.h" 
   6           
   7          #define WriteCmd  0x80
   8          #define ReadCmd   0x81
   9          #define TempCmd   0xE3
  10          #define RHCmd     0xE5
  11          
  12           /***************************************************************************/
  13          
  14          #define SDA_CONF     P11
  15          #define SCL          P12
  16          #define SDA          P11
  17          #define ASK            0
  18          #define NO_ASK         1
  19          #define OUT_LOW        0
  20          //#define INPUT_HIGH     1
  21          //#define SCL_INPUT_HIGH()   P1M1 |= 0x04;P1M0 &= 0xFB        //10 仅为输入
  22          //#define SDA_INPUT_HIGH()   P1M1 |= 0x02;P1M0 &= 0xFD        //10 仅为输入
  23          //#define SCL_OUTPUT_LOW()   P1M1 |= 0x04;P1M0 |= 0x04;SCL=OUT_LOW    //11 开漏 Set port as output for con
             -figuration
  24          //#define SDA_OUTPUT_LOW()   P1M1 |= 0x02;P1M0 |= 0x02;SDA=OUT_LOW    //11 开漏 Set port as output for con
             -figuration
  25          //=============================================================
  26          
  27          
  28          
  29          
  30          static void SHT21_Start(void);
  31          static void SHT21_Stop(void);
  32          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum);
  33          static uint8_t SHT21_Write8Bit(uint8_t i_input);
  34          static uint8_t SHT21_Read8Bit(uint8_t ask);
  35          
  36          //extern uint8_t  Test_Mode_Dis_Data_Flag; //测试模式显示数据DATA的标志 外部变量
  37          
  38          
  39          //2019.03.29
  40          sfr P1M0 = 0x92; // 
  41          sfr P1M1 = 0x91;
  42          sbit P11 = (u8)0x90^(u8)1;
  43          sbit P12 = (u8)0x90^(u8)2;
  44          
  45          
  46          static void SCL_INPUT_HIGH(void)
  47          {
  48   1        P1M1 |= (u8)0x04;
  49   1        P1M0 &= (u8)0xFB;       //10 仅为输入
  50   1      }
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 2   

  51          
  52          static void SDA_INPUT_HIGH(void)
  53          {
  54   1        P1M1 |= (u8)0x02;
  55   1        P1M0 &= (u8)0xFD; 
  56   1      } 
  57          static void SCL_OUTPUT_LOW(void)
  58          {
  59   1        P1M1 |= (u8)0x04;
  60   1        P1M0 |= (u8)0x04;
  61   1        SCL=(bit)OUT_LOW;
  62   1      }
  63          static void SDA_OUTPUT_LOW(void)
  64          {
  65   1        P1M1 |= (u8)0x02;
  66   1        P1M0 |= (u8)0x02;
  67   1        SDA=(bit)OUT_LOW;
  68   1      }
  69          
  70          static void SHT21_Start(void)
  71          {
  72   1          SCL_INPUT_HIGH(); 
  73   1          SDA_INPUT_HIGH();
  74   1          delay_us(10);   
  75   1          SDA_OUTPUT_LOW();
  76   1          delay_us(10); //
  77   1          SCL_OUTPUT_LOW();   
  78   1      }
  79          
  80          
  81          static void SHT21_Stop(void)
  82           {
  83   1          SCL_OUTPUT_LOW();
  84   1          SDA_OUTPUT_LOW();   
  85   1          SCL_INPUT_HIGH();
  86   1          delay_us(10); //
  87   1          SDA_INPUT_HIGH();
  88   1          delay_us(10); //
  89   1      }
  90          
  91          
  92          /***************************************************************************/
  93          /***************************************************************************/
  94          static uint8_t SHT21_Write8Bit(uint8_t i_input)
  95          {
  96   1          uint16_t  i;
  97   1          uint8_t ret=0;
  98   1      
  99   1          for(i=(uint16_t)0x80; i>(u16)0; i>>=1)           //shift bit for masking (8 times)
 100   1          {
 101   2            SCL_OUTPUT_LOW();
 102   2            if((i &(uint8_t)i_input)!=(uint8_t)0)
 103   2            { 
 104   3              SDA_INPUT_HIGH();
 105   3            }     
 106   2            else
 107   2            { 
 108   3              SDA_OUTPUT_LOW(); //masking txByte, write bit to SDA-Line
 109   3            }              
 110   2      
 111   2            delay_us(10);                        //data set-up time (t_SU;DAT)
 112   2            SCL_INPUT_HIGH();                                //generate clock pulse on SCL
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 3   

 113   2            delay_us(10);                        //SCL input_high time (t_HIGH)
 114   2          }
 115   1          SCL_OUTPUT_LOW();
 116   1          delay_us(10); 
 117   1          SDA_INPUT_HIGH();                       //release SDA-line
 118   1        
 119   1          SCL_INPUT_HIGH();                       //clk #9 for ack
 120   1          delay_us(10);                         //data set-up time (t_SU;DAT)
 121   1          
 122   1          i = 0;
 123   1          while(SDA_CONF)
 124   1          {
 125   2            if(++i>(u16)2400){SCL_OUTPUT_LOW();ret=(uint8_t)1;break;}
 126   2          }
 127   1      //    SCL_OUTPUT_LOW();
 128   1      //    return (uint8_t)0;
 129   1          if(ret==(uint8_t)0)
 130   1          {
 131   2            SCL_OUTPUT_LOW();
 132   2          }
 133   1          
 134   1          return ret;
 135   1      }
 136          
 137          /***************************************************************************/
 138          static uint8_t SHT21_Read8Bit(uint8_t ask)
 139          {
 140   1          uint8_t  mask,rxByte=0;     
 141   1      
 142   1          SDA_INPUT_HIGH(); //release SDA-line
 143   1      
 144   1          for (mask=(u8)0x80; mask>(u8)0; mask>>=1) //shift bit for masking (8 times)
 145   1          {
 146   2            SCL_INPUT_HIGH();                   //sht21_start clock on SCL-line
 147   2            delay_us(10);                     //SCL input_high time (t_HIGH)
 148   2            if (SDA_CONF==1) 
 149   2            {
 150   3              rxByte=(rxByte | mask); //read bit
 151   3            }
 152   2            SCL_OUTPUT_LOW();
 153   2            delay_us(10);                     //data hold time(t_HD;DAT)
 154   2          }
 155   1          if(ask!=(uint8_t)0)
 156   1          {
 157   2            SDA_INPUT_HIGH();
 158   2          }
 159   1          else
 160   1          {
 161   2            SDA_OUTPUT_LOW();
 162   2          }                      //send acknowledge if necessary
 163   1          delay_us(10);                       //data set-up time (t_SU;DAT)
 164   1          SCL_INPUT_HIGH();                     //clk #9 for ack
 165   1          delay_us(10);                       //SCL input_high time (t_HIGH)
 166   1          SCL_OUTPUT_LOW();
 167   1          delay_us(10);
 168   1          SDA_INPUT_HIGH();                      //release SDA-line
 169   1          SDA_OUTPUT_LOW();
 170   1          delay_us(10);   
 171   1          return  rxByte;
 172   1      }
 173          
 174          
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 4   

 175          
 176          /***************************************************************************/
 177          uint8_t SHT21_WriteTemp(void)
 178          {
 179   1        uint8_t  Read_SHT21_Err;
 180   1        SHT21_Start();
 181   1        Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 182   1        Read_SHT21_Err=SHT21_Write8Bit(TempCmd);
 183   1        SHT21_Start();
 184   1        Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 185   1        SCL_INPUT_HIGH();    // set SCL I/O port as input 
 186   1      
 187   1        return Read_SHT21_Err;
 188   1      }
 189          
 190          uint8_t SHT21_WriteRH(void)
 191          {
 192   1        uint8_t  Read_SHT21_Err;
 193   1        SHT21_Start();
 194   1        Read_SHT21_Err=SHT21_Write8Bit(WriteCmd);
 195   1        Read_SHT21_Err=SHT21_Write8Bit(RHCmd);
 196   1        SHT21_Start();
 197   1        Read_SHT21_Err=SHT21_Write8Bit(ReadCmd);
 198   1        SCL_INPUT_HIGH(); // set SCL I/O port as input
 199   1        
 200   1      
 201   1          return Read_SHT21_Err;
 202   1      }
 203          
 204          
 205          
 206          //// 打开或关闭SHT21内部加热功能
 207          //void  SHT21_Heater_On_Off(uint8_t Heater_State)
 208          //{
 209          //  uint8_t  Read_SHT21_Err;
 210          //  uint8_t UserReg;
 211          //  SHT21_Start();
 212          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd); 
 213          //  Read_SHT21_Err = SHT21_Write8Bit(0xE7);  *读用户寄存器指令
 214          //  SHT21_Start();
 215          //  Read_SHT21_Err = SHT21_Write8Bit(0x81); 
 216          //  UserReg =  SHT21_Read8Bit(NO_ASK);//读取用户寄存器
 217          //  UserReg &= 0x38;//保留3-4-5预留位
 218          //  UserReg |= 0x02;//不能启动OTP加载，RH 12bit T 14bit
 219          //  if(Heater_State)
 220          //  {
 221          //    UserReg |= 0x04;//启动片上加热器  
 222          //  } 
 223          
 224          //  SHT21_Start();
 225          //  Read_SHT21_Err = SHT21_Write8Bit(WriteCmd);
 226          //  Read_SHT21_Err = SHT21_Write8Bit(0xE6);  //写用户寄存器指令
 227          //  Read_SHT21_Err = SHT21_Write8Bit(UserReg);   //写用户寄存器指令
 228          //  SHT21_Stop();
 229          //}
 230          
 231          
 232          
 233          /***************************************************************************/
 234          //返回SHT21_ERROR --- 未收到正确的数据
 235          //返回温度数据
 236          //返回湿度数据
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 5   

 237          uint16_t SHT21_ReadData(void)
 238          {
 239   1        uint8_t TempH,TempL;
 240   1        UINT32  TempLong; 
 241   1        u8t  checksum;   //checksum
 242   1          u8t  Cdata[2];    //data array for checksum verification
 243   1        u8t  CRC8_error;   //checksum
 244   1        uint8_t tmp=0;
 245   1        uint16_t ret=0;
 246   1      
 247   1        TempH=SHT21_Read8Bit(ASK);
 248   1        //delay_us(50);
 249   1          TempL=SHT21_Read8Bit(ASK);
 250   1        //delay_us(50);
 251   1        checksum=SHT21_Read8Bit(NO_ASK); //读到CRC8数据
 252   1        //checksum+=1;   //测试CRC
 253   1        SHT21_Stop();
 254   1      
 255   1        Cdata[0] =  TempH;
 256   1        Cdata[1] =  TempL;
 257   1        CRC8_error = SHT2x_CheckCrc(Cdata,2,checksum);
 258   1        if(CRC8_error == (u8)CHECKSUM_ERROR)//
 259   1        {
 260   2      //    return SHT21_ERROR;//CRC校验失败
 261   2          ret=(uint16_t)SHT21_ERROR;
 262   2        }
 263   1        else
 264   1        {
 265   2          TempLong=TempH;
 266   2        //  TempLong=(TempLong<<8)+(UINT32)(TempL & (uint8_t)0xFC);
 267   2          TempLong<<=(UINT32)8;
 268   2          tmp=(TempL & (uint8_t)0xFC);
 269   2          TempLong+=(UINT32)tmp;
 270   2      
 271   2        //  if(Work_State == UI_STATE_SERVICE_MODE)
 272   2          {
 273   3      
 274   3          ////   LCD_ShowxNum(150,220,24,3,TempH,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 275   3          ////   LCD_ShowxNum(150,268,24,3,TempL,0x80,BLACK18); //8表示高位为0也显示,0表示非叠加显示
 276   3          }
 277   2          
 278   2          //if(TempL& 0x01==0x01) return SHT21_ERROR;
 279   2          if(TempLong==(UINT32)0x0)
 280   2          {
 281   3      //      return SHT21_ERROR;//数据为0
 282   3            ret=(uint16_t)SHT21_ERROR;
 283   3          }
 284   2          else
 285   2          {
 286   3            if((TempL&(uint8_t)0x02)==(u8)0x0)  //温度
 287   3            {
 288   4              TempLong=(((UINT32)1757*TempLong)>>16)-(UINT32)468; 
 289   4              //if(TempLong > 1250) return SHT21_ERROR; //温度不能超过125
 290   4              //else 
 291   4              //        return  TempLong;
 292   4              ret=(uint16_t)TempLong;
 293   4      
 294   4            }
 295   3            else  //湿度
 296   3            {
 297   4              TempLong=(((UINT32)1250*TempLong)>>16)-(UINT32)60;
 298   4              //if(TempLong > 1000) return SHT21_ERROR;  //湿度不能超过100
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 6   

 299   4              //else//20141228发现错误
 300   4              
 301   4              TempLong |= (UINT32)0x8000;//区别温度和湿度数据,温度最高位为1
 302   4      //        return  TempLong;
 303   4              ret=(uint16_t)TempLong;       
 304   4            }
 305   3          }
 306   2        }
 307   1        return ret;
 308   1      } 
 309          
 310          static u8t SHT2x_CheckCrc(const u8t Cdata[], u8t nbrOfBytes, u8t checksum)
 311          //==============================================================================
 312          {
 313   1        u8t crc = 0;  
 314   1        u8t byteCtr;
 315   1        u8t bit8;
 316   1        uint16_t tmp=0;
 317   1        uint8_t res=0;
 318   1        //calculates 8-Bit checksum with given polynomial
 319   1        for (byteCtr = 0; byteCtr < nbrOfBytes; ++byteCtr)
 320   1        { 
 321   2          crc ^= (Cdata[byteCtr]);
 322   2          for (bit8 = 8; bit8 > (u8)0; --bit8)
 323   2          {
 324   3        //    if (crc & 0x80) crc = (crc << 1) ^ POLYNOMIAL;
 325   3        //      else crc = (crc << 1);
 326   3            if ((crc & (u8t)0x80)!=(u8t)0)
 327   3            {
 328   4        //        crc = (u8t)((uint16_t)(crc << 1) ^ (uint16_t)POLYNOMIAL);
 329   4              crc<<=(uint16_t)1;
 330   4              tmp=(crc ^ (uint16_t)POLYNOMIAL);
 331   4              crc = (u8t)tmp;
 332   4            }       
 333   3            else
 334   3            {
 335   4              crc = (uint8_t)((crc << 1));
 336   4            }       
 337   3          }
 338   2        }
 339   1        if(crc != checksum) 
 340   1        {
 341   2          res=(uint8_t)CHECKSUM_ERROR;
 342   2        }
 343   1        else
 344   1        {
 345   2          res=(uint8_t)0;
 346   2        } 
 347   1        return res;
 348   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    921    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   SHT21                                                             04/11/2019 16:15:51 PAGE 7   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
