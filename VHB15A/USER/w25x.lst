C51 COMPILER V9.59.0.0   W25X                                                              04/19/2019 09:13:59 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE W25X
OBJECT MODULE PLACED IN ..\OBJ\w25x.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\w25x\w25x.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORD
                    -ER NOAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWAR
                    -E\sht31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\w25x.lst) TABS(2) OBJECT(
                    -..\OBJ\w25x.obj)

line level    source

   1           #include "STC12C32AD.h"
   2           #include "all.h"
   3          // #include "w25x.h"
   4          // #include "lcd.h"
   5          // #include "INTRINS.H" 
   6          
   7          //#define   W25X_WP    P1^3;
   8          #define   W25X_CS   P45
   9          #define   W25X_DI   P44
  10          #define   W25X_DO   P42
  11          #define   W25X_CLK  P41
  12          
  13          #define W25X_WriteEnable      0x06
  14          #define W25X_WriteDisable     0x04
  15          //#define W25X_ReadStatusReg    0x05
  16          //#define W25X_WriteStatusReg   0x01
  17          #define W25X_ReadData         0x03
  18          //#define W25X_FastReadData     0x0B
  19          //#define W25X_FastReadDual     0x3B
  20          #define W25X_PageProgram      0x02
  21          //#define W25X_BlockErase       0xD8
  22          #define W25X_SectorErase      0x20
  23          //#define W25X_ChipErase        0xC7
  24          //#define W25X_PowerDown        0xB9
  25          //#define W25X_ReleasePowerDown 0xAB
  26          //#define W25X_DeviceID         0xAB
  27          //#define W25X_ManufactDeviceID 0x90
  28          //#define W25X_JedecDeviceID    0x9F
  29          
  30          //#define nop() _nop_()
  31          
  32          
  33          ////2019.03.30
  34          //sbit P17 = (u8)0x90^(u8)7;
  35          //sbit P41 = (u8)0xC0^(u8)1;
  36          //sbit P42 = (u8)0xC0^(u8)2;
  37          //sbit P44 = (u8)0xC0^(u8)4;
  38          //sbit P45 = (u8)0xC0^(u8)5;
  39                      
  40          //unsigned char Read_Data; 
  41          
  42          void    SPI_Write_Enable() //写使能
  43          {   W25X_CS = (bit)0;                            //  enable device
  44   1         SPI_Send_Byte(W25X_WriteEnable);        //  send W25X_Write_Enable command
  45   1         W25X_CS = (bit)1;                            //  disable device
  46   1      }
  47          void    SPI_Write_Disable() //写禁止
  48          {
  49   1         W25X_CS = (bit)0;                            //  enable device
  50   1         SPI_Send_Byte(W25X_WriteDisable);       //  send W25X_WriteW25X_DIsable command
  51   1         W25X_CS = (bit)1;                            //  disable device
  52   1      }
C51 COMPILER V9.59.0.0   W25X                                                              04/19/2019 09:13:59 PAGE 2   

  53          
  54          //void nop(void)
  55          //{
  56          //  _nop_();
  57          //}
  58          // 
  59          //读N个字节
  60          //起始地址
  61          //读字节的个数,最多128
  62          //存放的地址
  63          void   SPI_Read_nBytes(uint32 Dst_Addr, uchar nBytes_128,uchar * Read_Adr)
  64          {
  65   1        uchar i = 0;
  66   1        LCD_1DIR_H;
  67   1        W25X_CS = (bit)0;                                        //  enable device
  68   1        SPI_Send_Byte(W25X_ReadData);                       //  read command
  69   1        SPI_Send_Byte((u8)((Dst_Addr & (uint32)0xFFFFFF) >> 16));       //  send 3 address bytes
  70   1        SPI_Send_Byte((u8)((Dst_Addr & (uint32)0xFFFF) >> 8));
  71   1        SPI_Send_Byte((u8)(Dst_Addr & (uint32)0xFF));
  72   1        // SPI_Send_Byte(0xFF);                                //  dummy byte
  73   1        for (; i < nBytes_128; i++)                     //  read until no_bytes is reached
  74   1        {
  75   2          Read_Adr[i] = SPI_Get_Byte();                  //  receive byte and store at address 80H - FFH
  76   2        }
  77   1           
  78   1        W25X_CS = (bit)1;                                         //  disable device
  79   1        LCD_1DIR_L;
  80   1      }
  81          
  82          //写N个字节
  83          //起始地址
  84          //写字节的个数,最多128
  85          //存放的地址
  86           void    SPI_Write_nBytes(uint32 Dst_Addr, uchar nBytes_128,const uchar * Data_Adr)
  87          {
  88   1        uchar i, byte;
  89   1        W25X_CS = (bit)0;                    /* enable device */
  90   1        SPI_Write_Enable();             /* set WEL */
  91   1        W25X_CS = (bit)0;
  92   1        SPI_Send_Byte(W25X_PageProgram);        /* send Byte Program command */
  93   1        SPI_Send_Byte((u8)((Dst_Addr & (uint32)0xFFFFFF) >> 16)); /* send 3 address bytes */
  94   1        SPI_Send_Byte((u8)((Dst_Addr & (uint32)0xFFFF) >> 8));
  95   1        SPI_Send_Byte((u8)(Dst_Addr & (uint32)0xFF));
  96   1        for (i = 0; i < nBytes_128; i++)
  97   1        {
  98   2          //         byte = *(Data_Adr+i);
  99   2          byte = Data_Adr[i];
 100   2          SPI_Send_Byte(byte);        /* send byte to be programmed */
 101   2        }
 102   1        W25X_CS = (bit)1;                /* disable device */
 103   1      }
 104          
 105           //初始化
 106           void    SPI_init()
 107           {
 108   1         W25X_CLK = (bit)0;                         //  set clock to low initial state for SPI operation mode 0
 109   1           W25X_CS = (bit)1;
 110   1           _nop_();_nop_(); _nop_();_nop_();
 111   1           SPI_Write_Disable();
 112   1       }
 113          
 114           //发送一个字节
C51 COMPILER V9.59.0.0   W25X                                                              04/19/2019 09:13:59 PAGE 3   

 115           void    SPI_Send_Byte(uchar out)
 116          {
 117   1        uchar i = 0;
 118   1        uchar OUT=out;
 119   1        for (; i < (u8)8; i++)
 120   1        {
 121   2          if ((OUT & (uchar)0x80) == (uchar)0x80)           //  check if MSB is high
 122   2          {
 123   3            W25X_DI = (bit)1;
 124   3          }
 125   2          else
 126   2          {
 127   3            W25X_DI = (bit)0;                    //  if not, set to low
 128   3          }
 129   2            
 130   2      
 131   2          W25X_CLK = (bit)1;                       //  toggle clock high
 132   2          OUT = (uint8_t)(OUT << 1);                   //  shift 1 place for next bit
 133   2          _nop_();_nop_(); _nop_();_nop_();
 134   2          W25X_CLK = (bit)0;                       //  toggle clock low
 135   2        }
 136   1      }
 137          
 138          //读取一个字节
 139          uchar   SPI_Get_Byte(void)
 140          {
 141   1        uchar i = 0, in = 0;
 142   1        uchar temp;
 143   1        for (; i < (u8)8; i++)
 144   1        {
 145   2          in = (uint8_t)(in << 1);                      //  shift 1 place to the left or shift in 0
 146   2      //    temp = W25X_DO;                      //  save input
 147   2          if(W25X_DO)
 148   2          {
 149   3            temp=(uchar)1;
 150   3          }
 151   2          else
 152   2          {
 153   3            temp=(uchar)0;
 154   3          }
 155   2          W25X_CLK = (bit)1; 
 156   2          _nop_();                              //  toggle clock high
 157   2          if (temp==(uchar)1)                        //  check to see if bit is high
 158   2          {
 159   3            in |= (uchar)0x01;                     //  if high, make bit high
 160   3          }
 161   2             
 162   2          _nop_();
 163   2          _nop_();
 164   2          _nop_(); 
 165   2          _nop_(); 
 166   2          W25X_CLK = (bit)0;                       //  toggle clock low
 167   2        }
 168   1        return in;
 169   1      }
 170          
 171           //擦除指定的扇区
 172           void    SPI_Erase_Sector(uint32 Dst_Addr)
 173           {
 174   1         W25X_CS = (bit)0;                                        //  enable device
 175   1           SPI_Write_Enable();                                 //  set WEL
 176   1           W25X_CS = (bit)0;
C51 COMPILER V9.59.0.0   W25X                                                              04/19/2019 09:13:59 PAGE 4   

 177   1           SPI_Send_Byte(W25X_SectorErase);                    //  send Sector Erase command
 178   1           SPI_Send_Byte((uchar)((Dst_Addr & (uint32)0xFFFFFF) >> 16));//    send 3 address bytes
 179   1           SPI_Send_Byte((uchar)((Dst_Addr & (uint32)0xFFFF) >> 8));
 180   1           SPI_Send_Byte((uchar)(Dst_Addr & (uint32)0xFF));
 181   1           W25X_CS = (bit)1;                                        //  disable device
 182   1       }
 183          
 184          //读取SPI_FLASH的状态寄存器
 185          //BIT7  6   5   4   3   2   1   0
 186          //SPR   RV  TB BP2 BP1 BP0 WEL BUSY
 187          //SPR:默认0,状态寄存器保护位,配合WP使用
 188          //TB,BP2,BP1,BP0:FLASH区域写保护设置
 189          //WEL:写使能锁定
 190          //BUSY:忙标记位(1,忙;0,空闲)
 191          //默认:0x00
 192          //uchar SPI_Flash_ReadSR(void)   
 193          //{  
 194          //  uchar byte=0;   
 195          //  W25X_CS=0;                            //使能器件 
 196          //  SPI_Send_Byte(W25X_ReadStatusReg);    //发送读取状态寄存器命令 
 197          //  LCD_1DIR_H;
 198          //  byte=SPI_Get_Byte();             //读取一个字节  
 199          //  LCD_1DIR_L;
 200          //  W25X_CS=1;                            //取消片选     
 201          //  return byte;   
 202          //}
 203          
 204          
 205          ////等待空闲
 206          //void SPI_Flash_Wait_Busy(void)   
 207          //{   
 208          //  while((SPI_Flash_ReadSR()&0x01)==0x01);   // 等待BUSY位清空
 209          //}  
 210          
 211          ////擦除整个芯片      
 212          ////等待时间超长...
 213          //void SPI_Flash_Erase_Chip(void)   
 214          //{                                   
 215          //    SPI_Write_Enable();                     //SET WEL 
 216          //    SPI_Flash_Wait_Busy();   
 217          //    W25X_CS=0;                            //使能器件   
 218          //    SPI_Send_Byte(W25X_ChipErase);        //发送片擦除命令  
 219          //  W25X_CS=1;                            //取消片选            
 220          //  SPI_Flash_Wait_Busy();             //等待芯片擦除结束
 221          //}   
 222          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    420    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
