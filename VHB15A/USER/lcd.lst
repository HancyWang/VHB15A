C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN ..\OBJ\lcd.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\HARDWARE\lcd\lcd.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER N
                    -OAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sh
                    -t31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\lcd.lst) TABS(2) OBJECT(..\OB
                    -J\lcd.obj)

line level    source

   1          #include "delay.h"
   2          #include "lcd.h"
   3          #include "Font.h"
   4          #include "all.h"
   5          
   6          uint8_t  xdata  Back_Color;
   7          
   8          //2019.03.29
   9          sfr P0   = 0x80;
  10          sbit P14 = 0x90^4;
  11          sbit P15 = 0x90^5;
  12          sbit P16 = 0x90^6;
  13          sbit P40 = 0xC0^0;
  14          sbit P46 = 0xC0^6;
  15          
  16          static uint16_t code Table_Color[]=
  17          {
  18            RED,
  19            GREEN,
  20            BLUE,
  21            WHITE, 
  22            BLACK , 
  23            GRAY,  
  24            YELLOW ,
  25            BRIGHT_BLUE,
  26            AIR_BLUE,
  27            PURPLE,
  28            BLACKRED   
  29          };
  30          
  31          
  32          static void SdCmd(uint8_t data8)   //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  33          {
  34   1        LCD_RS_L;
  35   1        LCD_PORT =data8;
  36   1        LCD_CS_L;
  37   1        LCD_WR_L;
  38   1        LCD_WR_H;
  39   1        LCD_CS_H;
  40   1      }
  41          
  42          
  43          static void SdData(uint8_t data8)  //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  44          {
  45   1        LCD_RS_H;
  46   1        LCD_PORT =data8;
  47   1        LCD_CS_L;
  48   1        LCD_WR_L;
  49   1        LCD_WR_H;
  50   1        LCD_CS_H;
  51   1      }
  52          
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 2   

  53          void LCD_CtrlWrite_ILI9328(uint16_t i)
  54          {
  55   1        LCD_CS_L;
  56   1        LCD_RS_H;
  57   1        LCD_PORT =i/256;
  58   1        LCD_WR_L;
  59   1        LCD_WR_H;
  60   1        LCD_PORT =i%256;
  61   1        LCD_WR_L;
  62   1        LCD_WR_H;
  63   1        LCD_RS_H;
  64   1        LCD_CS_H;
  65   1      }
  66          
  67          void   LCD_CtrlWrite_Color(uint8_t color)
  68          {
  69   1         LCD_CtrlWrite_ILI9328(Table_Color[color]);
  70   1      }
  71          
  72          void LCD_Initial(void)
  73          {
  74   1       
  75   1        LCD_RST_L;
  76   1        delay_ms(20); // Delay 1ms
  77   1        LCD_RST_H;
  78   1        delay_ms(800); // Delay 10ms // This delay time is necessary
  79   1        
  80   1        SdCmd(0x11);//Wake up
  81   1        delay_ms(120); //Delay 120ms
  82   1        SdCmd(0x35);SdData(0x00);//TE ON   60Hz
  83   1            
  84   1        SdCmd(0x36);
  85   1        SdData(0x00); //RTN
  86   1        SdCmd(0x21); //黑白反相  
  87   1      
  88   1        SdCmd(0xb2);  //Porch setting
  89   1        SdData(0x0c);
  90   1        SdData(0x0c);
  91   1        SdData(0x00);
  92   1        SdData(0x33);
  93   1        SdData(0x33);
  94   1      
  95   1        SdCmd(0xb7);  //Gate Control
  96   1        SdData(0x35); //VGH=13.26V, VGL=-10.43V
  97   1      
  98   1        SdCmd(0xbb); //vcom setting
  99   1        SdData(0x19);
 100   1      
 101   1        SdCmd(0xc0); //LCM Control
 102   1        SdData(0x2c);
 103   1      
 104   1        SdCmd(0xc2);  //VDV and VRH Command Enable  
 105   1        SdData(0x01);
 106   1      
 107   1        SdCmd(0xc3); //VRH Set, VAP(GVDD) & VAN(GVCL)
 108   1        SdData(0x1d); 
 109   1      
 110   1        SdCmd(0xc4);  //VDV Set, 
 111   1        SdData(0x20); //VDV=0V
 112   1      
 113   1        SdCmd(0xc6);//Frame rate control in normal mode
 114   1        SdData(0x0f);//dot inversion & 60Hz
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 3   

 115   1      
 116   1        SdCmd(0xd0);   //Power control 1
 117   1        SdData(0xa4);
 118   1        SdData(0xa1); //AVDD=6.8V; AVCL=-4.8V; VDDS=2.3V
 119   1      
 120   1        SdCmd(0xe8);
 121   1        SdData(0x83);
 122   1      //--------------------------------ST7789VI gamma setting---------------------------------------//
 123   1        SdCmd(0xe0);
 124   1        SdData(0xd2);
 125   1        SdData(0x11);
 126   1        SdData(0x16);
 127   1        SdData(0x0d);
 128   1        SdData(0x0d);
 129   1        SdData(0x38);
 130   1        SdData(0x3d);
 131   1        SdData(0x44);
 132   1        SdData(0x4c);
 133   1        SdData(0x1c);
 134   1        SdData(0x15);
 135   1        SdData(0x15);
 136   1        SdData(0x1c);
 137   1        SdData(0x20);
 138   1      
 139   1      
 140   1        SdCmd(0xe1);
 141   1        SdData(0xd2);
 142   1        SdData(0x11);
 143   1        SdData(0x16);
 144   1        SdData(0x0d);
 145   1        SdData(0x0d);
 146   1        SdData(0x38);
 147   1        SdData(0x3d);
 148   1        SdData(0x44);
 149   1        SdData(0x4c);
 150   1        SdData(0x1c);
 151   1        SdData(0x15);
 152   1        SdData(0x15);
 153   1        SdData(0x1c);
 154   1        SdData(0x20);
 155   1      
 156   1        SdCmd(0x3a);SdData(0x55); // 8/16bit,65k colors
 157   1        SdCmd(0x29);             //Display on
 158   1      
 159   1        delay_ms(10);
 160   1      
 161   1        SdCmd(0x2a);
 162   1        SdData(0x00);
 163   1        SdData(0x00);
 164   1        SdData(0x00);
 165   1        SdData(0xEF);
 166   1      
 167   1        SdCmd(0x2b);
 168   1        SdData(0x00);
 169   1        SdData(0x00);
 170   1        SdData(0x01);
 171   1        SdData(0x3F);
 172   1      
 173   1        delay_ms(120);
 174   1        SdCmd(0x2c);
 175   1      }
 176          
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 4   

 177          void  LCD_CrtlWrite_Area(uint8_t SX,uint8_t EX,uint16_t SY,uint16_t EY)
 178          {
 179   1           SdCmd(0x2A);
 180   1           SdData(SX/256);
 181   1           SdData(SX%256);
 182   1           SdData(EX/256);
 183   1           SdData(EX%256);
 184   1           SdCmd(0x2B);
 185   1           SdData(SY/256);
 186   1           SdData(SY%256);
 187   1           SdData(EY/256);
 188   1           SdData(EY%256);
 189   1           SdCmd(0x2C); 
 190   1      }  
 191          
 192          
 193           //画矩形
 194          void Draw_Rectangle(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color, uint8_t
             - LineW)
 195          {
 196   1           uint16_t i,j,w,h;
 197   1           w=End_X-Start_X;
 198   1           h=End_Y-Start_Y;
 199   1           //画第一条线
 200   1           LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,Start_Y+LineW-1);
 201   1           for (j=0; j<LineW;j++)
 202   1           {
 203   2             for(i=0;i<=w;i++)
 204   2             {
 205   3                LCD_CtrlWrite_Color(color);
 206   3             }
 207   2           }
 208   1           LCD_CrtlWrite_Area(Start_X,End_X,End_Y-LineW+1,End_Y);
 209   1           for (j=0; j<LineW;j++)
 210   1           {
 211   2             for(i=0;i<=w;i++)
 212   2             {
 213   3                  LCD_CtrlWrite_Color(color);
 214   3             }
 215   2           }
 216   1           LCD_CrtlWrite_Area(Start_X,Start_X+LineW-1,Start_Y,End_Y);
 217   1           for (j=0; j<=h;j++)
 218   1           {
 219   2             for(i=0;i<LineW;i++)
 220   2             {
 221   3                 LCD_CtrlWrite_Color(color);
 222   3             }
 223   2           }
 224   1           LCD_CrtlWrite_Area(End_X-LineW+1,End_X,Start_Y,End_Y);
 225   1           for (j=0; j<=h;j++)
 226   1           {
 227   2             for(i=0;i<LineW;i++)
 228   2             {
 229   3                LCD_CtrlWrite_Color(color);
 230   3             }
 231   2           }
 232   1       }
 233          
 234           //画实体方块
 235          void Draw_Rectangle_Real(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color)
 236          {
 237   1           uint16_t i,j,w,h;
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 5   

 238   1           w=End_X-Start_X;
 239   1           h=End_Y-Start_Y;
 240   1           LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,End_Y);
 241   1           for (j=0; j<=h;j++)
 242   1           {
 243   2             for(i=0;i<=w;i++)
 244   2             {
 245   3                    LCD_CtrlWrite_Color(color);
 246   3      
 247   3             }
 248   2           }
 249   1      }
 250          
 251          //显示单色图形
 252          //X-坐标 0-239
 253          //Y-坐标 0-319
 254          //H-高   2-200
 255          //W-宽   1-100
 256          //gp 字符地址
 257          //NUM-图形编号
 258          //color-颜色
 259          static void DISP_MONO_GRAP(uint8_t  X1, uint16_t Y1,uint8_t  H, uint8_t  W, uint8_t *gp,uint8_t color)
 260          {
 261   1           uint16_t w,j;
 262   1           LCD_CrtlWrite_Area(X1,X1+H-1,Y1,Y1+W-1);
 263   1           for(w=0;w<(int)H*(int)W/8;w++)
 264   1           {
 265   2             for(j=0;j<8;j++)
 266   2             {
 267   3               if((gp[w]&(0x01<<j))!=0)
 268   3                  LCD_CtrlWrite_Color(color);
 269   3               else
 270   3                  LCD_CtrlWrite_Color(Back_Color);
 271   3              }
 272   2           }
 273   1      }
 274          
 275          
 276          void DISP_TEMP_30X56(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 277          {
 278   1        DISP_MONO_GRAP(X,Y,56,30,NUM30X56[NUM],color);
 279   1      }
 280          
 281          void DISP_TEMP_38X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 282          {
 283   1        DISP_MONO_GRAP(X,Y,64,38,NUM38X64[NUM],color);
 284   1      }
 285          
 286          void DISP_CQK25X24(uint8_t  X, uint16_t Y,uint8_t color)
 287          {
 288   1        DISP_MONO_GRAP(X,Y,24,25,CQK25X24,color);
 289   1      }
 290          
 291          void DISP_RTD28X24(uint8_t  X, uint16_t Y,uint8_t color)
 292          {
 293   1        DISP_MONO_GRAP(X,Y,24,28,RTD28X24,color);
 294   1      }
 295          
 296          void DISP_JQK41X16(uint8_t  X, uint16_t Y,uint8_t color)
 297          {
 298   1        DISP_MONO_GRAP(X,Y,16,41,JQK41X16,color);
 299   1      }
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 6   

 300          
 301          
 302          
 303          void DISP_HEAT_36X24(uint8_t  X, uint16_t Y,uint8_t color)
 304          {
 305   1           DISP_MONO_GRAP(X,Y,24,36,HEAT36X32,color);
 306   1      }
 307          
 308          void DISP_RH_17X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 309          {
 310   1        DISP_MONO_GRAP(X,Y,40,17,NUM17X40[NUM],color);
 311   1      }
 312          
 313          void DISP_FNT10X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 314          {
 315   1        DISP_MONO_GRAP(X,Y,24,10,FNT10X24[NUM],color);
 316   1      }
 317          
 318          void DISP_RH14X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 319          {
 320   1        DISP_MONO_GRAP(X,Y,24,14,RH14X24[NUM],color);
 321   1      }
 322          
 323          void DISP_TIME_10X16(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 324          {
 325   1        DISP_MONO_GRAP(X,Y,16,10,NUM10X16[NUM],color);
 326   1      }
 327          void DISP_ICO_32X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 328          {
 329   1        DISP_MONO_GRAP(X,Y,40,32,ICO32X40[NUM],color);  
 330   1      }
 331          
 332          void DISP_ICO_40X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 333          {
 334   1        DISP_MONO_GRAP(X,Y,40,40,ICO40X40[NUM],color);
 335   1      }
 336          
 337          
 338          
 339          void DISP_ICO_52X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 340          {
 341   1        DISP_MONO_GRAP(X,Y,48,48,ICO48X48[NUM],color);  
 342   1      }
 343          
 344          
 345          void DISP_DHM(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 346          {
 347   1        DISP_MONO_GRAP(X,Y,16,14,DHM14X16[NUM],color);
 348   1      }  
 349          
 350          void DISP_VHB80_56X40(uint8_t  X, uint16_t Y,uint8_t color)
 351          {
 352   1        DISP_MONO_GRAP(X,Y,40,56,VHB8056X40,color);
 353   1      }
 354          
 355          
 356          void Disp_YouChuang(uint8_t  X, uint16_t Y,uint8_t color) //80,71
 357          {
 358   1        DISP_MONO_GRAP(X,Y,80,71,PIC_YouChuang,color); 
 359   1      }
 360          
 361          void Disp_WuChuang(uint8_t  X, uint16_t Y,uint8_t color)   //
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 7   

 362          {
 363   1        DISP_MONO_GRAP(X,Y,80,71,PIC_WuChuang,color);
 364   1      }
 365          
 366          void DISP_VHB80_PIC(uint8_t color)
 367          { 
 368   1        DISP_VHB80_56X40(POS_VHB80_X,POS_VHB80_Y,color);
 369   1        DISP_HEAT_36X24(POS_HEAT_X,POS_HEAT_Y,color);    //加热盘图形    
 370   1        DISP_CQK25X24(POS_CQK_X,POS_CQK_Y,color);
 371   1        Draw_Rectangle_Real(POS_XQGS_X1,POS_XQGS_Y1,POS_XQGS_X2,POS_XQGS_Y2,color);  //画吸气管上部，下部
 372   1        Draw_Rectangle_Real(POS_XQGX_X1,POS_XQGX_Y1,POS_XQGX_X2,POS_XQGX_Y2,color); 
 373   1        DISP_RTD28X24(POS_RTD_X,POS_RTD_Y,color);    
 374   1        Draw_Rectangle_Real(POS_CQGS_X1,POS_CQGS_Y1,POS_CQGS_X2,POS_CQGS_Y2,color);  //画出气管上部，下部
 375   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGX_X2,POS_CQGX_Y2,color); ;  //画出气管上部，下部
 376   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGS_X2,POS_CQGX_Y1+1,color);  //画封口 
 377   1        DISP_JQK41X16(POS_JQK_X,POS_JQK_Y,color);     //画进气口
 378   1      }
 379          
 380          
 381          //画点
 382          //x,y:坐标
 383          //POINT_COLOR:此点的颜色
 384          static void LCD_DrawPoint(u16 x,u16 y,uint8_t color)
 385          { 
 386   1        SdCmd(0x2A);;  //设置光标位置 
 387   1        SdData(x/256);    //开始点的X坐标
 388   1        SdData(x%256);
 389   1        SdData(x/256);
 390   1        SdData(x%256);     
 391   1        SdCmd(0x2B);
 392   1        SdData(y/256);  //开始点的Y坐标    
 393   1        SdData(y%256);     
 394   1        SdData(y/256);       
 395   1        SdData(y%256);
 396   1        SdCmd(0x2C);    
 397   1        LCD_CtrlWrite_Color(color); //开始写入GRAM
 398   1      }
 399          
 400          //*  画点的方式
 401          //显示16*8 ASC字符  
 402          //X座标 0-239
 403          //Y座标 0-319
 404          //NUM字符
 405          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 406          //color字符的颜色 
 407           void DISP_FNT8X16(u16  X, u16 Y,u8 NUM,u8 mode,u8 color)
 408          {
 409   1           uint16_t  w,j;
 410   1           uint16_t F_x,F_y;
 411   1      
 412   1           F_x = X;
 413   1           F_y = Y;  
 414   1      
 415   1          LCD_CrtlWrite_Area(X,X+15,Y,Y+7);
 416   1      
 417   1           NUM=NUM-' ';//得到偏移后的值      
 418   1           for(w=0;w<8;w++)
 419   1           {
 420   2             for(j=0;j<8;j++)
 421   2             {
 422   3               if((asc2_1608[NUM][w*2+1]&(0x01<<j))!=0)
 423   3             {
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 8   

 424   4              if(mode == 0)
 425   4                LCD_CtrlWrite_Color(color); //快速写
 426   4              else
 427   4                    LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 428   4              
 429   4             }
 430   3               else
 431   3                  {
 432   4                if(mode == 0)
 433   4                    LCD_CtrlWrite_Color(Back_Color);
 434   4                }
 435   3             F_x++;       
 436   3             } 
 437   2             for(j=0;j<8;j++)
 438   2             {
 439   3               if((asc2_1608[NUM][w*2]&(0x01<<j))!=0)
 440   3                {
 441   4              if(mode == 0)
 442   4                LCD_CtrlWrite_Color(color); //快速写
 443   4              else
 444   4                    LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 445   4              
 446   4             }
 447   3               else
 448   3                  {
 449   4                if(mode == 0)
 450   4                    LCD_CtrlWrite_Color(Back_Color);
 451   4                }
 452   3             F_x++;       
 453   3             }
 454   2             F_y++; 
 455   2             F_x = X; 
 456   2          } 
 457   1      }
 458          
 459          //*  画点的方式 可以显示叠加方式
 460          //显示24*12 ASC字符  
 461          //X座标 0-239
 462          //Y座标 0-319
 463          //NUM字符
 464          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色 速度快，画框方式
 465          //color字符的颜色 
 466           void DISP_FNT12X24(u16 X, u16 Y,u8 NUM,u8 mode,u8 color)
 467          {
 468   1           uint16_t  w,j;
 469   1           uint16_t F_x,F_y;     
 470   1      
 471   1           F_x = X;
 472   1           F_y = Y;
 473   1      
 474   1           LCD_CrtlWrite_Area(X,X+23,Y,Y+11);
 475   1      
 476   1           NUM=NUM-' ';//得到偏移后的值      
 477   1           for(w=0;w<12;w++)
 478   1           {
 479   2               for(j=0;j<8;j++)
 480   2             {
 481   3               if((asc2_2412[NUM][w*3+2]&(0x01<<j))!=0)
 482   3             {
 483   4              if(mode == 0)
 484   4                LCD_CtrlWrite_Color(color); //快速写
 485   4              else
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 9   

 486   4                    LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 487   4              
 488   4             }
 489   3               else
 490   3                  {
 491   4                if(mode == 0)
 492   4                    LCD_CtrlWrite_Color(Back_Color);
 493   4                }
 494   3              F_x++;  
 495   3              
 496   3             } 
 497   2             for(j=0;j<8;j++)
 498   2             {
 499   3               if((asc2_2412[NUM][w*3+1]&(0x01<<j))!=0)
 500   3               {
 501   4              if(mode == 0)
 502   4                LCD_CtrlWrite_Color(color); //快速写
 503   4              else
 504   4                    LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 505   4              
 506   4             }
 507   3               else
 508   3                  {
 509   4                if(mode == 0)
 510   4                    LCD_CtrlWrite_Color(Back_Color);
 511   4                }
 512   3              F_x++;
 513   3              
 514   3             } 
 515   2             for(j=0;j<8;j++)
 516   2             {
 517   3               if((asc2_2412[NUM][w*3]&(0x01<<j))!=0)
 518   3               {
 519   4              if(mode == 0)
 520   4                LCD_CtrlWrite_Color(color); //快速写
 521   4              else
 522   4                    LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 523   4              
 524   4             }
 525   3               else
 526   3                  {
 527   4                if(mode == 0)
 528   4                    LCD_CtrlWrite_Color(Back_Color);
 529   4                }
 530   3               F_x++;
 531   3      
 532   3             }  
 533   2             F_y++; 
 534   2             F_x = X; 
 535   2          } 
 536   1      }
 537          
 538          //在指定位置显示一个字符
 539          //x,y:起始坐标
 540          //size:字体大小 16/24
 541          //num:要显示的字符:" "--->"~" 
 542          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 543          //color:
 544          void LCD_ShowChar(u16 x,u16 y,u8 size,u8 num,u8 mode,u8 color)
 545          {                 
 546   1          
 547   1        //设置窗口
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 10  

 548   1        if(size == 16)
 549   1                DISP_FNT8X16(x,y,num,mode,color);
 550   1          else if(size == 24)
 551   1                DISP_FNT12X24(x,y,num,mode,color); 
 552   1      }  
 553          
 554          
 555          //显示16*8 或24*12 ASC字符
 556          //x,y:起点坐标
 557          //height_x  字高度，也是字号,如16表示16*8，24表示24*12
 558          //width_y: 文字的最大长度，以免超出范围，最大是320 
 559          //*p:字符串起始地址
 560          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 561          //字符的颜色
 562          void LCD_ShowString(u16 x, u16 y,u16 height_x,u16 width_y, u8 *p,u8 mode,u8 color)
 563          { 
 564   1        uint8_t size;         
 565   1        uint8_t y0;
 566   1        y0=y;
 567   1        //size = 16;
 568   1      
 569   1        //LCD_CrtlWrite_Area(0,239,0,319);
 570   1        size = height_x;  //字号或高度
 571   1        height_x+=x; //
 572   1        width_y+=y;//总宽度
 573   1          while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
 574   1          {       
 575   2              if(y>=width_y){y=y0;y+=size;}
 576   2              //if(x>=height_x)break;//退出
 577   2          LCD_ShowChar(x,y,size,*p,mode,color);
 578   2      
 579   2              y+=size/2;  
 580   2              p++;
 581   2          }  
 582   1      }
 583          
 584          //m^n函数
 585          //返回值:m^n次方.
 586          static u32 LCD_Pow(u8 m,u8 n)
 587          {
 588   1        u32 result=1;  
 589   1        while(n--)result*=m;    
 590   1        return result;
 591   1      }   
 592          
 593          
 594          //显示数字,高位为0,还是显示
 595          //x,y:起点坐标
 596          //size:字体大小  16或24  
 597          //len:长度(即要显示的位数)
 598          //num:数值(0~999999999);
 599          //mode:   7和0位使用
 600          //[7]:0,不填充;1,填充0.
 601          //[6:1]:保留
 602          //[0]:0,非叠加显示;1,叠加显示.
 603          //color:颜色 
 604          void LCD_ShowxNum(u16 x,u16 y,u8 size,u8 len,u32 num,u8 mode,u8 color)
 605          {  
 606   1        u8 t,temp;
 607   1        u8 enshow=0;               
 608   1        for(t=0;t<len;t++)
 609   1        {
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 11  

 610   2          temp=(num/LCD_Pow(10,len-t-1))%10;   //求需要显示的最高位
 611   2          if(enshow==0&&t<(len-1))// 如果最高位为0   需要显示的长度
 612   2          {
 613   3            if(temp==0)
 614   3            {
 615   4              if(mode&0X80)LCD_ShowChar(x,y+(size/2)*t,size,'0',mode&0X01,color);  //为0也要显示
 616   4              else LCD_ShowChar(x,y+(size/2)*t,size,' ',mode&0X01,color);  //为0不显示
 617   4              continue;
 618   4            }else enshow=1; //最高位不是0或        
 619   3          }
 620   2          LCD_ShowChar(x,y+(size/2)*t,size,temp+'0',mode&0X01,color); 
 621   2        }
 622   1      } 
 623          
 624          //在指定位置画一个指定大小的圆
 625          //(x,y):中心点
 626          //r    :半径
 627          void Draw_Circle(u16 x0,u16 y0,u8 r,u8 color)
 628          {
 629   1        int a,b;
 630   1        int di;
 631   1      
 632   1        a=0;b=r;    
 633   1        di=3-(r<<1);             //判断下个点位置的标志
 634   1        while(a<=b)
 635   1        {
 636   2          LCD_DrawPoint(x0+a,y0-b,color);             //5
 637   2          LCD_DrawPoint(x0+b,y0-a,color);             //0           
 638   2          LCD_DrawPoint(x0+b,y0+a,color);             //4               
 639   2          LCD_DrawPoint(x0+a,y0+b,color);             //6 
 640   2          LCD_DrawPoint(x0-a,y0+b,color);             //1       
 641   2          LCD_DrawPoint(x0-b,y0+a,color);             
 642   2          LCD_DrawPoint(x0-a,y0-b,color);             //2             
 643   2          LCD_DrawPoint(x0-b,y0-a,color);             //7                
 644   2          a++;
 645   2          //使用Bresenham算法画圆     
 646   2          if(di<0)di +=4*a+6;   
 647   2          else
 648   2          {
 649   3            di+=10+4*(a-b);   
 650   3            b--;
 651   3          }                 
 652   2        }
 653   1      } 
 654          
 655          void Refresh_Work_Mode(void)
 656          {
 657   1          Back_Color=WHITE18;
 658   1          if(Work_Mode==0)
 659   1          {
 660   2               Disp_WuChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 661   2          }else if(Work_Mode==1)
 662   1          {
 663   2               Disp_YouChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 664   2          }else//无简易模式
 665   1          {
 666   2                 ;
 667   2          }
 668   1      }
 669          
 670          
 671          
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 12  

 672          //在指定位置画一个指定大小的圆
 673          //(x,y):中心点
 674          //r    :半径
 675          void DrawWorkWindows(void)
 676          {
 677   1          LCD_LIGHT_CLOSE;
 678   1          //清除选择界面-----------------------------------------
 679   1          Draw_Rectangle_Real(0,0,239,319,WHITE18);//清屏
 680   1          Back_Color=WHITE18;
 681   1          Disp_WuChuang(POS_Select_WC_X,POS_Select_WC_Y,WHITE18);
 682   1          Disp_YouChuang(POS_Select_YC_X,POS_Select_YC_Y,WHITE18);
 683   1          Draw_Rectangle(75,182,162,262,WHITE18,4);//
 684   1          Draw_Rectangle(75,58,162,136,WHITE18,4);
 685   1          Refresh_Work_Mode();
 686   1          Back_Color=WHITE18;
 687   1          DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 688   1          DISP_ICO_40X40(POS_ICO_SHIDU_X,POS_ICO_TEMP_Y,0,BLACK18);
 689   1          DISP_ICO_40X40(POS_ICO_TIME_X,POS_ICO_TEMP_Y,1,BLACK18);//显示时间
 690   1          //画点
 691   1          Draw_Rectangle_Real(POS_RT_TEMP_X+1,POS_RT_TEMP_Y+67,POS_RT_TEMP_X+8,POS_RT_TEMP_Y+71,BLACK18); //画点
 692   1          //显示单位
 693   1          DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+34*3+5,ICO_DU,BLACK18);
 694   1        
 695   1          //显示湿度单位
 696   1          DISP_ICO_32X40(POS_RT_RH_X,POS_RT_RH_Y+19*2,ICO_PER,BLACK18);  
 697   1          if(data_flash.Language == Lan_English)//英语
 698   1          {
 699   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,0,BLACK18);
 700   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,1,BLACK18);
 701   2          }
 702   1          else if(data_flash.Language == Lan_Portuguese)//葡萄牙语
 703   1          {
 704   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,2,BLACK18);
 705   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 706   2          }
 707   1          else if(data_flash.Language == Lan_Spanish)//西班牙语
 708   1          {
 709   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
 710   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 711   2          }
 712   1          else if(data_flash.Language == Lan_French)//法语
 713   1          {
 714   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
 715   2            DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 716   2          }   
 717   1           
 718   1          DISP_DHM(POS_DMH_X,POS_DMH_Y,0,BLACK18);
 719   1          DISP_DHM(POS_DMH_X,POS_DMH_Y+25,1,BLACK18);
 720   1          DISP_DHM(POS_DMH_X,POS_DMH_Y+25*2,2,BLACK18);   
 721   1          //显示运行时间
 722   1      
 723   1          Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+18,POS_ICO_TIME_X+2,POS_DMH_Y+20,BLACK18);
 724   1          Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+18,POS_ICO_TIME_X+12,POS_DMH_Y+20,BLACK18);
 725   1      
 726   1          Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+43,POS_ICO_TIME_X+2,POS_DMH_Y+45,BLACK18);
 727   1          Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+43,POS_ICO_TIME_X+12,POS_DMH_Y+45,BLACK18);
 728   1          
 729   1          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y,2,BLACK18);
 730   1          DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+12,0,BLACK18);
 731   1        
 732   1          Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+48,POS_SYSDATE_X+2,POS_SYSDATE_Y+50,BLACK18);
 733   1      
C51 COMPILER V9.52.0.0   LCD                                                               03/30/2019 12:47:22 PAGE 13  

 734   1          Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+76,POS_SYSDATE_X+2,POS_SYSDATE_Y+78,BLACK18);
 735   1      
 736   1          Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+24,POS_SYSTIME_X+2,POS_SYSTIME_Y+26,BLACK18);
 737   1          Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+24,POS_SYSTIME_X+12,POS_SYSTIME_Y+26,BLACK18);
 738   1      
 739   1          Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+52,POS_SYSTIME_X+2,POS_SYSTIME_Y+54,BLACK18);
 740   1          Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+52,POS_SYSTIME_X+12,POS_SYSTIME_Y+54,BLACK18);     
 741   1      } 
 742          
 743          //显示版本号
 744          //VHB15A_EN_VM_V1.07      EN-英文国家   VM-VM默认功能及界面
 745          void  LCD_Show_Verion(void)
 746          {
 747   1        LCD_ShowString(60,20,16,200,"VHB15A",0,BLACK18);  //显示机种名
 748   1        
 749   1        LCD_ShowString(60,68,16,200,"---EN",0,BLACK18); //显示版本语言    
 750   1      
 751   1        LCD_ShowString(60,108,16,200,"---VM",0,BLACK18);  //显示客户 
 752   1      
 753   1        
 754   1      
 755   1      //显示版本号
 756   1        LCD_ShowString(40,20,16,200,VHB15A_VER,0,GRAY18); 
 757   1      }
 758          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6005    ----
   CONSTANT SIZE    =  22160    ----
   XDATA SIZE       =      1     185
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
