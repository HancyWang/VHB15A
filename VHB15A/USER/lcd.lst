C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN ..\OBJ\lcd.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\HARDWARE\lcd\lcd.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER N
                    -OAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sh
                    -t31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\lcd.lst) TABS(2) OBJECT(..\OB
                    -J\lcd.obj)

line level    source

   1          #include "delay.h"
   2          #include "lcd.h"
   3          #include "Font.h"
   4          //#include "all.h"
   5          
   6          uint8_t    Back_Color;
   7          
   8          //2019.03.29
   9          sfr P0   = 0x80;
  10          sbit P14 = (u8)0x90^(u8)4;
  11          sbit P15 = (u8)0x90^(u8)5;
  12          sbit P16 = (u8)0x90^(u8)6;
  13          //sbit P40 = (u8)0xC0^(u8)0;
  14          sbit P40 = (u8)0xC0;
  15          sbit P46 = (u8)0xC0^(u8)6;
  16          
  17          static const uint16_t code Table_Color[]=
  18          {
  19            RED,
  20            GREEN,
  21            BLUE,
  22            WHITE, 
  23            BLACK , 
  24            GRAY,  
  25            YELLOW ,
  26            BRIGHT_BLUE,
  27            AIR_BLUE,
  28            PURPLE,
  29            BLACKRED   
  30          };
  31          
  32          
  33          static void SdCmd(uint8_t data8)   //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  34          {
  35   1        LCD_RS_L;
  36   1        LCD_PORT =data8;
  37   1        LCD_CS_L;
  38   1        LCD_WR_L;
  39   1        LCD_WR_H;
  40   1        LCD_CS_H;
  41   1      }
  42          
  43          
  44          static void SdData(uint8_t data8)  //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  45          {
  46   1        LCD_RS_H;
  47   1        LCD_PORT =data8;
  48   1        LCD_CS_L;
  49   1        LCD_WR_L;
  50   1        LCD_WR_H;
  51   1        LCD_CS_H;
  52   1      }
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 2   

  53          
  54          void LCD_CtrlWrite_ILI9328(uint16_t i)
  55          {
  56   1        LCD_CS_L;
  57   1        LCD_RS_H;
  58   1        LCD_PORT =(uint8_t)(i/256);
  59   1        LCD_WR_L;
  60   1        LCD_WR_H;
  61   1        LCD_PORT =i%256;
  62   1        LCD_WR_L;
  63   1        LCD_WR_H;
  64   1        LCD_RS_H;
  65   1        LCD_CS_H;
  66   1      }
  67          
  68          void   LCD_CtrlWrite_Color(uint8_t color)
  69          {
  70   1        LCD_CtrlWrite_ILI9328(Table_Color[color]);
  71   1      }
  72          
  73          void LCD_Initial(void)
  74          {
  75   1       
  76   1        LCD_RST_L;
  77   1        delay_ms(20); // Delay 1ms
  78   1        LCD_RST_H;
  79   1        delay_ms(800); // Delay 10ms // This delay time is necessary
  80   1        
  81   1        SdCmd(0x11);//Wake up
  82   1        delay_ms(120); //Delay 120ms
  83   1        SdCmd(0x35);SdData(0x00);//TE ON   60Hz
  84   1            
  85   1        SdCmd(0x36);
  86   1        SdData(0x00); //RTN
  87   1        SdCmd(0x21); //黑白反相  
  88   1      
  89   1        SdCmd(0xb2);  //Porch setting
  90   1        SdData(0x0c);
  91   1        SdData(0x0c);
  92   1        SdData(0x00);
  93   1        SdData(0x33);
  94   1        SdData(0x33);
  95   1      
  96   1        SdCmd(0xb7);  //Gate Control
  97   1        SdData(0x35); //VGH=13.26V, VGL=-10.43V
  98   1      
  99   1        SdCmd(0xbb); //vcom setting
 100   1        SdData(0x19);
 101   1      
 102   1        SdCmd(0xc0); //LCM Control
 103   1        SdData(0x2c);
 104   1      
 105   1        SdCmd(0xc2);  //VDV and VRH Command Enable  
 106   1        SdData(0x01);
 107   1      
 108   1        SdCmd(0xc3); //VRH Set, VAP(GVDD) & VAN(GVCL)
 109   1        SdData(0x1d); 
 110   1      
 111   1        SdCmd(0xc4);  //VDV Set, 
 112   1        SdData(0x20); //VDV=0V
 113   1      
 114   1        SdCmd(0xc6);//Frame rate control in normal mode
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 3   

 115   1        SdData(0x0f);//dot inversion & 60Hz
 116   1      
 117   1        SdCmd(0xd0);   //Power control 1
 118   1        SdData(0xa4);
 119   1        SdData(0xa1); //AVDD=6.8V; AVCL=-4.8V; VDDS=2.3V
 120   1      
 121   1        SdCmd(0xe8);
 122   1        SdData(0x83);
 123   1      //--------------------------------ST7789VI gamma setting---------------------------------------//
 124   1        SdCmd(0xe0);
 125   1        SdData(0xd2);
 126   1        SdData(0x11);
 127   1        SdData(0x16);
 128   1        SdData(0x0d);
 129   1        SdData(0x0d);
 130   1        SdData(0x38);
 131   1        SdData(0x3d);
 132   1        SdData(0x44);
 133   1        SdData(0x4c);
 134   1        SdData(0x1c);
 135   1        SdData(0x15);
 136   1        SdData(0x15);
 137   1        SdData(0x1c);
 138   1        SdData(0x20);
 139   1      
 140   1      
 141   1        SdCmd(0xe1);
 142   1        SdData(0xd2);
 143   1        SdData(0x11);
 144   1        SdData(0x16);
 145   1        SdData(0x0d);
 146   1        SdData(0x0d);
 147   1        SdData(0x38);
 148   1        SdData(0x3d);
 149   1        SdData(0x44);
 150   1        SdData(0x4c);
 151   1        SdData(0x1c);
 152   1        SdData(0x15);
 153   1        SdData(0x15);
 154   1        SdData(0x1c);
 155   1        SdData(0x20);
 156   1      
 157   1        SdCmd(0x3a);SdData(0x55); // 8/16bit,65k colors
 158   1        SdCmd(0x29);             //Display on
 159   1      
 160   1        delay_ms(10);
 161   1      
 162   1        SdCmd(0x2a);
 163   1        SdData(0x00);
 164   1        SdData(0x00);
 165   1        SdData(0x00);
 166   1        SdData(0xEF);
 167   1      
 168   1        SdCmd(0x2b);
 169   1        SdData(0x00);
 170   1        SdData(0x00);
 171   1        SdData(0x01);
 172   1        SdData(0x3F);
 173   1      
 174   1        delay_ms(120);
 175   1        SdCmd(0x2c);
 176   1      }
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 4   

 177          
 178          void  LCD_CrtlWrite_Area(uint8_t SX,uint8_t EX,uint16_t SY,uint16_t EY)
 179          {
 180   1        SdCmd(0x2A);
 181   1        SdData(SX/256);
 182   1        SdData(SX%256);
 183   1        SdData(EX/256);
 184   1        SdData(EX%256);
 185   1        SdCmd(0x2B);
 186   1        SdData((uint8_t)(SY/256));
 187   1        SdData(SY%256);
 188   1        SdData((uint8_t)(EY/256));
 189   1        SdData(EY%256);
 190   1        SdCmd(0x2C);  
 191   1      }  
 192          
 193          
 194           //画矩形
 195          void Draw_Rectangle(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color, uint8_t
             - LineW)
 196          {
 197   1        uint16_t i,j,w,h;
 198   1        w=(uint16_t)End_X-(uint16_t)Start_X;
 199   1        h=End_Y-Start_Y;
 200   1        //画第一条线
 201   1        LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,Start_Y+LineW-1);
 202   1        for (j=0; j<LineW;j++)
 203   1        {
 204   2          for(i=0;i<=w;i++)
 205   2          {
 206   3            LCD_CtrlWrite_Color(color);
 207   3          }
 208   2        }
 209   1        LCD_CrtlWrite_Area(Start_X,End_X,End_Y-LineW+1,End_Y);
 210   1        for (j=0; j<LineW;j++)
 211   1        {
 212   2          for(i=0;i<=w;i++)
 213   2          {
 214   3            LCD_CtrlWrite_Color(color);
 215   3          }
 216   2        }
 217   1        LCD_CrtlWrite_Area(Start_X,Start_X+LineW-1,Start_Y,End_Y);
 218   1        for (j=0; j<=h;j++)
 219   1        {
 220   2          for(i=0;i<LineW;i++)
 221   2          {
 222   3            LCD_CtrlWrite_Color(color);
 223   3          }
 224   2        }
 225   1        LCD_CrtlWrite_Area(End_X-LineW+1,End_X,Start_Y,End_Y);
 226   1        for (j=0; j<=h;j++)
 227   1        {
 228   2          for(i=0;i<LineW;i++)
 229   2          {
 230   3            LCD_CtrlWrite_Color(color);
 231   3          }
 232   2        }
 233   1      }
 234          
 235           //画实体方块
 236          void Draw_Rectangle_Real(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color)
 237          {
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 5   

 238   1        uint16_t i,j,w,h;
 239   1        w=(uint16_t)End_X-(uint16_t)Start_X;
 240   1        h=End_Y-Start_Y;
 241   1        LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,End_Y);
 242   1        for (j=0; j<=h;j++)
 243   1        {
 244   2          for(i=0;i<=w;i++)
 245   2          {
 246   3            LCD_CtrlWrite_Color(color);
 247   3          }
 248   2        }
 249   1      }
 250          
 251          //显示单色图形
 252          //X-坐标 0-239
 253          //Y-坐标 0-319
 254          //H-高   2-200
 255          //W-宽   1-100
 256          //gp 字符地址
 257          //NUM-图形编号
 258          //color-颜色
 259          static void DISP_MONO_GRAP(uint8_t  X1, uint16_t Y1,uint8_t  H, uint8_t  W,const uint8_t *gp,uint8_t color
             -)
 260          {
 261   1        uint16_t w,j;
 262   1        LCD_CrtlWrite_Area(X1,X1+H-1,Y1,Y1+W-1);
 263   1        for(w=0;w<((INT)H*((INT)W)/8);w++)
 264   1        {
 265   2          for(j=0;j<(uint16_t)8;j++)
 266   2          {
 267   3            if((gp[w]&((uint16_t)0x01<<j))!=0)
 268   3            {
 269   4              LCD_CtrlWrite_Color(color);
 270   4            }
 271   3            else
 272   3            {
 273   4              LCD_CtrlWrite_Color(Back_Color);
 274   4            } 
 275   3          }
 276   2        }
 277   1      }
 278          
 279          
 280          void DISP_TEMP_30X56(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 281          {
 282   1        DISP_MONO_GRAP(X,Y,56,30,NUM30X56[NUM],color);
 283   1      }
 284          
 285          void DISP_TEMP_38X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 286          {
 287   1        DISP_MONO_GRAP(X,Y,64,38,NUM38X64[NUM],color);
 288   1      }
 289          
 290          void DISP_CQK25X24(uint8_t  X, uint16_t Y,uint8_t color)
 291          {
 292   1        DISP_MONO_GRAP(X,Y,24,25,CQK25X24,color);
 293   1      }
 294          
 295          void DISP_RTD28X24(uint8_t  X, uint16_t Y,uint8_t color)
 296          {
 297   1        DISP_MONO_GRAP(X,Y,24,28,RTD28X24,color);
 298   1      }
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 6   

 299          
 300          void DISP_JQK41X16(uint8_t  X, uint16_t Y,uint8_t color)
 301          {
 302   1        DISP_MONO_GRAP(X,Y,16,41,JQK41X16,color);
 303   1      }
 304          
 305          
 306          
 307          void DISP_HEAT_36X24(uint8_t  X, uint16_t Y,uint8_t color)
 308          {
 309   1        DISP_MONO_GRAP(X,Y,24,36,HEAT36X32,color);
 310   1      }
 311          
 312          void DISP_RH_17X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 313          {
 314   1        DISP_MONO_GRAP(X,Y,40,17,NUM17X40[NUM],color);
 315   1      }
 316          
 317          void DISP_FNT10X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 318          {
 319   1        DISP_MONO_GRAP(X,Y,24,10,FNT10X24[NUM],color);
 320   1      }
 321          
 322          void DISP_RH14X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 323          {
 324   1        DISP_MONO_GRAP(X,Y,24,14,RH14X24[NUM],color);
 325   1      }
 326          
 327          void DISP_TIME_10X16(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 328          {
 329   1        DISP_MONO_GRAP(X,Y,16,10,NUM10X16[NUM],color);
 330   1      }
 331          void DISP_ICO_32X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 332          {
 333   1        DISP_MONO_GRAP(X,Y,40,32,ICO32X40[NUM],color);  
 334   1      }
 335          
 336          void DISP_ICO_40X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 337          {
 338   1        DISP_MONO_GRAP(X,Y,40,40,ICO40X40[NUM],color);
 339   1      }
 340          
 341          
 342          
 343          void DISP_ICO_52X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 344          {
 345   1        DISP_MONO_GRAP(X,Y,48,48,ICO48X48[NUM],color);  
 346   1      }
 347          
 348          
 349          void DISP_DHM(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 350          {
 351   1        DISP_MONO_GRAP(X,Y,16,14,DHM14X16[NUM],color);
 352   1      }  
 353          
 354          void DISP_VHB80_56X40(uint8_t  X, uint16_t Y,uint8_t color)
 355          {
 356   1        DISP_MONO_GRAP(X,Y,40,56,VHB8056X40,color);
 357   1      }
 358          
 359          
 360          void Disp_YouChuang(uint8_t  X, uint16_t Y,uint8_t color) //80,71
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 7   

 361          {
 362   1        DISP_MONO_GRAP(X,Y,80,71,PIC_YouChuang,color); 
 363   1      }
 364          
 365          void Disp_WuChuang(uint8_t  X, uint16_t Y,uint8_t color)   //
 366          {
 367   1        DISP_MONO_GRAP(X,Y,80,71,PIC_WuChuang,color);
 368   1      }
 369          
 370          void DISP_VHB80_PIC(uint8_t color)
 371          { 
 372   1        DISP_VHB80_56X40(POS_VHB80_X,POS_VHB80_Y,color);
 373   1        DISP_HEAT_36X24(POS_HEAT_X,POS_HEAT_Y,color);    //加热盘图形    
 374   1        DISP_CQK25X24(POS_CQK_X,POS_CQK_Y,color);
 375   1        Draw_Rectangle_Real(POS_XQGS_X1,POS_XQGS_Y1,POS_XQGS_X2,POS_XQGS_Y2,color);  //画吸气管上部，下部
 376   1        Draw_Rectangle_Real(POS_XQGX_X1,POS_XQGX_Y1,POS_XQGX_X2,POS_XQGX_Y2,color); 
 377   1        DISP_RTD28X24(POS_RTD_X,POS_RTD_Y,color);    
 378   1        Draw_Rectangle_Real(POS_CQGS_X1,POS_CQGS_Y1,POS_CQGS_X2,POS_CQGS_Y2,color);  //画出气管上部，下部
 379   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGX_X2,POS_CQGX_Y2,color); ;  //画出气管上部，下部
 380   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGS_X2,POS_CQGX_Y1+1,color);  //画封口 
 381   1        DISP_JQK41X16(POS_JQK_X,POS_JQK_Y,color);     //画进气口
 382   1      }
 383          
 384          
 385          //画点
 386          //x,y:坐标
 387          //POINT_COLOR:此点的颜色
 388          static void LCD_DrawPoint(u16 x,u16 y,uint8_t color)
 389          { 
 390   1        SdCmd(0x2A);;  //设置光标位置 
 391   1        SdData((uint8_t)(x/256));   //开始点的X坐标
 392   1        SdData(x%256);
 393   1        SdData((uint8_t)(x/256));
 394   1        SdData(x%256);     
 395   1        SdCmd(0x2B);
 396   1        SdData((uint8_t)(y/256)); //开始点的Y坐标    
 397   1        SdData(y%256);     
 398   1        SdData((uint8_t)(y/256));      
 399   1        SdData(y%256);
 400   1        SdCmd(0x2C);    
 401   1        LCD_CtrlWrite_Color(color); //开始写入GRAM
 402   1      }
 403          
 404          //*  画点的方式
 405          //显示16*8 ASC字符  
 406          //X座标 0-239
 407          //Y座标 0-319
 408          //NUM字符
 409          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 410          //color字符的颜色 
 411          void DISP_FNT8X16(u16  X, u16 Y,u8 NUM,u8 mode,u8 color)
 412          {
 413   1        uint16_t  w,j;
 414   1        uint16_t F_x,F_y;
 415   1        u8 num=NUM;
 416   1      
 417   1        F_x = X;
 418   1        F_y = Y;   
 419   1      
 420   1        LCD_CrtlWrite_Area((uint8_t)X,(uint8_t)(X+15),Y,Y+7);
 421   1      
 422   1        num=num-(u8)(' ');//得到偏移后的值       
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 8   

 423   1        for(w=0;w<8;w++)
 424   1        {
 425   2          for(j=0;j<8;j++)
 426   2          {
 427   3            if((asc2_1608[num][(w*2)+1]&((uint16_t)0x01<<j))!=0)
 428   3            {
 429   4              if(mode == (u8)0)
 430   4              {
 431   5                LCD_CtrlWrite_Color(color); //快速写
 432   5              }
 433   4              else
 434   4              {
 435   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 436   5              }
 437   4            }
 438   3            else
 439   3            {
 440   4              if(mode == (u8)0)
 441   4              {
 442   5                LCD_CtrlWrite_Color(Back_Color);
 443   5              }
 444   4            }
 445   3            F_x++;        
 446   3          } 
 447   2          
 448   2          for(j=0;j<8;j++)
 449   2          {
 450   3            if((asc2_1608[num][w*2]&((uint16_t)0x01<<j))!=0)
 451   3            {
 452   4              if(mode == (u8)0)
 453   4              {
 454   5                LCD_CtrlWrite_Color(color); //快速写
 455   5              }
 456   4              else
 457   4              {
 458   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 459   5              }
 460   4            }
 461   3            else
 462   3            {
 463   4              if(mode == (u8)0)
 464   4              {
 465   5                LCD_CtrlWrite_Color(Back_Color);
 466   5              } 
 467   4            }
 468   3            F_x++;        
 469   3          }
 470   2          F_y++; 
 471   2          F_x = X; 
 472   2        } 
 473   1      }
 474          
 475          //*  画点的方式 可以显示叠加方式
 476          //显示24*12 ASC字符  
 477          //X座标 0-239
 478          //Y座标 0-319
 479          //NUM字符
 480          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色 速度快，画框方式
 481          //color字符的颜色 
 482          void DISP_FNT12X24(u16 X, u16 Y,u8 NUM,u8 mode,u8 color)
 483          {
 484   1        uint16_t  w,j;
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 9   

 485   1        uint16_t F_x,F_y;    
 486   1        u8 num=NUM;
 487   1      
 488   1        F_x = X;
 489   1        F_y = Y;
 490   1      
 491   1        LCD_CrtlWrite_Area((uint8_t)X,(uint8_t)(X+23),Y,Y+11);
 492   1      
 493   1        num=num-(u8)(' ');//得到偏移后的值       
 494   1        for(w=0;w<12;w++)
 495   1        {
 496   2          for(j=0;j<8;j++)
 497   2          {
 498   3            if((asc2_2412[num][(w*3)+2]&((uint16_t)0x01<<j))!=0)
 499   3            {
 500   4              if(mode == (u8)0)
 501   4              {
 502   5                LCD_CtrlWrite_Color(color); //快速写
 503   5              }
 504   4              else
 505   4              {
 506   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 507   5              }
 508   4            }
 509   3            else
 510   3            {
 511   4              if(mode == (u8)0)
 512   4              {
 513   5                LCD_CtrlWrite_Color(Back_Color);
 514   5              }
 515   4            }
 516   3            F_x++;  
 517   3          } 
 518   2          
 519   2          for(j=0;j<8;j++)
 520   2          {
 521   3            if((asc2_2412[num][(w*3)+1]&((uint16_t)0x01<<j))!=0)
 522   3            {
 523   4              if(mode == (u8)0)
 524   4              {
 525   5                LCD_CtrlWrite_Color(color); //快速写
 526   5              }
 527   4              else
 528   4              {
 529   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 530   5              }
 531   4            }
 532   3            else
 533   3            {
 534   4              if(mode == (u8)0)
 535   4              {
 536   5                LCD_CtrlWrite_Color(Back_Color);
 537   5              }
 538   4            }
 539   3            F_x++;
 540   3          } 
 541   2          for(j=0;j<8;j++)
 542   2          {
 543   3            if((asc2_2412[num][w*3]&((uint16_t)0x01<<j))!=0)
 544   3            {
 545   4              if(mode == (u8)0)
 546   4              {
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 10  

 547   5                LCD_CtrlWrite_Color(color); //快速写
 548   5              }
 549   4              else
 550   4              {
 551   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 552   5              }
 553   4            }
 554   3            else
 555   3            {
 556   4              if(mode == (u8)0)
 557   4              {
 558   5                LCD_CtrlWrite_Color(Back_Color);
 559   5              } 
 560   4            }
 561   3            F_x++;
 562   3          }  
 563   2          F_y++; 
 564   2          F_x = X; 
 565   2        } 
 566   1      }
 567          
 568          //在指定位置显示一个字符
 569          //x,y:起始坐标
 570          //size:字体大小 16/24
 571          //num:要显示的字符:" "--->"~" 
 572          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 573          //color:
 574          void LCD_ShowChar(u16 x,u16 y,u8 size,u8 num,u8 mode,u8 color)
 575          {                 
 576   1          
 577   1        //设置窗口
 578   1        if(size == 16)
 579   1        {
 580   2          DISP_FNT8X16(x,y,num,mode,color);
 581   2        } 
 582   1        else if(size == 24)
 583   1        {
 584   2          DISP_FNT12X24(x,y,num,mode,color);
 585   2        }
 586   1        else
 587   1        {
 588   2          //do nothing
 589   2        }
 590   1      }  
 591          
 592          
 593          //显示16*8 或24*12 ASC字符
 594          //x,y:起点坐标
 595          //height_x  字高度，也是字号,如16表示16*8，24表示24*12
 596          //width_y: 文字的最大长度，以免超出范围，最大是320 
 597          //*p:字符串起始地址
 598          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 599          //字符的颜色
 600          void LCD_ShowString(u16 x, u16 y,u16 height_x,u16 width_y,const u8 *p,u8 mode,u8 color)
 601          { 
 602   1        uint8_t size;         
 603   1        uint8_t y0;
 604   1        u16 Y1;
 605   1        u16 X1;
 606   1        u16 WIDTH_Y;
 607   1        
 608   1        y0=(uint8_t)y;
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 11  

 609   1        
 610   1        Y1=y;
 611   1        X1=x;
 612   1        WIDTH_Y=width_y;
 613   1        
 614   1        //size = 16;
 615   1      
 616   1        //LCD_CrtlWrite_Area(0,239,0,319);
 617   1        size = (uint8_t)height_x;  //字号或高度
 618   1      
 619   1        WIDTH_Y+=Y1;//总宽度
 620   1        while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
 621   1        {       
 622   2          if(Y1>=WIDTH_Y){Y1=y0;Y1+=size;}
 623   2          //if(x>=height_x)break;//退出
 624   2          LCD_ShowChar(X1,Y1,size,*p,mode,color);
 625   2      
 626   2          Y1+=size/2; 
 627   2          p++;
 628   2        } 
 629   1      //  uint8_t size;         
 630   1      //  uint8_t y0;
 631   1      //  y0=y;
 632   1      //  //size = 16;
 633   1      
 634   1      //  //LCD_CrtlWrite_Area(0,239,0,319);
 635   1      //  size = height_x;  //字号或高度
 636   1      //  height_x+=x; //
 637   1      //  width_y+=y;//总宽度
 638   1      //  while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
 639   1      //  {       
 640   1      //    if(y>=width_y){y=y0;y+=size;}
 641   1      //    //if(x>=height_x)break;//退出
 642   1      //    LCD_ShowChar(x,y,size,*p,mode,color);
 643   1      
 644   1      //    y+=size/2;  
 645   1      //    p++;
 646   1      //  }   
 647   1      }
 648          
 649          //m^n函数
 650          //返回值:m^n次方.
 651          static u32 LCD_Pow(u8 m,u8 n)
 652          {
 653   1        u32 result=1;  
 654   1        while(n-->(u8)0)
 655   1        {
 656   2          result*=m;
 657   2        }    
 658   1        return result;
 659   1      }   
 660          
 661          
 662          //显示数字,高位为0,还是显示
 663          //x,y:起点坐标
 664          //size:字体大小  16或24  
 665          //len:长度(即要显示的位数)
 666          //num:数值(0~999999999);
 667          //mode:   7和0位使用
 668          //[7]:0,不填充;1,填充0.
 669          //[6:1]:保留
 670          //[0]:0,非叠加显示;1,叠加显示.
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 12  

 671          //color:颜色 
 672          void LCD_ShowxNum(u16 x,u16 y,u8 size,u8 len,u32 num,u8 mode,u8 color)
 673          {  
 674   1        u8 t,temp;
 675   1        u8 enshow=0;               
 676   1        for(t=0;t<len;t++)
 677   1        {
 678   2          temp=(num/LCD_Pow(10,len-t-1))%10;   //求需要显示的最高位
 679   2          if((enshow==0)&&(t<(len-1)))// 如果最高位为0   需要显示的长度
 680   2          {
 681   3            if(temp==0)
 682   3            {
 683   4              if((mode&(u8)0X80)!=(u8)0)
 684   4              {
 685   5                LCD_ShowChar(x,y+((size/2)*t),size,'0',mode&(u8)0x01,color);  //为0也要显示
 686   5              }
 687   4              else
 688   4              {
 689   5                LCD_ShowChar(x,y+((size/2)*t),size,' ',mode&(u8)0x01,color);  //为0不显示
 690   5              }         
 691   4              continue;
 692   4            }
 693   3            else
 694   3            {
 695   4              enshow=1; //最高位不是0或 
 696   4            }              
 697   3          }
 698   2          LCD_ShowChar(x,y+((size/2)*t),size,temp+'0',mode&(u8)0x01,color); 
 699   2        }
 700   1      } 
 701          
 702          //在指定位置画一个指定大小的圆
 703          //(x,y):中心点
 704          //r    :半径
 705          void Draw_Circle(u16 x0,u16 y0,u8 r,u8 color)
 706          {
 707   1        u16 a,b;
 708   1        u16 di;
 709   1      
 710   1        a=0;b=r;    
 711   1        di=3-(r<<1);             //判断下个点位置的标志
 712   1        while(a<=b)
 713   1        {
 714   2          LCD_DrawPoint(x0+a,y0-b,color);             //5
 715   2          LCD_DrawPoint(x0+b,y0-a,color);             //0           
 716   2          LCD_DrawPoint(x0+b,y0+a,color);             //4               
 717   2          LCD_DrawPoint(x0+a,y0+b,color);             //6 
 718   2          LCD_DrawPoint(x0-a,y0+b,color);             //1       
 719   2          LCD_DrawPoint(x0-b,y0+a,color);             
 720   2          LCD_DrawPoint(x0-a,y0-b,color);             //2             
 721   2          LCD_DrawPoint(x0-b,y0-a,color);             //7                
 722   2          a++;
 723   2          //使用Bresenham算法画圆     
 724   2          if(di<0)
 725   2          {
 726   3            di +=((4*a)+6); 
 727   3          }  
 728   2          else
 729   2          {
 730   3            di+=(10+(4*(a-b)));   
 731   3            b--;
 732   3          }                 
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 13  

 733   2        }
 734   1      } 
 735          
 736          void Refresh_Work_Mode(void)
 737          {
 738   1        Back_Color=WHITE18;
 739   1        if(Work_Mode==0)
 740   1        {
 741   2          Disp_WuChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 742   2        }else if(Work_Mode==1)
 743   1        {
 744   2          Disp_YouChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 745   2        }else//无简易模式
 746   1        {
 747   2          //do nothing
 748   2        }
 749   1      }
 750          
 751          
 752          
 753          //在指定位置画一个指定大小的圆
 754          //(x,y):中心点
 755          //r    :半径
 756          void DrawWorkWindows(void)
 757          {
 758   1        LCD_LIGHT_CLOSE;
 759   1        //清除选择界面-----------------------------------------
 760   1        Draw_Rectangle_Real(0,0,239,319,WHITE18);//清屏
 761   1        Back_Color=WHITE18;
 762   1        Disp_WuChuang(POS_Select_WC_X,POS_Select_WC_Y,WHITE18);
 763   1        Disp_YouChuang(POS_Select_YC_X,POS_Select_YC_Y,WHITE18);
 764   1        Draw_Rectangle(75,182,162,262,WHITE18,4);//
 765   1        Draw_Rectangle(75,58,162,136,WHITE18,4);
 766   1        Refresh_Work_Mode();
 767   1        Back_Color=WHITE18;
 768   1        DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 769   1        DISP_ICO_40X40(POS_ICO_SHIDU_X,POS_ICO_TEMP_Y,0,BLACK18);
 770   1        DISP_ICO_40X40(POS_ICO_TIME_X,POS_ICO_TEMP_Y,1,BLACK18);//显示时间
 771   1        //画点
 772   1        Draw_Rectangle_Real(POS_RT_TEMP_X+1,POS_RT_TEMP_Y+67,POS_RT_TEMP_X+8,POS_RT_TEMP_Y+71,BLACK18); //画点
 773   1        //显示单位
 774   1        DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
 775   1      
 776   1        //显示湿度单位
 777   1        DISP_ICO_32X40(POS_RT_RH_X,POS_RT_RH_Y+(19*2),ICO_PER,BLACK18);  
 778   1        if(data_flash.Language == Lan_English)//英语
 779   1        {
 780   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,0,BLACK18);
 781   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,1,BLACK18);
 782   2        }
 783   1        else if(data_flash.Language == Lan_Portuguese)//葡萄牙语
 784   1        {
 785   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,2,BLACK18);
 786   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 787   2        }
 788   1        else if(data_flash.Language == Lan_Spanish)//西班牙语
 789   1        {
 790   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
 791   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 792   2        }
 793   1        else if(data_flash.Language == Lan_French)//法语
 794   1        {
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 14  

 795   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
 796   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 797   2        } 
 798   1        else
 799   1        {
 800   2          //do nothing
 801   2        }
 802   1           
 803   1        DISP_DHM(POS_DMH_X,POS_DMH_Y,0,BLACK18);
 804   1        DISP_DHM(POS_DMH_X,POS_DMH_Y+25,1,BLACK18);
 805   1        DISP_DHM(POS_DMH_X,POS_DMH_Y+(25*2),2,BLACK18);   
 806   1        //显示运行时间
 807   1      
 808   1        Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+18,POS_ICO_TIME_X+2,POS_DMH_Y+20,BLACK18);
 809   1        Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+18,POS_ICO_TIME_X+12,POS_DMH_Y+20,BLACK18);
 810   1      
 811   1        Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+43,POS_ICO_TIME_X+2,POS_DMH_Y+45,BLACK18);
 812   1        Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+43,POS_ICO_TIME_X+12,POS_DMH_Y+45,BLACK18);
 813   1      
 814   1        DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y,2,BLACK18);
 815   1        DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+12,0,BLACK18);
 816   1      
 817   1        Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+48,POS_SYSDATE_X+2,POS_SYSDATE_Y+50,BLACK18);
 818   1      
 819   1        Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+76,POS_SYSDATE_X+2,POS_SYSDATE_Y+78,BLACK18);
 820   1      
 821   1        Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+24,POS_SYSTIME_X+2,POS_SYSTIME_Y+26,BLACK18);
 822   1        Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+24,POS_SYSTIME_X+12,POS_SYSTIME_Y+26,BLACK18);
 823   1      
 824   1        Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+52,POS_SYSTIME_X+2,POS_SYSTIME_Y+54,BLACK18);
 825   1        Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+52,POS_SYSTIME_X+12,POS_SYSTIME_Y+54,BLACK18);     
 826   1      } 
 827          
 828          //显示版本号
 829          //VHB15A_EN_VM_V1.07      EN-英文国家   VM-VM默认功能及界面
 830          void  LCD_Show_Verion(void)
 831          {
 832   1        LCD_ShowString(60,20,16,200,"VHB15A",0,BLACK18);  //显示机种名
 833   1      
 834   1        LCD_ShowString(60,68,16,200,"---EN",0,BLACK18); //显示版本语言    
 835   1      
 836   1        LCD_ShowString(60,108,16,200,"---VM",0,BLACK18);  //显示客户 
 837   1      
 838   1        
 839   1      
 840   1      //显示版本号
 841   1        LCD_ShowString(40,20,16,200,VHB15A_VER,0,GRAY18); 
 842   1      }
 843          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6038    ----
   CONSTANT SIZE    =  22159    ----
   XDATA SIZE       =      1     192
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
C51 COMPILER V9.52.0.0   LCD                                                               04/08/2019 16:42:10 PAGE 15  

   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
