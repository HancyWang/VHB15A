C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE LCD
OBJECT MODULE PLACED IN ..\OBJ\lcd.obj
COMPILER INVOKED BY: D:\Keil4\C51\BIN\C51.EXE ..\HARDWARE\lcd\lcd.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE ORDER N
                    -OAREGS INCDIR(..\HARDWARE\ds1302;..\HARDWARE\ds18b20;..\HARDWARE\lcd;..\HARDWARE\RX8010;..\HARDWARE\sht21;..\HARDWARE\sh
                    -t31;..\HARDWARE\w25x;..\SYSTEM\delay;..\SYSTEM\stc_eeprom;..\SYSTEM;..\CODE) DEBUG PRINT(.\lcd.lst) TABS(2) OBJECT(..\OB
                    -J\lcd.obj)

line level    source

   1          #include "delay.h"
   2          #include "lcd.h"
   3          #include "Font.h"
   4          //#include "all.h"
   5          
   6          uint8_t    Back_Color;
   7          
   8          //2019.03.29
   9          sfr P0   = 0x80;
  10          sbit P14 = 0x90^4;
  11          sbit P15 = 0x90^5;
  12          sbit P16 = 0x90^6;
  13          sbit P40 = 0xC0^0;
  14          sbit P46 = 0xC0^6;
  15          
  16          static const uint16_t code Table_Color[]=
  17          {
  18            RED,
  19            GREEN,
  20            BLUE,
  21            WHITE, 
  22            BLACK , 
  23            GRAY,  
  24            YELLOW ,
  25            BRIGHT_BLUE,
  26            AIR_BLUE,
  27            PURPLE,
  28            BLACKRED   
  29          };
  30          
  31          
  32          static void SdCmd(uint8_t data8)   //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  33          {
  34   1        LCD_RS_L;
  35   1        LCD_PORT =data8;
  36   1        LCD_CS_L;
  37   1        LCD_WR_L;
  38   1        LCD_WR_H;
  39   1        LCD_CS_H;
  40   1      }
  41          
  42          
  43          static void SdData(uint8_t data8)  //2014-06-10 V1.04更换夏瑞的LCD屏，驱动由ILI9328变更为ILI9341
  44          {
  45   1        LCD_RS_H;
  46   1        LCD_PORT =data8;
  47   1        LCD_CS_L;
  48   1        LCD_WR_L;
  49   1        LCD_WR_H;
  50   1        LCD_CS_H;
  51   1      }
  52          
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 2   

  53          void LCD_CtrlWrite_ILI9328(uint16_t i)
  54          {
  55   1        LCD_CS_L;
  56   1        LCD_RS_H;
  57   1        LCD_PORT =(uint8_t)(i/256);
  58   1        LCD_WR_L;
  59   1        LCD_WR_H;
  60   1        LCD_PORT =i%256;
  61   1        LCD_WR_L;
  62   1        LCD_WR_H;
  63   1        LCD_RS_H;
  64   1        LCD_CS_H;
  65   1      }
  66          
  67          void   LCD_CtrlWrite_Color(uint8_t color)
  68          {
  69   1        LCD_CtrlWrite_ILI9328(Table_Color[color]);
  70   1      }
  71          
  72          void LCD_Initial(void)
  73          {
  74   1       
  75   1        LCD_RST_L;
  76   1        delay_ms(20); // Delay 1ms
  77   1        LCD_RST_H;
  78   1        delay_ms(800); // Delay 10ms // This delay time is necessary
  79   1        
  80   1        SdCmd(0x11);//Wake up
  81   1        delay_ms(120); //Delay 120ms
  82   1        SdCmd(0x35);SdData(0x00);//TE ON   60Hz
  83   1            
  84   1        SdCmd(0x36);
  85   1        SdData(0x00); //RTN
  86   1        SdCmd(0x21); //黑白反相  
  87   1      
  88   1        SdCmd(0xb2);  //Porch setting
  89   1        SdData(0x0c);
  90   1        SdData(0x0c);
  91   1        SdData(0x00);
  92   1        SdData(0x33);
  93   1        SdData(0x33);
  94   1      
  95   1        SdCmd(0xb7);  //Gate Control
  96   1        SdData(0x35); //VGH=13.26V, VGL=-10.43V
  97   1      
  98   1        SdCmd(0xbb); //vcom setting
  99   1        SdData(0x19);
 100   1      
 101   1        SdCmd(0xc0); //LCM Control
 102   1        SdData(0x2c);
 103   1      
 104   1        SdCmd(0xc2);  //VDV and VRH Command Enable  
 105   1        SdData(0x01);
 106   1      
 107   1        SdCmd(0xc3); //VRH Set, VAP(GVDD) & VAN(GVCL)
 108   1        SdData(0x1d); 
 109   1      
 110   1        SdCmd(0xc4);  //VDV Set, 
 111   1        SdData(0x20); //VDV=0V
 112   1      
 113   1        SdCmd(0xc6);//Frame rate control in normal mode
 114   1        SdData(0x0f);//dot inversion & 60Hz
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 3   

 115   1      
 116   1        SdCmd(0xd0);   //Power control 1
 117   1        SdData(0xa4);
 118   1        SdData(0xa1); //AVDD=6.8V; AVCL=-4.8V; VDDS=2.3V
 119   1      
 120   1        SdCmd(0xe8);
 121   1        SdData(0x83);
 122   1      //--------------------------------ST7789VI gamma setting---------------------------------------//
 123   1        SdCmd(0xe0);
 124   1        SdData(0xd2);
 125   1        SdData(0x11);
 126   1        SdData(0x16);
 127   1        SdData(0x0d);
 128   1        SdData(0x0d);
 129   1        SdData(0x38);
 130   1        SdData(0x3d);
 131   1        SdData(0x44);
 132   1        SdData(0x4c);
 133   1        SdData(0x1c);
 134   1        SdData(0x15);
 135   1        SdData(0x15);
 136   1        SdData(0x1c);
 137   1        SdData(0x20);
 138   1      
 139   1      
 140   1        SdCmd(0xe1);
 141   1        SdData(0xd2);
 142   1        SdData(0x11);
 143   1        SdData(0x16);
 144   1        SdData(0x0d);
 145   1        SdData(0x0d);
 146   1        SdData(0x38);
 147   1        SdData(0x3d);
 148   1        SdData(0x44);
 149   1        SdData(0x4c);
 150   1        SdData(0x1c);
 151   1        SdData(0x15);
 152   1        SdData(0x15);
 153   1        SdData(0x1c);
 154   1        SdData(0x20);
 155   1      
 156   1        SdCmd(0x3a);SdData(0x55); // 8/16bit,65k colors
 157   1        SdCmd(0x29);             //Display on
 158   1      
 159   1        delay_ms(10);
 160   1      
 161   1        SdCmd(0x2a);
 162   1        SdData(0x00);
 163   1        SdData(0x00);
 164   1        SdData(0x00);
 165   1        SdData(0xEF);
 166   1      
 167   1        SdCmd(0x2b);
 168   1        SdData(0x00);
 169   1        SdData(0x00);
 170   1        SdData(0x01);
 171   1        SdData(0x3F);
 172   1      
 173   1        delay_ms(120);
 174   1        SdCmd(0x2c);
 175   1      }
 176          
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 4   

 177          void  LCD_CrtlWrite_Area(uint8_t SX,uint8_t EX,uint16_t SY,uint16_t EY)
 178          {
 179   1        SdCmd(0x2A);
 180   1        SdData(SX/256);
 181   1        SdData(SX%256);
 182   1        SdData(EX/256);
 183   1        SdData(EX%256);
 184   1        SdCmd(0x2B);
 185   1        SdData((uint8_t)(SY/256));
 186   1        SdData(SY%256);
 187   1        SdData((uint8_t)(EY/256));
 188   1        SdData(EY%256);
 189   1        SdCmd(0x2C);  
 190   1      }  
 191          
 192          
 193           //画矩形
 194          void Draw_Rectangle(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color, uint8_t
             - LineW)
 195          {
 196   1        uint16_t i,j,w,h;
 197   1        w=(uint16_t)End_X-(uint16_t)Start_X;
 198   1        h=End_Y-Start_Y;
 199   1        //画第一条线
 200   1        LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,Start_Y+LineW-1);
 201   1        for (j=0; j<LineW;j++)
 202   1        {
 203   2          for(i=0;i<=w;i++)
 204   2          {
 205   3            LCD_CtrlWrite_Color(color);
 206   3          }
 207   2        }
 208   1        LCD_CrtlWrite_Area(Start_X,End_X,End_Y-LineW+1,End_Y);
 209   1        for (j=0; j<LineW;j++)
 210   1        {
 211   2          for(i=0;i<=w;i++)
 212   2          {
 213   3            LCD_CtrlWrite_Color(color);
 214   3          }
 215   2        }
 216   1        LCD_CrtlWrite_Area(Start_X,Start_X+LineW-1,Start_Y,End_Y);
 217   1        for (j=0; j<=h;j++)
 218   1        {
 219   2          for(i=0;i<LineW;i++)
 220   2          {
 221   3            LCD_CtrlWrite_Color(color);
 222   3          }
 223   2        }
 224   1        LCD_CrtlWrite_Area(End_X-LineW+1,End_X,Start_Y,End_Y);
 225   1        for (j=0; j<=h;j++)
 226   1        {
 227   2          for(i=0;i<LineW;i++)
 228   2          {
 229   3            LCD_CtrlWrite_Color(color);
 230   3          }
 231   2        }
 232   1      }
 233          
 234           //画实体方块
 235          void Draw_Rectangle_Real(uint8_t Start_X, uint16_t Start_Y,uint8_t End_X, uint16_t End_Y,uint8_t color)
 236          {
 237   1        uint16_t i,j,w,h;
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 5   

 238   1        w=(uint16_t)End_X-(uint16_t)Start_X;
 239   1        h=End_Y-Start_Y;
 240   1        LCD_CrtlWrite_Area(Start_X,End_X,Start_Y,End_Y);
 241   1        for (j=0; j<=h;j++)
 242   1        {
 243   2          for(i=0;i<=w;i++)
 244   2          {
 245   3            LCD_CtrlWrite_Color(color);
 246   3          }
 247   2        }
 248   1      }
 249          
 250          //显示单色图形
 251          //X-坐标 0-239
 252          //Y-坐标 0-319
 253          //H-高   2-200
 254          //W-宽   1-100
 255          //gp 字符地址
 256          //NUM-图形编号
 257          //color-颜色
 258          static void DISP_MONO_GRAP(uint8_t  X1, uint16_t Y1,uint8_t  H, uint8_t  W,const uint8_t *gp,uint8_t color
             -)
 259          {
 260   1        uint16_t w,j;
 261   1        LCD_CrtlWrite_Area(X1,X1+H-1,Y1,Y1+W-1);
 262   1        for(w=0;w<((INT)H*((INT)W)/8);w++)
 263   1        {
 264   2          for(j=0;j<8;j++)
 265   2          {
 266   3            if((gp[w]&(0x01<<j))!=0)
 267   3            {
 268   4              LCD_CtrlWrite_Color(color);
 269   4            }
 270   3            else
 271   3            {
 272   4              LCD_CtrlWrite_Color(Back_Color);
 273   4            } 
 274   3          }
 275   2        }
 276   1      }
 277          
 278          
 279          void DISP_TEMP_30X56(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 280          {
 281   1        DISP_MONO_GRAP(X,Y,56,30,NUM30X56[NUM],color);
 282   1      }
 283          
 284          void DISP_TEMP_38X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 285          {
 286   1        DISP_MONO_GRAP(X,Y,64,38,NUM38X64[NUM],color);
 287   1      }
 288          
 289          void DISP_CQK25X24(uint8_t  X, uint16_t Y,uint8_t color)
 290          {
 291   1        DISP_MONO_GRAP(X,Y,24,25,CQK25X24,color);
 292   1      }
 293          
 294          void DISP_RTD28X24(uint8_t  X, uint16_t Y,uint8_t color)
 295          {
 296   1        DISP_MONO_GRAP(X,Y,24,28,RTD28X24,color);
 297   1      }
 298          
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 6   

 299          void DISP_JQK41X16(uint8_t  X, uint16_t Y,uint8_t color)
 300          {
 301   1        DISP_MONO_GRAP(X,Y,16,41,JQK41X16,color);
 302   1      }
 303          
 304          
 305          
 306          void DISP_HEAT_36X24(uint8_t  X, uint16_t Y,uint8_t color)
 307          {
 308   1        DISP_MONO_GRAP(X,Y,24,36,HEAT36X32,color);
 309   1      }
 310          
 311          void DISP_RH_17X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 312          {
 313   1        DISP_MONO_GRAP(X,Y,40,17,NUM17X40[NUM],color);
 314   1      }
 315          
 316          void DISP_FNT10X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 317          {
 318   1        DISP_MONO_GRAP(X,Y,24,10,FNT10X24[NUM],color);
 319   1      }
 320          
 321          void DISP_RH14X24(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 322          {
 323   1        DISP_MONO_GRAP(X,Y,24,14,RH14X24[NUM],color);
 324   1      }
 325          
 326          void DISP_TIME_10X16(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 327          {
 328   1        DISP_MONO_GRAP(X,Y,16,10,NUM10X16[NUM],color);
 329   1      }
 330          void DISP_ICO_32X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 331          {
 332   1        DISP_MONO_GRAP(X,Y,40,32,ICO32X40[NUM],color);  
 333   1      }
 334          
 335          void DISP_ICO_40X40(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 336          {
 337   1        DISP_MONO_GRAP(X,Y,40,40,ICO40X40[NUM],color);
 338   1      }
 339          
 340          
 341          
 342          void DISP_ICO_52X64(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 343          {
 344   1        DISP_MONO_GRAP(X,Y,48,48,ICO48X48[NUM],color);  
 345   1      }
 346          
 347          
 348          void DISP_DHM(uint8_t  X, uint16_t Y,uint8_t NUM,uint8_t color)
 349          {
 350   1        DISP_MONO_GRAP(X,Y,16,14,DHM14X16[NUM],color);
 351   1      }  
 352          
 353          void DISP_VHB80_56X40(uint8_t  X, uint16_t Y,uint8_t color)
 354          {
 355   1        DISP_MONO_GRAP(X,Y,40,56,VHB8056X40,color);
 356   1      }
 357          
 358          
 359          void Disp_YouChuang(uint8_t  X, uint16_t Y,uint8_t color) //80,71
 360          {
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 7   

 361   1        DISP_MONO_GRAP(X,Y,80,71,PIC_YouChuang,color); 
 362   1      }
 363          
 364          void Disp_WuChuang(uint8_t  X, uint16_t Y,uint8_t color)   //
 365          {
 366   1        DISP_MONO_GRAP(X,Y,80,71,PIC_WuChuang,color);
 367   1      }
 368          
 369          void DISP_VHB80_PIC(uint8_t color)
 370          { 
 371   1        DISP_VHB80_56X40(POS_VHB80_X,POS_VHB80_Y,color);
 372   1        DISP_HEAT_36X24(POS_HEAT_X,POS_HEAT_Y,color);    //加热盘图形    
 373   1        DISP_CQK25X24(POS_CQK_X,POS_CQK_Y,color);
 374   1        Draw_Rectangle_Real(POS_XQGS_X1,POS_XQGS_Y1,POS_XQGS_X2,POS_XQGS_Y2,color);  //画吸气管上部，下部
 375   1        Draw_Rectangle_Real(POS_XQGX_X1,POS_XQGX_Y1,POS_XQGX_X2,POS_XQGX_Y2,color); 
 376   1        DISP_RTD28X24(POS_RTD_X,POS_RTD_Y,color);    
 377   1        Draw_Rectangle_Real(POS_CQGS_X1,POS_CQGS_Y1,POS_CQGS_X2,POS_CQGS_Y2,color);  //画出气管上部，下部
 378   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGX_X2,POS_CQGX_Y2,color); ;  //画出气管上部，下部
 379   1        Draw_Rectangle_Real(POS_CQGX_X1,POS_CQGX_Y1,POS_CQGS_X2,POS_CQGX_Y1+1,color);  //画封口 
 380   1        DISP_JQK41X16(POS_JQK_X,POS_JQK_Y,color);     //画进气口
 381   1      }
 382          
 383          
 384          //画点
 385          //x,y:坐标
 386          //POINT_COLOR:此点的颜色
 387          static void LCD_DrawPoint(u16 x,u16 y,uint8_t color)
 388          { 
 389   1        SdCmd(0x2A);;  //设置光标位置 
 390   1        SdData((uint8_t)(x/256));   //开始点的X坐标
 391   1        SdData(x%256);
 392   1        SdData((uint8_t)(x/256));
 393   1        SdData(x%256);     
 394   1        SdCmd(0x2B);
 395   1        SdData((uint8_t)(y/256)); //开始点的Y坐标    
 396   1        SdData(y%256);     
 397   1        SdData((uint8_t)(y/256));      
 398   1        SdData(y%256);
 399   1        SdCmd(0x2C);    
 400   1        LCD_CtrlWrite_Color(color); //开始写入GRAM
 401   1      }
 402          
 403          //*  画点的方式
 404          //显示16*8 ASC字符  
 405          //X座标 0-239
 406          //Y座标 0-319
 407          //NUM字符
 408          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 409          //color字符的颜色 
 410          void DISP_FNT8X16(u16  X, u16 Y,u8 NUM,u8 mode,u8 color)
 411          {
 412   1        uint16_t  w,j;
 413   1        uint16_t F_x,F_y;
 414   1        u8 num=NUM;
 415   1      
 416   1        F_x = X;
 417   1        F_y = Y;   
 418   1      
 419   1        LCD_CrtlWrite_Area((uint8_t)X,(uint8_t)(X+15),Y,Y+7);
 420   1      
 421   1        num=num-(u8)(' ');//得到偏移后的值       
 422   1        for(w=0;w<8;w++)
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 8   

 423   1        {
 424   2          for(j=0;j<8;j++)
 425   2          {
 426   3            if((asc2_1608[num][(w*2)+1]&(0x01<<j))!=0)
 427   3            {
 428   4              if(mode == 0)
 429   4              {
 430   5                LCD_CtrlWrite_Color(color); //快速写
 431   5              }
 432   4              else
 433   4              {
 434   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 435   5              }
 436   4            }
 437   3            else
 438   3            {
 439   4              if(mode == 0)
 440   4              {
 441   5                LCD_CtrlWrite_Color(Back_Color);
 442   5              }
 443   4            }
 444   3            F_x++;        
 445   3          } 
 446   2          
 447   2          for(j=0;j<8;j++)
 448   2          {
 449   3            if((asc2_1608[num][w*2]&(0x01<<j))!=0)
 450   3            {
 451   4              if(mode == 0)
 452   4              {
 453   5                LCD_CtrlWrite_Color(color); //快速写
 454   5              }
 455   4              else
 456   4              {
 457   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 458   5              }
 459   4            }
 460   3            else
 461   3            {
 462   4              if(mode == 0)
 463   4              {
 464   5                LCD_CtrlWrite_Color(Back_Color);
 465   5              } 
 466   4            }
 467   3            F_x++;        
 468   3          }
 469   2          F_y++; 
 470   2          F_x = X; 
 471   2        } 
 472   1      }
 473          
 474          //*  画点的方式 可以显示叠加方式
 475          //显示24*12 ASC字符  
 476          //X座标 0-239
 477          //Y座标 0-319
 478          //NUM字符
 479          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色 速度快，画框方式
 480          //color字符的颜色 
 481          void DISP_FNT12X24(u16 X, u16 Y,u8 NUM,u8 mode,u8 color)
 482          {
 483   1        uint16_t  w,j;
 484   1        uint16_t F_x,F_y;    
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 9   

 485   1        u8 num=NUM;
 486   1      
 487   1        F_x = X;
 488   1        F_y = Y;
 489   1      
 490   1        LCD_CrtlWrite_Area((uint8_t)X,(uint8_t)(X+23),Y,Y+11);
 491   1      
 492   1        num=num-(u8)(' ');//得到偏移后的值       
 493   1        for(w=0;w<12;w++)
 494   1        {
 495   2          for(j=0;j<8;j++)
 496   2          {
 497   3            if((asc2_2412[num][(w*3)+2]&(0x01<<j))!=0)
 498   3            {
 499   4              if(mode == 0)
 500   4              {
 501   5                LCD_CtrlWrite_Color(color); //快速写
 502   5              }
 503   4              else
 504   4              {
 505   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 506   5              }
 507   4            }
 508   3            else
 509   3            {
 510   4              if(mode == 0)
 511   4              {
 512   5                LCD_CtrlWrite_Color(Back_Color);
 513   5              }
 514   4            }
 515   3            F_x++;  
 516   3          } 
 517   2          
 518   2          for(j=0;j<8;j++)
 519   2          {
 520   3            if((asc2_2412[num][(w*3)+1]&(0x01<<j))!=0)
 521   3            {
 522   4              if(mode == 0)
 523   4              {
 524   5                LCD_CtrlWrite_Color(color); //快速写
 525   5              }
 526   4              else
 527   4              {
 528   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 529   5              }
 530   4            }
 531   3            else
 532   3            {
 533   4              if(mode == 0)
 534   4              {
 535   5                LCD_CtrlWrite_Color(Back_Color);
 536   5              }
 537   4            }
 538   3            F_x++;
 539   3          } 
 540   2          for(j=0;j<8;j++)
 541   2          {
 542   3            if((asc2_2412[num][w*3]&(0x01<<j))!=0)
 543   3            {
 544   4              if(mode == 0)
 545   4              {
 546   5                LCD_CtrlWrite_Color(color); //快速写
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 10  

 547   5              }
 548   4              else
 549   4              {
 550   5                LCD_DrawPoint(F_x,F_y,color);//开始写入GRAM
 551   5              }
 552   4            }
 553   3            else
 554   3            {
 555   4              if(mode == 0)
 556   4              {
 557   5                LCD_CtrlWrite_Color(Back_Color);
 558   5              } 
 559   4            }
 560   3            F_x++;
 561   3          }  
 562   2          F_y++; 
 563   2          F_x = X; 
 564   2        } 
 565   1      }
 566          
 567          //在指定位置显示一个字符
 568          //x,y:起始坐标
 569          //size:字体大小 16/24
 570          //num:要显示的字符:" "--->"~" 
 571          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 572          //color:
 573          void LCD_ShowChar(u16 x,u16 y,u8 size,u8 num,u8 mode,u8 color)
 574          {                 
 575   1          
 576   1        //设置窗口
 577   1        if(size == 16)
 578   1        {
 579   2          DISP_FNT8X16(x,y,num,mode,color);
 580   2        } 
 581   1        else if(size == 24)
 582   1        {
 583   2          DISP_FNT12X24(x,y,num,mode,color);
 584   2        }
 585   1        else
 586   1        {
 587   2          //do nothing
 588   2        }
 589   1      }  
 590          
 591          
 592          //显示16*8 或24*12 ASC字符
 593          //x,y:起点坐标
 594          //height_x  字高度，也是字号,如16表示16*8，24表示24*12
 595          //width_y: 文字的最大长度，以免超出范围，最大是320 
 596          //*p:字符串起始地址
 597          //mode:叠加方式(1)不写背景色  还是非叠加方式(0)写背景色
 598          //字符的颜色
 599          void LCD_ShowString(u16 x, u16 y,u16 height_x,u16 width_y,const u8 *p,u8 mode,u8 color)
 600          { 
 601   1        uint8_t size;         
 602   1        uint8_t y0;
 603   1        u16 Y1;
 604   1        u16 X1;
 605   1        u16 WIDTH_Y;
 606   1        
 607   1        y0=(uint8_t)y;
 608   1        
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 11  

 609   1        Y1=y;
 610   1        X1=x;
 611   1        WIDTH_Y=width_y;
 612   1        
 613   1        //size = 16;
 614   1      
 615   1        //LCD_CrtlWrite_Area(0,239,0,319);
 616   1        size = (uint8_t)height_x;  //字号或高度
 617   1      
 618   1        WIDTH_Y+=Y1;//总宽度
 619   1        while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
 620   1        {       
 621   2          if(Y1>=WIDTH_Y){Y1=y0;Y1+=size;}
 622   2          //if(x>=height_x)break;//退出
 623   2          LCD_ShowChar(X1,Y1,size,*p,mode,color);
 624   2      
 625   2          Y1+=size/2; 
 626   2          p++;
 627   2        } 
 628   1      //  uint8_t size;         
 629   1      //  uint8_t y0;
 630   1      //  y0=y;
 631   1      //  //size = 16;
 632   1      
 633   1      //  //LCD_CrtlWrite_Area(0,239,0,319);
 634   1      //  size = height_x;  //字号或高度
 635   1      //  height_x+=x; //
 636   1      //  width_y+=y;//总宽度
 637   1      //  while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
 638   1      //  {       
 639   1      //    if(y>=width_y){y=y0;y+=size;}
 640   1      //    //if(x>=height_x)break;//退出
 641   1      //    LCD_ShowChar(x,y,size,*p,mode,color);
 642   1      
 643   1      //    y+=size/2;  
 644   1      //    p++;
 645   1      //  }   
 646   1      }
 647          
 648          //m^n函数
 649          //返回值:m^n次方.
 650          static u32 LCD_Pow(u8 m,u8 n)
 651          {
 652   1        u32 result=1;  
 653   1        while(n-->(u8)0)
 654   1        {
 655   2          result*=m;
 656   2        }    
 657   1        return result;
 658   1      }   
 659          
 660          
 661          //显示数字,高位为0,还是显示
 662          //x,y:起点坐标
 663          //size:字体大小  16或24  
 664          //len:长度(即要显示的位数)
 665          //num:数值(0~999999999);
 666          //mode:   7和0位使用
 667          //[7]:0,不填充;1,填充0.
 668          //[6:1]:保留
 669          //[0]:0,非叠加显示;1,叠加显示.
 670          //color:颜色 
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 12  

 671          void LCD_ShowxNum(u16 x,u16 y,u8 size,u8 len,u32 num,u8 mode,u8 color)
 672          {  
 673   1        u8 t,temp;
 674   1        u8 enshow=0;               
 675   1        for(t=0;t<len;t++)
 676   1        {
 677   2          temp=(num/LCD_Pow(10,len-t-1))%10;   //求需要显示的最高位
 678   2          if((enshow==0)&&(t<(len-1)))// 如果最高位为0   需要显示的长度
 679   2          {
 680   3            if(temp==0)
 681   3            {
 682   4              if((mode&(u8)0X80)!=(u8)0)
 683   4              {
 684   5                LCD_ShowChar(x,y+((size/2)*t),size,'0',mode&0X01,color);  //为0也要显示
 685   5              }
 686   4              else
 687   4              {
 688   5                LCD_ShowChar(x,y+((size/2)*t),size,' ',mode&0X01,color);  //为0不显示
 689   5              }         
 690   4              continue;
 691   4            }
 692   3            else
 693   3            {
 694   4              enshow=1; //最高位不是0或 
 695   4            }              
 696   3          }
 697   2          LCD_ShowChar(x,y+((size/2)*t),size,temp+'0',mode&0X01,color); 
 698   2        }
 699   1      } 
 700          
 701          //在指定位置画一个指定大小的圆
 702          //(x,y):中心点
 703          //r    :半径
 704          void Draw_Circle(u16 x0,u16 y0,u8 r,u8 color)
 705          {
 706   1        u16 a,b;
 707   1        u16 di;
 708   1      
 709   1        a=0;b=r;    
 710   1        di=3-(r<<1);             //判断下个点位置的标志
 711   1        while(a<=b)
 712   1        {
 713   2          LCD_DrawPoint(x0+a,y0-b,color);             //5
 714   2          LCD_DrawPoint(x0+b,y0-a,color);             //0           
 715   2          LCD_DrawPoint(x0+b,y0+a,color);             //4               
 716   2          LCD_DrawPoint(x0+a,y0+b,color);             //6 
 717   2          LCD_DrawPoint(x0-a,y0+b,color);             //1       
 718   2          LCD_DrawPoint(x0-b,y0+a,color);             
 719   2          LCD_DrawPoint(x0-a,y0-b,color);             //2             
 720   2          LCD_DrawPoint(x0-b,y0-a,color);             //7                
 721   2          a++;
 722   2          //使用Bresenham算法画圆     
 723   2          if(di<0)
 724   2          {
 725   3            di +=((4*a)+6); 
 726   3          }  
 727   2          else
 728   2          {
 729   3            di+=(10+(4*(a-b)));   
 730   3            b--;
 731   3          }                 
 732   2        }
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 13  

 733   1      } 
 734          
 735          void Refresh_Work_Mode(void)
 736          {
 737   1        Back_Color=WHITE18;
 738   1        if(Work_Mode==0)
 739   1        {
 740   2          Disp_WuChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 741   2        }else if(Work_Mode==1)
 742   1        {
 743   2          Disp_YouChuang(POS_YWC_X,POS_YWC_Y,PURPLE18);
 744   2        }else//无简易模式
 745   1        {
 746   2          //do nothing
 747   2        }
 748   1      }
 749          
 750          
 751          
 752          //在指定位置画一个指定大小的圆
 753          //(x,y):中心点
 754          //r    :半径
 755          void DrawWorkWindows(void)
 756          {
 757   1        LCD_LIGHT_CLOSE;
 758   1        //清除选择界面-----------------------------------------
 759   1        Draw_Rectangle_Real(0,0,239,319,WHITE18);//清屏
 760   1        Back_Color=WHITE18;
 761   1        Disp_WuChuang(POS_Select_WC_X,POS_Select_WC_Y,WHITE18);
 762   1        Disp_YouChuang(POS_Select_YC_X,POS_Select_YC_Y,WHITE18);
 763   1        Draw_Rectangle(75,182,162,262,WHITE18,4);//
 764   1        Draw_Rectangle(75,58,162,136,WHITE18,4);
 765   1        Refresh_Work_Mode();
 766   1        Back_Color=WHITE18;
 767   1        DISP_ICO_52X64(POS_ICO_TEMP_X,POS_ICO_TEMP_Y,0,BLACK18);
 768   1        DISP_ICO_40X40(POS_ICO_SHIDU_X,POS_ICO_TEMP_Y,0,BLACK18);
 769   1        DISP_ICO_40X40(POS_ICO_TIME_X,POS_ICO_TEMP_Y,1,BLACK18);//显示时间
 770   1        //画点
 771   1        Draw_Rectangle_Real(POS_RT_TEMP_X+1,POS_RT_TEMP_Y+67,POS_RT_TEMP_X+8,POS_RT_TEMP_Y+71,BLACK18); //画点
 772   1        //显示单位
 773   1        DISP_ICO_32X40(POS_RT_TEMP_X,POS_RT_TEMP_Y+(34*3)+5,ICO_DU,BLACK18);
 774   1      
 775   1        //显示湿度单位
 776   1        DISP_ICO_32X40(POS_RT_RH_X,POS_RT_RH_Y+(19*2),ICO_PER,BLACK18);  
 777   1        if(data_flash.Language == Lan_English)//英语
 778   1        {
 779   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,0,BLACK18);
 780   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,1,BLACK18);
 781   2        }
 782   1        else if(data_flash.Language == Lan_Portuguese)//葡萄牙语
 783   1        {
 784   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,2,BLACK18);
 785   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 786   2        }
 787   1        else if(data_flash.Language == Lan_Spanish)//西班牙语
 788   1        {
 789   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
 790   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 791   2        }
 792   1        else if(data_flash.Language == Lan_French)//法语
 793   1        {
 794   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+70,1,BLACK18);
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 14  

 795   2          DISP_RH14X24(POS_RT_RH_X,POS_RT_RH_Y+84,0,BLACK18);
 796   2        } 
 797   1        else
 798   1        {
 799   2          //do nothing
 800   2        }
 801   1           
 802   1        DISP_DHM(POS_DMH_X,POS_DMH_Y,0,BLACK18);
 803   1        DISP_DHM(POS_DMH_X,POS_DMH_Y+25,1,BLACK18);
 804   1        DISP_DHM(POS_DMH_X,POS_DMH_Y+(25*2),2,BLACK18);   
 805   1        //显示运行时间
 806   1      
 807   1        Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+18,POS_ICO_TIME_X+2,POS_DMH_Y+20,BLACK18);
 808   1        Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+18,POS_ICO_TIME_X+12,POS_DMH_Y+20,BLACK18);
 809   1      
 810   1        Draw_Rectangle_Real(POS_ICO_TIME_X,POS_DMH_Y+43,POS_ICO_TIME_X+2,POS_DMH_Y+45,BLACK18);
 811   1        Draw_Rectangle_Real(POS_ICO_TIME_X+10,POS_DMH_Y+43,POS_ICO_TIME_X+12,POS_DMH_Y+45,BLACK18);
 812   1      
 813   1        DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y,2,BLACK18);
 814   1        DISP_TIME_10X16(POS_SYSDATE_X,POS_SYSDATE_Y+12,0,BLACK18);
 815   1      
 816   1        Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+48,POS_SYSDATE_X+2,POS_SYSDATE_Y+50,BLACK18);
 817   1      
 818   1        Draw_Rectangle_Real(POS_SYSDATE_X,POS_SYSDATE_Y+76,POS_SYSDATE_X+2,POS_SYSDATE_Y+78,BLACK18);
 819   1      
 820   1        Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+24,POS_SYSTIME_X+2,POS_SYSTIME_Y+26,BLACK18);
 821   1        Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+24,POS_SYSTIME_X+12,POS_SYSTIME_Y+26,BLACK18);
 822   1      
 823   1        Draw_Rectangle_Real(POS_SYSTIME_X,POS_SYSTIME_Y+52,POS_SYSTIME_X+2,POS_SYSTIME_Y+54,BLACK18);
 824   1        Draw_Rectangle_Real(POS_SYSTIME_X+10,POS_SYSTIME_Y+52,POS_SYSTIME_X+12,POS_SYSTIME_Y+54,BLACK18);     
 825   1      } 
 826          
 827          //显示版本号
 828          //VHB15A_EN_VM_V1.07      EN-英文国家   VM-VM默认功能及界面
 829          void  LCD_Show_Verion(void)
 830          {
 831   1        LCD_ShowString(60,20,16,200,"VHB15A",0,BLACK18);  //显示机种名
 832   1      
 833   1        LCD_ShowString(60,68,16,200,"---EN",0,BLACK18); //显示版本语言    
 834   1      
 835   1        LCD_ShowString(60,108,16,200,"---VM",0,BLACK18);  //显示客户 
 836   1      
 837   1        
 838   1      
 839   1      //显示版本号
 840   1        LCD_ShowString(40,20,16,200,VHB15A_VER,0,GRAY18); 
 841   1      }
 842          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6038    ----
   CONSTANT SIZE    =  22159    ----
   XDATA SIZE       =      1     192
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
C51 COMPILER V9.52.0.0   LCD                                                               04/04/2019 16:21:57 PAGE 15  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
